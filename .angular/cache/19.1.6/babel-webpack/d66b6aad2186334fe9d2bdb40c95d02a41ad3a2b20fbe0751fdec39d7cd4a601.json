{"ast":null,"code":"!\n/**\n* Highcharts JS v12.1.2 (2024-12-21)\n* @module highcharts/highcharts\n*\n* (c) 2009-2024 Torstein Honsi\n*\n* License: www.highcharts.com/license\n*/\nfunction (t, e) {\n  \"object\" == typeof exports && \"object\" == typeof module ? (t._Highcharts = e(), module.exports = t._Highcharts) : \"function\" == typeof define && define.amd ? define(\"highcharts/highcharts\", [], e) : \"object\" == typeof exports ? (t._Highcharts = e(), exports.highcharts = t._Highcharts) : (t.Highcharts && t.Highcharts.error(16, !0), t.Highcharts = e());\n}(\"undefined\" == typeof window ? this : window, () => (() => {\n  \"use strict\";\n\n  let t, e, i, s, o;\n  var r,\n    n,\n    a,\n    h,\n    l,\n    d,\n    c,\n    p,\n    u,\n    g,\n    f,\n    m,\n    x,\n    y,\n    b,\n    v,\n    M,\n    k,\n    w,\n    S,\n    A,\n    T,\n    P = {};\n  P.d = (t, e) => {\n    for (var i in e) P.o(e, i) && !P.o(t, i) && Object.defineProperty(t, i, {\n      enumerable: !0,\n      get: e[i]\n    });\n  }, P.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e);\n  var C = {};\n  P.d(C, {\n    default: () => gr\n  }), function (t) {\n    t.SVG_NS = \"http://www.w3.org/2000/svg\", t.product = \"Highcharts\", t.version = \"12.1.2\", t.win = \"undefined\" != typeof window ? window : {}, t.doc = t.win.document, t.svg = t.doc && t.doc.createElementNS && !!t.doc.createElementNS(t.SVG_NS, \"svg\").createSVGRect, t.pageLang = t.doc?.documentElement?.closest(\"[lang]\")?.lang, t.userAgent = t.win.navigator && t.win.navigator.userAgent || \"\", t.isChrome = t.win.chrome, t.isFirefox = -1 !== t.userAgent.indexOf(\"Firefox\"), t.isMS = /(edge|msie|trident)/i.test(t.userAgent) && !t.win.opera, t.isSafari = !t.isChrome && -1 !== t.userAgent.indexOf(\"Safari\"), t.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(t.userAgent), t.isWebKit = -1 !== t.userAgent.indexOf(\"AppleWebKit\"), t.deg2rad = 2 * Math.PI / 360, t.marginNames = [\"plotTop\", \"marginRight\", \"marginBottom\", \"plotLeft\"], t.noop = function () {}, t.supportsPassiveEvents = function () {\n      let e = !1;\n      if (!t.isMS) {\n        let i = Object.defineProperty({}, \"passive\", {\n          get: function () {\n            e = !0;\n          }\n        });\n        t.win.addEventListener && t.win.removeEventListener && (t.win.addEventListener(\"testPassive\", t.noop, i), t.win.removeEventListener(\"testPassive\", t.noop, i));\n      }\n      return e;\n    }(), t.charts = [], t.composed = [], t.dateFormats = {}, t.seriesTypes = {}, t.symbolSizes = {}, t.chartCount = 0;\n  }(r || (r = {}));\n  let O = r,\n    {\n      charts: E,\n      doc: L,\n      win: B\n    } = O;\n  function I(t, e, i, s) {\n    let o = e ? \"Highcharts error\" : \"Highcharts warning\";\n    32 === t && (t = `${o}: Deprecated member`);\n    let r = H(t),\n      n = r ? `${o} #${t}: www.highcharts.com/errors/${t}/` : t.toString();\n    if (void 0 !== s) {\n      let t = \"\";\n      r && (n += \"?\"), Z(s, function (e, i) {\n        t += `\n - ${i}: ${e}`, r && (n += encodeURI(i) + \"=\" + encodeURI(e));\n      }), n += t;\n    }\n    J(O, \"displayError\", {\n      chart: i,\n      code: t,\n      message: n,\n      params: s\n    }, function () {\n      if (e) throw Error(n);\n      B.console && -1 === I.messages.indexOf(n) && console.warn(n);\n    }), I.messages.push(n);\n  }\n  function D(t, e) {\n    return parseInt(t, e || 10);\n  }\n  function R(t) {\n    return \"string\" == typeof t;\n  }\n  function N(t) {\n    let e = Object.prototype.toString.call(t);\n    return \"[object Array]\" === e || \"[object Array Iterator]\" === e;\n  }\n  function z(t, e) {\n    return !!t && \"object\" == typeof t && (!e || !N(t));\n  }\n  function W(t) {\n    return z(t) && \"number\" == typeof t.nodeType;\n  }\n  function G(t) {\n    let e = t && t.constructor;\n    return !!(z(t, !0) && !W(t) && e && e.name && \"Object\" !== e.name);\n  }\n  function H(t) {\n    return \"number\" == typeof t && !isNaN(t) && t < 1 / 0 && t > -1 / 0;\n  }\n  function F(t) {\n    return null != t;\n  }\n  function X(t, e, i) {\n    let s;\n    let o = R(e) && !F(i),\n      r = (e, i) => {\n        F(e) ? t.setAttribute(i, e) : o ? (s = t.getAttribute(i)) || \"class\" !== i || (s = t.getAttribute(i + \"Name\")) : t.removeAttribute(i);\n      };\n    return R(e) ? r(i, e) : Z(e, r), s;\n  }\n  function Y(t) {\n    return N(t) ? t : [t];\n  }\n  function j(t, e) {\n    let i;\n    for (i in t || (t = {}), e) t[i] = e[i];\n    return t;\n  }\n  function U() {\n    let t = arguments,\n      e = t.length;\n    for (let i = 0; i < e; i++) {\n      let e = t[i];\n      if (null != e) return e;\n    }\n  }\n  function V(t, e) {\n    j(t.style, e);\n  }\n  function $(t) {\n    return Math.pow(10, Math.floor(Math.log(t) / Math.LN10));\n  }\n  function _(t, e) {\n    return t > 1e14 ? t : parseFloat(t.toPrecision(e || 14));\n  }\n  (I || (I = {})).messages = [], Math.easeInOutSine = function (t) {\n    return -.5 * (Math.cos(Math.PI * t) - 1);\n  };\n  let q = Array.prototype.find ? function (t, e) {\n    return t.find(e);\n  } : function (t, e) {\n    let i;\n    let s = t.length;\n    for (i = 0; i < s; i++) if (e(t[i], i)) return t[i];\n  };\n  function Z(t, e, i) {\n    for (let s in t) Object.hasOwnProperty.call(t, s) && e.call(i || t[s], t[s], s, t);\n  }\n  function K(t, e, i) {\n    function s(e, i) {\n      let s = t.removeEventListener;\n      s && s.call(t, e, i, !1);\n    }\n    function o(i) {\n      let o, r;\n      t.nodeName && (e ? (o = {})[e] = !0 : o = i, Z(o, function (t, e) {\n        if (i[e]) for (r = i[e].length; r--;) s(e, i[e][r].fn);\n      }));\n    }\n    let r = \"function\" == typeof t && t.prototype || t;\n    if (Object.hasOwnProperty.call(r, \"hcEvents\")) {\n      let t = r.hcEvents;\n      if (e) {\n        let r = t[e] || [];\n        i ? (t[e] = r.filter(function (t) {\n          return i !== t.fn;\n        }), s(e, i)) : (o(t), t[e] = []);\n      } else o(t), delete r.hcEvents;\n    }\n  }\n  function J(t, e, i, s) {\n    if (i = i || {}, L.createEvent && (t.dispatchEvent || t.fireEvent && t !== O)) {\n      let s = L.createEvent(\"Events\");\n      s.initEvent(e, !0, !0), i = j(s, i), t.dispatchEvent ? t.dispatchEvent(i) : t.fireEvent(e, i);\n    } else if (t.hcEvents) {\n      i.target || j(i, {\n        preventDefault: function () {\n          i.defaultPrevented = !0;\n        },\n        target: t,\n        type: e\n      });\n      let s = [],\n        o = t,\n        r = !1;\n      for (; o.hcEvents;) Object.hasOwnProperty.call(o, \"hcEvents\") && o.hcEvents[e] && (s.length && (r = !0), s.unshift.apply(s, o.hcEvents[e])), o = Object.getPrototypeOf(o);\n      r && s.sort((t, e) => t.order - e.order), s.forEach(e => {\n        !1 === e.fn.call(t, i) && i.preventDefault();\n      });\n    }\n    s && !i.defaultPrevented && s.call(t, i);\n  }\n  let Q = function () {\n    let e = Math.random().toString(36).substring(2, 9) + \"-\",\n      i = 0;\n    return function () {\n      return \"highcharts-\" + (t ? \"\" : e) + i++;\n    };\n  }();\n  B.jQuery && (B.jQuery.fn.highcharts = function () {\n    let t = [].slice.call(arguments);\n    if (this[0]) return t[0] ? (new O[R(t[0]) ? t.shift() : \"Chart\"](this[0], t[0], t[1]), this) : E[X(this[0], \"data-highcharts-chart\")];\n  });\n  let tt = {\n      addEvent: function (t, e, i, s = {}) {\n        let o = \"function\" == typeof t && t.prototype || t;\n        Object.hasOwnProperty.call(o, \"hcEvents\") || (o.hcEvents = {});\n        let r = o.hcEvents;\n        O.Point && t instanceof O.Point && t.series && t.series.chart && (t.series.chart.runTrackerClick = !0);\n        let n = t.addEventListener;\n        n && n.call(t, e, i, !!O.supportsPassiveEvents && {\n          passive: void 0 === s.passive ? -1 !== e.indexOf(\"touch\") : s.passive,\n          capture: !1\n        }), r[e] || (r[e] = []);\n        let a = {\n          fn: i,\n          order: \"number\" == typeof s.order ? s.order : 1 / 0\n        };\n        return r[e].push(a), r[e].sort((t, e) => t.order - e.order), function () {\n          K(t, e, i);\n        };\n      },\n      arrayMax: function (t) {\n        let e = t.length,\n          i = t[0];\n        for (; e--;) t[e] > i && (i = t[e]);\n        return i;\n      },\n      arrayMin: function (t) {\n        let e = t.length,\n          i = t[0];\n        for (; e--;) t[e] < i && (i = t[e]);\n        return i;\n      },\n      attr: X,\n      clamp: function (t, e, i) {\n        return t > e ? t < i ? t : i : e;\n      },\n      clearTimeout: function (t) {\n        F(t) && clearTimeout(t);\n      },\n      correctFloat: _,\n      createElement: function (t, e, i, s, o) {\n        let r = L.createElement(t);\n        return e && j(r, e), o && V(r, {\n          padding: \"0\",\n          border: \"none\",\n          margin: \"0\"\n        }), i && V(r, i), s && s.appendChild(r), r;\n      },\n      crisp: function (t, e = 0, i) {\n        let s = e % 2 / 2,\n          o = i ? -1 : 1;\n        return (Math.round(t * o - s) + s) * o;\n      },\n      css: V,\n      defined: F,\n      destroyObjectProperties: function (t, e, i) {\n        Z(t, function (s, o) {\n          s !== e && s?.destroy && s.destroy(), (s?.destroy || !i) && delete t[o];\n        });\n      },\n      diffObjects: function (t, e, i, s) {\n        let o = {};\n        return !function t(e, o, r, n) {\n          let a = i ? o : e;\n          Z(e, function (i, h) {\n            if (!n && s && s.indexOf(h) > -1 && o[h]) {\n              i = Y(i), r[h] = [];\n              for (let e = 0; e < Math.max(i.length, o[h].length); e++) o[h][e] && (void 0 === i[e] ? r[h][e] = o[h][e] : (r[h][e] = {}, t(i[e], o[h][e], r[h][e], n + 1)));\n            } else z(i, !0) && !i.nodeType ? (r[h] = N(i) ? [] : {}, t(i, o[h] || {}, r[h], n + 1), 0 !== Object.keys(r[h]).length || \"colorAxis\" === h && 0 === n || delete r[h]) : (e[h] !== o[h] || h in e && !(h in o)) && \"__proto__\" !== h && \"constructor\" !== h && (r[h] = a[h]);\n          });\n        }(t, e, o, 0), o;\n      },\n      discardElement: function (t) {\n        t && t.parentElement && t.parentElement.removeChild(t);\n      },\n      erase: function (t, e) {\n        let i = t.length;\n        for (; i--;) if (t[i] === e) {\n          t.splice(i, 1);\n          break;\n        }\n      },\n      error: I,\n      extend: j,\n      extendClass: function (t, e) {\n        let i = function () {};\n        return i.prototype = new t(), j(i.prototype, e), i;\n      },\n      find: q,\n      fireEvent: J,\n      getAlignFactor: (t = \"\") => ({\n        center: .5,\n        right: 1,\n        middle: .5,\n        bottom: 1\n      })[t] || 0,\n      getClosestDistance: function (t, e) {\n        let i, s, o, r;\n        let n = !e;\n        return t.forEach(t => {\n          if (t.length > 1) for (r = s = t.length - 1; r > 0; r--) (o = t[r] - t[r - 1]) < 0 && !n ? (e?.(), e = void 0) : o && (void 0 === i || o < i) && (i = o);\n        }), i;\n      },\n      getMagnitude: $,\n      getNestedProperty: function (t, e) {\n        let i = t.split(\".\");\n        for (; i.length && F(e);) {\n          let t = i.shift();\n          if (void 0 === t || \"__proto__\" === t) return;\n          if (\"this\" === t) {\n            let t;\n            return z(e) && (t = e[\"@this\"]), t ?? e;\n          }\n          let s = e[t.replace(/[\\\\'\"]/g, \"\")];\n          if (!F(s) || \"function\" == typeof s || \"number\" == typeof s.nodeType || s === B) return;\n          e = s;\n        }\n        return e;\n      },\n      getStyle: function t(e, i, s) {\n        let o;\n        if (\"width\" === i) {\n          let i = Math.min(e.offsetWidth, e.scrollWidth),\n            s = e.getBoundingClientRect && e.getBoundingClientRect().width;\n          return s < i && s >= i - 1 && (i = Math.floor(s)), Math.max(0, i - (t(e, \"padding-left\", !0) || 0) - (t(e, \"padding-right\", !0) || 0));\n        }\n        if (\"height\" === i) return Math.max(0, Math.min(e.offsetHeight, e.scrollHeight) - (t(e, \"padding-top\", !0) || 0) - (t(e, \"padding-bottom\", !0) || 0));\n        let r = B.getComputedStyle(e, void 0);\n        return r && (o = r.getPropertyValue(i), U(s, \"opacity\" !== i) && (o = D(o))), o;\n      },\n      insertItem: function (t, e) {\n        let i;\n        let s = t.options.index,\n          o = e.length;\n        for (i = t.options.isInternal ? o : 0; i < o + 1; i++) if (!e[i] || H(s) && s < U(e[i].options.index, e[i]._i) || e[i].options.isInternal) {\n          e.splice(i, 0, t);\n          break;\n        }\n        return i;\n      },\n      isArray: N,\n      isClass: G,\n      isDOMElement: W,\n      isFunction: function (t) {\n        return \"function\" == typeof t;\n      },\n      isNumber: H,\n      isObject: z,\n      isString: R,\n      merge: function (t, ...e) {\n        let i,\n          s = [t, ...e],\n          o = {},\n          r = function (t, e) {\n            return \"object\" != typeof t && (t = {}), Z(e, function (i, s) {\n              \"__proto__\" !== s && \"constructor\" !== s && (!z(i, !0) || G(i) || W(i) ? t[s] = e[s] : t[s] = r(t[s] || {}, i));\n            }), t;\n          };\n        !0 === t && (o = s[1], s = Array.prototype.slice.call(s, 2));\n        let n = s.length;\n        for (i = 0; i < n; i++) o = r(o, s[i]);\n        return o;\n      },\n      normalizeTickInterval: function (t, e, i, s, o) {\n        let r,\n          n = t;\n        i = U(i, $(t));\n        let a = t / i;\n        for (!e && (e = o ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === s && (1 === i ? e = e.filter(function (t) {\n          return t % 1 == 0;\n        }) : i <= .1 && (e = [1 / i]))), r = 0; r < e.length && (n = e[r], (!o || !(n * i >= t)) && (o || !(a <= (e[r] + (e[r + 1] || e[r])) / 2))); r++);\n        return _(n * i, -Math.round(Math.log(.001) / Math.LN10));\n      },\n      objectEach: Z,\n      offset: function (t) {\n        let e = L.documentElement,\n          i = t.parentElement || t.parentNode ? t.getBoundingClientRect() : {\n            top: 0,\n            left: 0,\n            width: 0,\n            height: 0\n          };\n        return {\n          top: i.top + (B.pageYOffset || e.scrollTop) - (e.clientTop || 0),\n          left: i.left + (B.pageXOffset || e.scrollLeft) - (e.clientLeft || 0),\n          width: i.width,\n          height: i.height\n        };\n      },\n      pad: function (t, e, i) {\n        return Array((e || 2) + 1 - String(t).replace(\"-\", \"\").length).join(i || \"0\") + t;\n      },\n      pick: U,\n      pInt: D,\n      pushUnique: function (t, e) {\n        return 0 > t.indexOf(e) && !!t.push(e);\n      },\n      relativeLength: function (t, e, i) {\n        return /%$/.test(t) ? e * parseFloat(t) / 100 + (i || 0) : parseFloat(t);\n      },\n      removeEvent: K,\n      replaceNested: function (t, ...e) {\n        let i, s;\n        do for (s of (i = t, e)) t = t.replace(s[0], s[1]); while (t !== i);\n        return t;\n      },\n      splat: Y,\n      stableSort: function (t, e) {\n        let i, s;\n        let o = t.length;\n        for (s = 0; s < o; s++) t[s].safeI = s;\n        for (t.sort(function (t, s) {\n          return 0 === (i = e(t, s)) ? t.safeI - s.safeI : i;\n        }), s = 0; s < o; s++) delete t[s].safeI;\n      },\n      syncTimeout: function (t, e, i) {\n        return e > 0 ? setTimeout(t, e, i) : (t.call(0, i), -1);\n      },\n      timeUnits: {\n        millisecond: 1,\n        second: 1e3,\n        minute: 6e4,\n        hour: 36e5,\n        day: 864e5,\n        week: 6048e5,\n        month: 24192e5,\n        year: 314496e5\n      },\n      ucfirst: function (t) {\n        return R(t) ? t.substring(0, 1).toUpperCase() + t.substring(1) : String(t);\n      },\n      uniqueKey: Q,\n      useSerialIds: function (e) {\n        return t = U(e, t);\n      },\n      wrap: function (t, e, i) {\n        let s = t[e];\n        t[e] = function () {\n          let t = arguments,\n            e = this;\n          return i.apply(this, [function () {\n            return s.apply(e, arguments.length ? arguments : t);\n          }].concat([].slice.call(arguments)));\n        };\n      }\n    },\n    {\n      pageLang: te,\n      win: ti\n    } = O,\n    {\n      defined: ts,\n      error: to,\n      extend: tr,\n      isNumber: tn,\n      isObject: ta,\n      isString: th,\n      merge: tl,\n      objectEach: td,\n      pad: tc,\n      splat: tp,\n      timeUnits: tu,\n      ucfirst: tg\n    } = tt,\n    tf = O.isSafari && ti.Intl && !ti.Intl.DateTimeFormat.prototype.formatRange,\n    tm = t => void 0 === t.main,\n    tx = t => [\"D\", \"L\", \"M\", \"X\", \"J\", \"V\", \"S\"].indexOf(t),\n    ty = class {\n      constructor(t) {\n        this.options = {\n          timezone: \"UTC\"\n        }, this.variableTimezone = !1, this.Date = ti.Date, this.update(t);\n      }\n      update(t = {}) {\n        this.dTLCache = {}, this.options = t = tl(!0, this.options, t);\n        let {\n          timezoneOffset: e,\n          useUTC: i\n        } = t;\n        this.Date = t.Date || ti.Date || Date;\n        let s = t.timezone;\n        ts(i) && (s = i ? \"UTC\" : void 0), e && e % 60 == 0 && (s = \"Etc/GMT\" + (e > 0 ? \"+\" : \"\") + e / 60), this.variableTimezone = \"UTC\" !== s && s?.indexOf(\"Etc/GMT\") !== 0, this.timezone = s, [\"months\", \"shortMonths\", \"weekdays\", \"shortWeekdays\"].forEach(t => {\n          let e = /months/i.test(t),\n            i = /short/.test(t),\n            s = {\n              timeZone: \"UTC\"\n            };\n          s[e ? \"month\" : \"weekday\"] = i ? \"short\" : \"long\", this[t] = (e ? [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] : [3, 4, 5, 6, 7, 8, 9]).map(t => this.dateFormat(s, (e ? 31 : 1) * 24 * 36e5 * t));\n        });\n      }\n      toParts(t) {\n        let [e, i, s, o, r, n, a] = this.dateTimeFormat({\n          weekday: \"narrow\",\n          day: \"numeric\",\n          month: \"numeric\",\n          year: \"numeric\",\n          hour: \"numeric\",\n          minute: \"numeric\",\n          second: \"numeric\"\n        }, t, \"es\").split(/(?:, |\\/|:)/g);\n        return [o, +s - 1, i, r, n, a, Math.floor(Number(t) || 0) % 1e3, tx(e)].map(Number);\n      }\n      dateTimeFormat(t, e, i = this.options.locale || te) {\n        let s = JSON.stringify(t) + i;\n        th(t) && (t = this.str2dtf(t));\n        let o = this.dTLCache[s];\n        if (!o) {\n          t.timeZone ?? (t.timeZone = this.timezone);\n          try {\n            o = new Intl.DateTimeFormat(i, t);\n          } catch (e) {\n            /Invalid time zone/i.test(e.message) ? (to(34), t.timeZone = \"UTC\", o = new Intl.DateTimeFormat(i, t)) : to(e.message, !1);\n          }\n        }\n        return this.dTLCache[s] = o, o?.format(e) || \"\";\n      }\n      str2dtf(t, e = {}) {\n        let i = {\n          L: {\n            fractionalSecondDigits: 3\n          },\n          S: {\n            second: \"2-digit\"\n          },\n          M: {\n            minute: \"numeric\"\n          },\n          H: {\n            hour: \"2-digit\"\n          },\n          k: {\n            hour: \"numeric\"\n          },\n          E: {\n            weekday: \"narrow\"\n          },\n          a: {\n            weekday: \"short\"\n          },\n          A: {\n            weekday: \"long\"\n          },\n          d: {\n            day: \"2-digit\"\n          },\n          e: {\n            day: \"numeric\"\n          },\n          b: {\n            month: \"short\"\n          },\n          B: {\n            month: \"long\"\n          },\n          m: {\n            month: \"2-digit\"\n          },\n          o: {\n            month: \"numeric\"\n          },\n          y: {\n            year: \"2-digit\"\n          },\n          Y: {\n            year: \"numeric\"\n          }\n        };\n        return Object.keys(i).forEach(s => {\n          -1 !== t.indexOf(s) && tr(e, i[s]);\n        }), e;\n      }\n      makeTime(t, e, i = 1, s = 0, o, r, n) {\n        let a = this.Date.UTC(t, e, i, s, o || 0, r || 0, n || 0);\n        if (\"UTC\" !== this.timezone) {\n          let t = this.getTimezoneOffset(a);\n          if (a += t, -1 !== [2, 3, 8, 9, 10, 11].indexOf(e) && (s < 5 || s > 20)) {\n            let e = this.getTimezoneOffset(a);\n            t !== e ? a += e - t : t - 36e5 !== this.getTimezoneOffset(a - 36e5) || tf || (a -= 36e5);\n          }\n        }\n        return a;\n      }\n      parse(t) {\n        if (!th(t)) return t ?? void 0;\n        let e = (t = t.replace(/\\//g, \"-\").replace(/(GMT|UTC)/, \"\")).indexOf(\"Z\") > -1 || /([+-][0-9]{2}):?[0-9]{2}$/.test(t),\n          i = /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/.test(t);\n        e || i || (t += \"Z\");\n        let s = Date.parse(t);\n        if (tn(s)) return s + (!e || i ? this.getTimezoneOffset(s) : 0);\n      }\n      getTimezoneOffset(t) {\n        if (\"UTC\" !== this.timezone) {\n          let [e, i, s, o, r = 0] = this.dateTimeFormat({\n              timeZoneName: \"shortOffset\"\n            }, t, \"en\").split(/(GMT|:)/).map(Number),\n            n = -(36e5 * (s + r / 60));\n          if (tn(n)) return n;\n        }\n        return 0;\n      }\n      dateFormat(t, e, i) {\n        let s = O.defaultOptions?.lang;\n        if (!ts(e) || isNaN(e)) return s?.invalidDate || \"\";\n        if (th(t = t ?? \"%Y-%m-%d %H:%M:%S\")) {\n          let i;\n          let s = /%\\[([a-zA-Z]+)\\]/g;\n          for (; i = s.exec(t);) t = t.replace(i[0], this.dateTimeFormat(i[1], e));\n        }\n        if (th(t) && -1 !== t.indexOf(\"%\")) {\n          let i = this,\n            [o, r, n, a, h, l, d, c] = this.toParts(e),\n            p = s?.weekdays || this.weekdays,\n            u = s?.shortWeekdays || this.shortWeekdays,\n            g = s?.months || this.months,\n            f = s?.shortMonths || this.shortMonths;\n          td(tr({\n            a: u ? u[c] : p[c].substr(0, 3),\n            A: p[c],\n            d: tc(n),\n            e: tc(n, 2, \" \"),\n            w: c,\n            b: f[r],\n            B: g[r],\n            m: tc(r + 1),\n            o: r + 1,\n            y: o.toString().substr(2, 2),\n            Y: o,\n            H: tc(a),\n            k: a,\n            I: tc(a % 12 || 12),\n            l: a % 12 || 12,\n            M: tc(h),\n            p: a < 12 ? \"AM\" : \"PM\",\n            P: a < 12 ? \"am\" : \"pm\",\n            S: tc(l),\n            L: tc(d, 3)\n          }, O.dateFormats), function (s, o) {\n            if (th(t)) for (; -1 !== t.indexOf(\"%\" + o);) t = t.replace(\"%\" + o, \"function\" == typeof s ? s.call(i, e) : s);\n          });\n        } else if (ta(t)) {\n          let i = (this.getTimezoneOffset(e) || 0) / 36e5,\n            s = this.timezone || \"Etc/GMT\" + (i >= 0 ? \"+\" : \"\") + i,\n            {\n              prefix: o = \"\",\n              suffix: r = \"\"\n            } = t;\n          t = o + this.dateTimeFormat(tr({\n            timeZone: s\n          }, t), e) + r;\n        }\n        return i ? tg(t) : t;\n      }\n      resolveDTLFormat(t) {\n        return ta(t, !0) ? ta(t, !0) && tm(t) ? {\n          main: t\n        } : t : {\n          main: (t = tp(t))[0],\n          from: t[1],\n          to: t[2]\n        };\n      }\n      getTimeTicks(t, e, i, s) {\n        let o = this,\n          r = [],\n          n = {},\n          {\n            count: a = 1,\n            unitRange: h\n          } = t,\n          [l, d, c, p, u, g] = o.toParts(e),\n          f = (e || 0) % 1e3,\n          m;\n        if (s ?? (s = 1), ts(e)) {\n          if (f = h >= tu.second ? 0 : a * Math.floor(f / a), h >= tu.second && (g = h >= tu.minute ? 0 : a * Math.floor(g / a)), h >= tu.minute && (u = h >= tu.hour ? 0 : a * Math.floor(u / a)), h >= tu.hour && (p = h >= tu.day ? 0 : a * Math.floor(p / a)), h >= tu.day && (c = h >= tu.month ? 1 : Math.max(1, a * Math.floor(c / a))), h >= tu.month && (d = h >= tu.year ? 0 : a * Math.floor(d / a)), h >= tu.year && (l -= l % a), h === tu.week) {\n            a && (e = o.makeTime(l, d, c, p, u, g, f));\n            let t = tx(this.dateTimeFormat({\n              timeZone: this.timezone,\n              weekday: \"narrow\"\n            }, e, \"es\"));\n            c += -t + s + (t < s ? -7 : 0);\n          }\n          e = o.makeTime(l, d, c, p, u, g, f), o.variableTimezone && ts(i) && (m = i - e > 4 * tu.month || o.getTimezoneOffset(e) !== o.getTimezoneOffset(i));\n          let t = e,\n            x = 1;\n          for (; t < i;) r.push(t), h === tu.year ? t = o.makeTime(l + x * a, 0) : h === tu.month ? t = o.makeTime(l, d + x * a) : m && (h === tu.day || h === tu.week) ? t = o.makeTime(l, d, c + x * a * (h === tu.day ? 1 : 7)) : m && h === tu.hour && a > 1 ? t = o.makeTime(l, d, c, p + x * a) : t += h * a, x++;\n          r.push(t), h <= tu.hour && r.length < 1e4 && r.forEach(t => {\n            t % 18e5 == 0 && \"000000000\" === o.dateFormat(\"%H%M%S%L\", t) && (n[t] = \"day\");\n          });\n        }\n        return r.info = tr(t, {\n          higherRanks: n,\n          totalRange: h * a\n        }), r;\n      }\n      getDateFormat(t, e, i, s) {\n        let o = this.dateFormat(\"%m-%d %H:%M:%S.%L\", e),\n          r = \"01-01 00:00:00.000\",\n          n = {\n            millisecond: 15,\n            second: 12,\n            minute: 9,\n            hour: 6,\n            day: 3\n          },\n          a = \"millisecond\",\n          h = a;\n        for (a in tu) {\n          if (t === tu.week && +this.dateFormat(\"%w\", e) === i && o.substr(6) === r.substr(6)) {\n            a = \"week\";\n            break;\n          }\n          if (tu[a] > t) {\n            a = h;\n            break;\n          }\n          if (n[a] && o.substr(n[a]) !== r.substr(n[a])) break;\n          \"week\" !== a && (h = a);\n        }\n        return this.resolveDTLFormat(s[a]).main;\n      }\n    },\n    {\n      isTouchDevice: tb\n    } = O,\n    {\n      fireEvent: tv,\n      merge: tM\n    } = tt,\n    tk = {\n      colors: [\"#2caffe\", \"#544fc5\", \"#00e272\", \"#fe6a35\", \"#6b8abc\", \"#d568fb\", \"#2ee0ca\", \"#fa4b42\", \"#feb56a\", \"#91e8e1\"],\n      symbols: [\"circle\", \"diamond\", \"square\", \"triangle\", \"triangle-down\"],\n      lang: {\n        locale: void 0,\n        loading: \"Loading...\",\n        months: void 0,\n        shortMonths: void 0,\n        weekdays: void 0,\n        numericSymbols: [\"k\", \"M\", \"G\", \"T\", \"P\", \"E\"],\n        resetZoom: \"Reset zoom\",\n        resetZoomTitle: \"Reset zoom level 1:1\"\n      },\n      global: {\n        buttonTheme: {\n          fill: \"#f7f7f7\",\n          padding: 8,\n          r: 2,\n          stroke: \"#cccccc\",\n          \"stroke-width\": 1,\n          style: {\n            color: \"#333333\",\n            cursor: \"pointer\",\n            fontSize: \"0.8em\",\n            fontWeight: \"normal\"\n          },\n          states: {\n            hover: {\n              fill: \"#e6e6e6\"\n            },\n            select: {\n              fill: \"#e6e9ff\",\n              style: {\n                color: \"#000000\",\n                fontWeight: \"bold\"\n              }\n            },\n            disabled: {\n              style: {\n                color: \"#cccccc\"\n              }\n            }\n          }\n        }\n      },\n      time: {\n        Date: void 0,\n        timezone: \"UTC\",\n        timezoneOffset: 0,\n        useUTC: void 0\n      },\n      chart: {\n        alignThresholds: !1,\n        panning: {\n          enabled: !1,\n          type: \"x\"\n        },\n        styledMode: !1,\n        borderRadius: 0,\n        colorCount: 10,\n        allowMutatingData: !0,\n        ignoreHiddenSeries: !0,\n        spacing: [10, 10, 15, 10],\n        resetZoomButton: {\n          theme: {},\n          position: {}\n        },\n        reflow: !0,\n        type: \"line\",\n        zooming: {\n          singleTouch: !1,\n          resetButton: {\n            theme: {\n              zIndex: 6\n            },\n            position: {\n              align: \"right\",\n              x: -10,\n              y: 10\n            }\n          }\n        },\n        width: null,\n        height: null,\n        borderColor: \"#334eff\",\n        backgroundColor: \"#ffffff\",\n        plotBorderColor: \"#cccccc\"\n      },\n      title: {\n        style: {\n          color: \"#333333\",\n          fontWeight: \"bold\"\n        },\n        text: \"Chart title\",\n        margin: 15,\n        minScale: .67\n      },\n      subtitle: {\n        style: {\n          color: \"#666666\",\n          fontSize: \"0.8em\"\n        },\n        text: \"\"\n      },\n      caption: {\n        margin: 15,\n        style: {\n          color: \"#666666\",\n          fontSize: \"0.8em\"\n        },\n        text: \"\",\n        align: \"left\",\n        verticalAlign: \"bottom\"\n      },\n      plotOptions: {},\n      legend: {\n        enabled: !0,\n        align: \"center\",\n        alignColumns: !0,\n        className: \"highcharts-no-tooltip\",\n        events: {},\n        layout: \"horizontal\",\n        itemMarginBottom: 2,\n        itemMarginTop: 2,\n        labelFormatter: function () {\n          return this.name;\n        },\n        borderColor: \"#999999\",\n        borderRadius: 0,\n        navigation: {\n          style: {\n            fontSize: \"0.8em\"\n          },\n          activeColor: \"#0022ff\",\n          inactiveColor: \"#cccccc\"\n        },\n        itemStyle: {\n          color: \"#333333\",\n          cursor: \"pointer\",\n          fontSize: \"0.8em\",\n          textDecoration: \"none\",\n          textOverflow: \"ellipsis\"\n        },\n        itemHoverStyle: {\n          color: \"#000000\"\n        },\n        itemHiddenStyle: {\n          color: \"#666666\",\n          textDecoration: \"line-through\"\n        },\n        shadow: !1,\n        itemCheckboxStyle: {\n          position: \"absolute\",\n          width: \"13px\",\n          height: \"13px\"\n        },\n        squareSymbol: !0,\n        symbolPadding: 5,\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0,\n        title: {\n          style: {\n            fontSize: \"0.8em\",\n            fontWeight: \"bold\"\n          }\n        }\n      },\n      loading: {\n        labelStyle: {\n          fontWeight: \"bold\",\n          position: \"relative\",\n          top: \"45%\"\n        },\n        style: {\n          position: \"absolute\",\n          backgroundColor: \"#ffffff\",\n          opacity: .5,\n          textAlign: \"center\"\n        }\n      },\n      tooltip: {\n        enabled: !0,\n        animation: {\n          duration: 300,\n          easing: t => Math.sqrt(1 - Math.pow(t - 1, 2))\n        },\n        borderRadius: 3,\n        dateTimeLabelFormats: {\n          millisecond: \"%[AebHMSL]\",\n          second: \"%[AebHMS]\",\n          minute: \"%[AebHM]\",\n          hour: \"%[AebHM]\",\n          day: \"%[AebY]\",\n          week: \"Week from %[AebY]\",\n          month: \"%[BY]\",\n          year: \"%Y\"\n        },\n        footerFormat: \"\",\n        headerShape: \"callout\",\n        hideDelay: 500,\n        padding: 8,\n        shape: \"callout\",\n        shared: !1,\n        snap: tb ? 25 : 10,\n        headerFormat: '<span style=\"font-size: 0.8em\">{ucfirst point.key}</span><br/>',\n        pointFormat: '<span style=\"color:{point.color}\">●</span> {series.name}: <b>{point.y}</b><br/>',\n        backgroundColor: \"#ffffff\",\n        borderWidth: void 0,\n        shadow: !0,\n        stickOnContact: !1,\n        style: {\n          color: \"#333333\",\n          cursor: \"default\",\n          fontSize: \"0.8em\"\n        },\n        useHTML: !1\n      },\n      credits: {\n        enabled: !0,\n        href: \"https://www.highcharts.com?credits\",\n        position: {\n          align: \"right\",\n          x: -10,\n          verticalAlign: \"bottom\",\n          y: -5\n        },\n        style: {\n          cursor: \"pointer\",\n          color: \"#999999\",\n          fontSize: \"0.6em\"\n        },\n        text: \"Highcharts.com\"\n      }\n    },\n    tw = new ty(tk.time),\n    tS = {\n      defaultOptions: tk,\n      defaultTime: tw,\n      getOptions: function () {\n        return tk;\n      },\n      setOptions: function (t) {\n        return tv(O, \"setOptions\", {\n          options: t\n        }), tM(!0, tk, t), t.time && tw.update(tk.time), t.lang && \"locale\" in t.lang && tw.update({\n          locale: t.lang.locale\n        }), tk;\n      }\n    },\n    {\n      isNumber: tA,\n      merge: tT,\n      pInt: tP,\n      defined: tC\n    } = tt;\n  class tO {\n    static parse(t) {\n      return t ? new tO(t) : tO.None;\n    }\n    constructor(t) {\n      let e, i, s, o;\n      this.rgba = [NaN, NaN, NaN, NaN], this.input = t;\n      let r = O.Color;\n      if (r && r !== tO) return new r(t);\n      if (\"object\" == typeof t && void 0 !== t.stops) this.stops = t.stops.map(t => new tO(t[1]));else if (\"string\" == typeof t) for (this.input = t = tO.names[t.toLowerCase()] || t, s = tO.parsers.length; s-- && !i;) (e = (o = tO.parsers[s]).regex.exec(t)) && (i = o.parse(e));\n      i && (this.rgba = i);\n    }\n    get(t) {\n      let e = this.input,\n        i = this.rgba;\n      if (\"object\" == typeof e && void 0 !== this.stops) {\n        let i = tT(e);\n        return i.stops = [].slice.call(i.stops), this.stops.forEach((e, s) => {\n          i.stops[s] = [i.stops[s][0], e.get(t)];\n        }), i;\n      }\n      return i && tA(i[0]) ? \"rgb\" !== t && (t || 1 !== i[3]) ? \"a\" === t ? `${i[3]}` : \"rgba(\" + i.join(\",\") + \")\" : \"rgb(\" + i[0] + \",\" + i[1] + \",\" + i[2] + \")\" : e;\n    }\n    brighten(t) {\n      let e = this.rgba;\n      if (this.stops) this.stops.forEach(function (e) {\n        e.brighten(t);\n      });else if (tA(t) && 0 !== t) for (let i = 0; i < 3; i++) e[i] += tP(255 * t), e[i] < 0 && (e[i] = 0), e[i] > 255 && (e[i] = 255);\n      return this;\n    }\n    setOpacity(t) {\n      return this.rgba[3] = t, this;\n    }\n    tweenTo(t, e) {\n      let i = this.rgba,\n        s = t.rgba;\n      if (!tA(i[0]) || !tA(s[0])) return t.input || \"none\";\n      let o = 1 !== s[3] || 1 !== i[3],\n        r = (t, s) => t + (i[s] - t) * (1 - e),\n        n = s.slice(0, 3).map(r).map(Math.round);\n      return o && n.push(r(s[3], 3)), (o ? \"rgba(\" : \"rgb(\") + n.join(\",\") + \")\";\n    }\n  }\n  tO.names = {\n    white: \"#ffffff\",\n    black: \"#000000\"\n  }, tO.parsers = [{\n    regex: /rgba\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d?(?:\\.\\d+)?)\\s*\\)/,\n    parse: function (t) {\n      return [tP(t[1]), tP(t[2]), tP(t[3]), parseFloat(t[4], 10)];\n    }\n  }, {\n    regex: /rgb\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*\\)/,\n    parse: function (t) {\n      return [tP(t[1]), tP(t[2]), tP(t[3]), 1];\n    }\n  }, {\n    regex: /^#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?$/i,\n    parse: function (t) {\n      return [tP(t[1] + t[1], 16), tP(t[2] + t[2], 16), tP(t[3] + t[3], 16), tC(t[4]) ? tP(t[4] + t[4], 16) / 255 : 1];\n    }\n  }, {\n    regex: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?$/i,\n    parse: function (t) {\n      return [tP(t[1], 16), tP(t[2], 16), tP(t[3], 16), tC(t[4]) ? tP(t[4], 16) / 255 : 1];\n    }\n  }], tO.None = new tO(\"\");\n  let {\n      parse: tE\n    } = tO,\n    {\n      win: tL\n    } = O,\n    {\n      isNumber: tB,\n      objectEach: tI\n    } = tt;\n  let tD = /*#__PURE__*/(() => {\n    class tD {\n      constructor(t, e, i) {\n        this.pos = NaN, this.options = e, this.elem = t, this.prop = i;\n      }\n      dSetter() {\n        let t = this.paths,\n          e = t && t[0],\n          i = t && t[1],\n          s = this.now || 0,\n          o = [];\n        if (1 !== s && e && i) {\n          if (e.length === i.length && s < 1) for (let t = 0; t < i.length; t++) {\n            let r = e[t],\n              n = i[t],\n              a = [];\n            for (let t = 0; t < n.length; t++) {\n              let e = r[t],\n                i = n[t];\n              tB(e) && tB(i) && !(\"A\" === n[0] && (4 === t || 5 === t)) ? a[t] = e + s * (i - e) : a[t] = i;\n            }\n            o.push(a);\n          } else o = i;\n        } else o = this.toD || [];\n        this.elem.attr(\"d\", o, void 0, !0);\n      }\n      update() {\n        let t = this.elem,\n          e = this.prop,\n          i = this.now,\n          s = this.options.step;\n        this[e + \"Setter\"] ? this[e + \"Setter\"]() : t.attr ? t.element && t.attr(e, i, null, !0) : t.style[e] = i + this.unit, s && s.call(t, i, this);\n      }\n      run(t, e, i) {\n        let s = this,\n          o = s.options,\n          r = function (t) {\n            return !r.stopped && s.step(t);\n          },\n          n = tL.requestAnimationFrame || function (t) {\n            setTimeout(t, 13);\n          },\n          a = function () {\n            for (let t = 0; t < tD.timers.length; t++) tD.timers[t]() || tD.timers.splice(t--, 1);\n            tD.timers.length && n(a);\n          };\n        t !== e || this.elem[\"forceAnimate:\" + this.prop] ? (this.startTime = +new Date(), this.start = t, this.end = e, this.unit = i, this.now = this.start, this.pos = 0, r.elem = this.elem, r.prop = this.prop, r() && 1 === tD.timers.push(r) && n(a)) : (delete o.curAnim[this.prop], o.complete && 0 === Object.keys(o.curAnim).length && o.complete.call(this.elem));\n      }\n      step(t) {\n        let e, i;\n        let s = +new Date(),\n          o = this.options,\n          r = this.elem,\n          n = o.complete,\n          a = o.duration,\n          h = o.curAnim;\n        return r.attr && !r.element ? e = !1 : t || s >= a + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), h[this.prop] = !0, i = !0, tI(h, function (t) {\n          !0 !== t && (i = !1);\n        }), i && n && n.call(r), e = !1) : (this.pos = o.easing((s - this.startTime) / a), this.now = this.start + (this.end - this.start) * this.pos, this.update(), e = !0), e;\n      }\n      initPath(t, e, i) {\n        let s = t.startX,\n          o = t.endX,\n          r = i.slice(),\n          n = t.isArea,\n          a = n ? 2 : 1,\n          h = e && i.length > e.length && i.hasStackedCliffs,\n          l,\n          d,\n          c,\n          p,\n          u = e && e.slice();\n        if (!u || h) return [r, r];\n        function g(t, e) {\n          for (; t.length < d;) {\n            let i = t[0],\n              s = e[d - t.length];\n            if (s && \"M\" === i[0] && (\"C\" === s[0] ? t[0] = [\"C\", i[1], i[2], i[1], i[2], i[1], i[2]] : t[0] = [\"L\", i[1], i[2]]), t.unshift(i), n) {\n              let e = t.pop();\n              t.push(t[t.length - 1], e);\n            }\n          }\n        }\n        function f(t) {\n          for (; t.length < d;) {\n            let e = t[Math.floor(t.length / a) - 1].slice();\n            if (\"C\" === e[0] && (e[1] = e[5], e[2] = e[6]), n) {\n              let i = t[Math.floor(t.length / a)].slice();\n              t.splice(t.length / 2, 0, e, i);\n            } else t.push(e);\n          }\n        }\n        if (s && o && o.length) {\n          for (c = 0; c < s.length; c++) {\n            if (s[c] === o[0]) {\n              l = c;\n              break;\n            }\n            if (s[0] === o[o.length - s.length + c]) {\n              l = c, p = !0;\n              break;\n            }\n            if (s[s.length - 1] === o[o.length - s.length + c]) {\n              l = s.length - c;\n              break;\n            }\n          }\n          void 0 === l && (u = []);\n        }\n        return u.length && tB(l) && (d = r.length + l * a, p ? (g(u, r), f(r)) : (g(r, u), f(u))), [u, r];\n      }\n      fillSetter() {\n        tD.prototype.strokeSetter.apply(this, arguments);\n      }\n      strokeSetter() {\n        this.elem.attr(this.prop, tE(this.start).tweenTo(tE(this.end), this.pos), void 0, !0);\n      }\n    }\n    tD.timers = [];\n    return tD;\n  })();\n  let {\n    defined: tR,\n    getStyle: tN,\n    isArray: tz,\n    isNumber: tW,\n    isObject: tG,\n    merge: tH,\n    objectEach: tF,\n    pick: tX\n  } = tt;\n  function tY(t) {\n    return tG(t) ? tH({\n      duration: 500,\n      defer: 0\n    }, t) : {\n      duration: t ? 500 : 0,\n      defer: 0\n    };\n  }\n  function tj(t, e) {\n    let i = tD.timers.length;\n    for (; i--;) tD.timers[i].elem !== t || e && e !== tD.timers[i].prop || (tD.timers[i].stopped = !0);\n  }\n  let tU = {\n      animate: function (t, e, i) {\n        let s,\n          o = \"\",\n          r,\n          n,\n          a;\n        tG(i) || (a = arguments, i = {\n          duration: a[2],\n          easing: a[3],\n          complete: a[4]\n        }), tW(i.duration) || (i.duration = 400), i.easing = \"function\" == typeof i.easing ? i.easing : Math[i.easing] || Math.easeInOutSine, i.curAnim = tH(e), tF(e, function (a, h) {\n          tj(t, h), n = new tD(t, i, h), r = void 0, \"d\" === h && tz(e.d) ? (n.paths = n.initPath(t, t.pathArray, e.d), n.toD = e.d, s = 0, r = 1) : t.attr ? s = t.attr(h) : (s = parseFloat(tN(t, h)) || 0, \"opacity\" !== h && (o = \"px\")), r || (r = a), \"string\" == typeof r && r.match(\"px\") && (r = r.replace(/px/g, \"\")), n.run(s, r, o);\n        });\n      },\n      animObject: tY,\n      getDeferredAnimation: function (t, e, i) {\n        let s = tY(e),\n          o = i ? [i] : t.series,\n          r = 0,\n          n = 0;\n        return o.forEach(t => {\n          let i = tY(t.options.animation);\n          r = tG(e) && tR(e.defer) ? s.defer : Math.max(r, i.duration + i.defer), n = Math.min(s.duration, i.duration);\n        }), t.renderer.forExport && (r = 0), {\n          defer: Math.max(0, r - n),\n          duration: Math.min(r, n)\n        };\n      },\n      setAnimation: function (t, e) {\n        e.renderer.globalAnimation = tX(t, e.options.chart.animation, !0);\n      },\n      stop: tj\n    },\n    {\n      SVG_NS: tV,\n      win: t$\n    } = O,\n    {\n      attr: t_,\n      createElement: tq,\n      css: tZ,\n      error: tK,\n      isFunction: tJ,\n      isString: tQ,\n      objectEach: t0,\n      splat: t1\n    } = tt,\n    {\n      trustedTypes: t2\n    } = t$,\n    t3 = t2 && tJ(t2.createPolicy) && t2.createPolicy(\"highcharts\", {\n      createHTML: t => t\n    }),\n    t5 = t3 ? t3.createHTML(\"\") : \"\";\n  class t6 {\n    static filterUserAttributes(t) {\n      return t0(t, (e, i) => {\n        let s = !0;\n        -1 === t6.allowedAttributes.indexOf(i) && (s = !1), -1 !== [\"background\", \"dynsrc\", \"href\", \"lowsrc\", \"src\"].indexOf(i) && (s = tQ(e) && t6.allowedReferences.some(t => 0 === e.indexOf(t))), s || (tK(33, !1, void 0, {\n          \"Invalid attribute in config\": `${i}`\n        }), delete t[i]), tQ(e) && t[i] && (t[i] = e.replace(/</g, \"&lt;\"));\n      }), t;\n    }\n    static parseStyle(t) {\n      return t.split(\";\").reduce((t, e) => {\n        let i = e.split(\":\").map(t => t.trim()),\n          s = i.shift();\n        return s && i.length && (t[s.replace(/-([a-z])/g, t => t[1].toUpperCase())] = i.join(\":\")), t;\n      }, {});\n    }\n    static setElementHTML(t, e) {\n      t.innerHTML = t6.emptyHTML, e && new t6(e).addToDOM(t);\n    }\n    constructor(t) {\n      this.nodes = \"string\" == typeof t ? this.parseMarkup(t) : t;\n    }\n    addToDOM(t) {\n      return function t(e, i) {\n        let s;\n        return t1(e).forEach(function (e) {\n          let o;\n          let r = e.tagName,\n            n = e.textContent ? O.doc.createTextNode(e.textContent) : void 0,\n            a = t6.bypassHTMLFiltering;\n          if (r) {\n            if (\"#text\" === r) o = n;else if (-1 !== t6.allowedTags.indexOf(r) || a) {\n              let s = \"svg\" === r ? tV : i.namespaceURI || tV,\n                h = O.doc.createElementNS(s, r),\n                l = e.attributes || {};\n              t0(e, function (t, e) {\n                \"tagName\" !== e && \"attributes\" !== e && \"children\" !== e && \"style\" !== e && \"textContent\" !== e && (l[e] = t);\n              }), t_(h, a ? l : t6.filterUserAttributes(l)), e.style && tZ(h, e.style), n && h.appendChild(n), t(e.children || [], h), o = h;\n            } else tK(33, !1, void 0, {\n              \"Invalid tagName in config\": r\n            });\n          }\n          o && i.appendChild(o), s = o;\n        }), s;\n      }(this.nodes, t);\n    }\n    parseMarkup(t) {\n      let e;\n      let i = [];\n      t = t.trim().replace(/ style=([\"'])/g, \" data-style=$1\");\n      try {\n        e = new DOMParser().parseFromString(t3 ? t3.createHTML(t) : t, \"text/html\");\n      } catch (t) {}\n      if (!e) {\n        let i = tq(\"div\");\n        i.innerHTML = t, e = {\n          body: i\n        };\n      }\n      let s = (t, e) => {\n        let i = t.nodeName.toLowerCase(),\n          o = {\n            tagName: i\n          };\n        \"#text\" === i && (o.textContent = t.textContent || \"\");\n        let r = t.attributes;\n        if (r) {\n          let t = {};\n          [].forEach.call(r, e => {\n            \"data-style\" === e.name ? o.style = t6.parseStyle(e.value) : t[e.name] = e.value;\n          }), o.attributes = t;\n        }\n        if (t.childNodes.length) {\n          let e = [];\n          [].forEach.call(t.childNodes, t => {\n            s(t, e);\n          }), e.length && (o.children = e);\n        }\n        e.push(o);\n      };\n      return [].forEach.call(e.body.childNodes, t => s(t, i)), i;\n    }\n  }\n  t6.allowedAttributes = [\"alt\", \"aria-controls\", \"aria-describedby\", \"aria-expanded\", \"aria-haspopup\", \"aria-hidden\", \"aria-label\", \"aria-labelledby\", \"aria-live\", \"aria-pressed\", \"aria-readonly\", \"aria-roledescription\", \"aria-selected\", \"class\", \"clip-path\", \"color\", \"colspan\", \"cx\", \"cy\", \"d\", \"dx\", \"dy\", \"disabled\", \"fill\", \"filterUnits\", \"flood-color\", \"flood-opacity\", \"height\", \"href\", \"id\", \"in\", \"in2\", \"markerHeight\", \"markerWidth\", \"offset\", \"opacity\", \"operator\", \"orient\", \"padding\", \"paddingLeft\", \"paddingRight\", \"patternUnits\", \"r\", \"radius\", \"refX\", \"refY\", \"role\", \"scope\", \"slope\", \"src\", \"startOffset\", \"stdDeviation\", \"stroke\", \"stroke-linecap\", \"stroke-width\", \"style\", \"tableValues\", \"result\", \"rowspan\", \"summary\", \"target\", \"tabindex\", \"text-align\", \"text-anchor\", \"textAnchor\", \"textLength\", \"title\", \"type\", \"valign\", \"width\", \"x\", \"x1\", \"x2\", \"xlink:href\", \"y\", \"y1\", \"y2\", \"zIndex\"], t6.allowedReferences = [\"https://\", \"http://\", \"mailto:\", \"/\", \"../\", \"./\", \"#\"], t6.allowedTags = [\"a\", \"abbr\", \"b\", \"br\", \"button\", \"caption\", \"circle\", \"clipPath\", \"code\", \"dd\", \"defs\", \"div\", \"dl\", \"dt\", \"em\", \"feComponentTransfer\", \"feComposite\", \"feDropShadow\", \"feFlood\", \"feFuncA\", \"feFuncB\", \"feFuncG\", \"feFuncR\", \"feGaussianBlur\", \"feMorphology\", \"feOffset\", \"feMerge\", \"feMergeNode\", \"filter\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"hr\", \"i\", \"img\", \"li\", \"linearGradient\", \"marker\", \"ol\", \"p\", \"path\", \"pattern\", \"pre\", \"rect\", \"small\", \"span\", \"stop\", \"strong\", \"style\", \"sub\", \"sup\", \"svg\", \"table\", \"text\", \"textPath\", \"thead\", \"title\", \"tbody\", \"tspan\", \"td\", \"th\", \"tr\", \"u\", \"ul\", \"#text\"], t6.emptyHTML = t5, t6.bypassHTMLFiltering = !1;\n  let {\n      defaultOptions: t9,\n      defaultTime: t4\n    } = tS,\n    {\n      pageLang: t8\n    } = O,\n    {\n      extend: t7,\n      getNestedProperty: et,\n      isArray: ee,\n      isNumber: ei,\n      isObject: es,\n      isString: eo,\n      pick: er,\n      ucfirst: en\n    } = tt,\n    ea = {\n      add: (t, e) => t + e,\n      divide: (t, e) => 0 !== e ? t / e : \"\",\n      eq: (t, e) => t == e,\n      each: function (t) {\n        let e = arguments[arguments.length - 1];\n        return !!ee(t) && t.map((i, s) => ed(e.body, t7(es(i) ? i : {\n          \"@this\": i\n        }, {\n          \"@index\": s,\n          \"@first\": 0 === s,\n          \"@last\": s === t.length - 1\n        }))).join(\"\");\n      },\n      ge: (t, e) => t >= e,\n      gt: (t, e) => t > e,\n      if: t => !!t,\n      le: (t, e) => t <= e,\n      lt: (t, e) => t < e,\n      multiply: (t, e) => t * e,\n      ne: (t, e) => t != e,\n      subtract: (t, e) => t - e,\n      ucfirst: en,\n      unless: t => !t\n    },\n    eh = {},\n    el = t => /^[\"'].+[\"']$/.test(t);\n  function ed(t = \"\", e, i) {\n    let s = /\\{([\\p{L}\\d:\\.,;\\-\\/<>\\[\\]%_@+\"'’= #\\(\\)]+)\\}/gu,\n      o = /\\(([\\p{L}\\d:\\.,;\\-\\/<>\\[\\]%_@+\"'= ]+)\\)/gu,\n      r = [],\n      n = /f$/,\n      a = /\\.(\\d)/,\n      h = i?.options.lang || t9.lang,\n      l = i && i.time || t4,\n      d = i && i.numberFormatter || ec,\n      c = (t = \"\") => {\n        let i;\n        return \"true\" === t || \"false\" !== t && ((i = Number(t)).toString() === t ? i : el(t) ? t.slice(1, -1) : et(t, e));\n      },\n      p,\n      u,\n      g = 0,\n      f;\n    for (; null !== (p = s.exec(t));) {\n      let i = p,\n        s = o.exec(p[1]);\n      s && (p = s, f = !0), u && u.isBlock || (u = {\n        ctx: e,\n        expression: p[1],\n        find: p[0],\n        isBlock: \"#\" === p[1].charAt(0),\n        start: p.index,\n        startInner: p.index + p[0].length,\n        length: p[0].length\n      });\n      let n = (u.isBlock ? i : p)[1].split(\" \")[0].replace(\"#\", \"\");\n      ea[n] && (u.isBlock && n === u.fn && g++, u.fn || (u.fn = n));\n      let a = \"else\" === p[1];\n      if (u.isBlock && u.fn && (p[1] === `/${u.fn}` || a)) {\n        if (g) !a && g--;else {\n          let e = u.startInner,\n            i = t.substr(e, p.index - e);\n          void 0 === u.body ? (u.body = i, u.startInner = p.index + p[0].length) : u.elseBody = i, u.find += i + p[0], a || (r.push(u), u = void 0);\n        }\n      } else u.isBlock || r.push(u);\n      if (s && !u?.isBlock) break;\n    }\n    return r.forEach(s => {\n      let r, p;\n      let {\n        body: u,\n        elseBody: g,\n        expression: f,\n        fn: m\n      } = s;\n      if (m) {\n        let t = [s],\n          o = [],\n          n = f.length,\n          a = 0,\n          h;\n        for (p = 0; p <= n; p++) {\n          let t = f.charAt(p);\n          h || '\"' !== t && \"'\" !== t ? h === t && (h = \"\") : h = t, h || \" \" !== t && p !== n || (o.push(f.substr(a, p - a)), a = p + 1);\n        }\n        for (p = ea[m].length; p--;) t.unshift(c(o[p + 1]));\n        r = ea[m].apply(e, t), s.isBlock && \"boolean\" == typeof r && (r = ed(r ? u : g, e, i));\n      } else {\n        let t = el(f) ? [f] : f.split(\":\");\n        if (r = c(t.shift() || \"\"), t.length && \"number\" == typeof r) {\n          let e = t.join(\":\");\n          if (n.test(e)) {\n            let t = parseInt((e.match(a) || [\"\", \"-1\"])[1], 10);\n            null !== r && (r = d(r, t, h.decimalPoint, e.indexOf(\",\") > -1 ? h.thousandsSep : \"\"));\n          } else r = l.dateFormat(e, r);\n        }\n        o.lastIndex = 0, o.test(s.find) && eo(r) && (r = `\"${r}\"`);\n      }\n      t = t.replace(s.find, er(r, \"\"));\n    }), f ? ed(t, e, i) : t;\n  }\n  function ec(t, e, i, s) {\n    e = +e;\n    let o,\n      r,\n      [n, a] = (t = +t || 0).toString().split(\"e\").map(Number),\n      h = this?.options?.lang || t9.lang,\n      l = (t.toString().split(\".\")[1] || \"\").split(\"e\")[0].length,\n      d = e,\n      c = {};\n    i ?? (i = h.decimalPoint), s ?? (s = h.thousandsSep), -1 === e ? e = Math.min(l, 20) : ei(e) ? e && a < 0 && ((r = e + a) >= 0 ? (n = +n.toExponential(r).split(\"e\")[0], e = r) : (n = Math.floor(n), t = e < 20 ? +(n * Math.pow(10, a)).toFixed(e) : 0, a = 0)) : e = 2, a && (e ?? (e = 2), t = n), ei(e) && e >= 0 && (c.minimumFractionDigits = e, c.maximumFractionDigits = e), \"\" === s && (c.useGrouping = !1);\n    let p = s || i,\n      u = p ? \"en\" : this?.locale || h.locale || t8,\n      g = JSON.stringify(c) + u;\n    return o = (eh[g] ?? (eh[g] = new Intl.NumberFormat(u, c))).format(t), p && (o = o.replace(/([,\\.])/g, \"_$1\").replace(/_\\,/g, s ?? \",\").replace(\"_.\", i ?? \".\")), (e || 0 != +o) && (!(a < 0) || d) || (o = \"0\"), a && 0 != +o && (o += \"e\" + (a < 0 ? \"\" : \"+\") + a), o;\n  }\n  let ep = {\n    dateFormat: function (t, e, i) {\n      return t4.dateFormat(t, e, i);\n    },\n    format: ed,\n    helpers: ea,\n    numberFormat: ec\n  };\n  !function (t) {\n    let e;\n    t.rendererTypes = {}, t.getRendererType = function (i = e) {\n      return t.rendererTypes[i] || t.rendererTypes[e];\n    }, t.registerRendererType = function (i, s, o) {\n      t.rendererTypes[i] = s, (!e || o) && (e = i, O.Renderer = s);\n    };\n  }(n || (n = {}));\n  let eu = n,\n    {\n      clamp: eg,\n      pick: ef,\n      pushUnique: em,\n      stableSort: ex\n    } = tt;\n  (a || (a = {})).distribute = function t(e, i, s) {\n    let o = e,\n      r = o.reducedLen || i,\n      n = (t, e) => t.target - e.target,\n      a = [],\n      h = e.length,\n      l = [],\n      d = a.push,\n      c,\n      p,\n      u,\n      g = !0,\n      f,\n      m,\n      x = 0,\n      y;\n    for (c = h; c--;) x += e[c].size;\n    if (x > r) {\n      for (ex(e, (t, e) => (e.rank || 0) - (t.rank || 0)), u = (y = e[0].rank === e[e.length - 1].rank) ? h / 2 : -1, p = y ? u : h - 1; u && x > r;) f = e[c = Math.floor(p)], em(l, c) && (x -= f.size), p += u, y && p >= e.length && (u /= 2, p = u);\n      l.sort((t, e) => e - t).forEach(t => d.apply(a, e.splice(t, 1)));\n    }\n    for (ex(e, n), e = e.map(t => ({\n      size: t.size,\n      targets: [t.target],\n      align: ef(t.align, .5)\n    })); g;) {\n      for (c = e.length; c--;) f = e[c], m = (Math.min.apply(0, f.targets) + Math.max.apply(0, f.targets)) / 2, f.pos = eg(m - f.size * f.align, 0, i - f.size);\n      for (c = e.length, g = !1; c--;) c > 0 && e[c - 1].pos + e[c - 1].size > e[c].pos && (e[c - 1].size += e[c].size, e[c - 1].targets = e[c - 1].targets.concat(e[c].targets), e[c - 1].align = .5, e[c - 1].pos + e[c - 1].size > i && (e[c - 1].pos = i - e[c - 1].size), e.splice(c, 1), g = !0);\n    }\n    return d.apply(o, a), c = 0, e.some(e => {\n      let r = 0;\n      return (e.targets || []).some(() => (o[c].pos = e.pos + r, void 0 !== s && Math.abs(o[c].pos - o[c].target) > s) ? (o.slice(0, c + 1).forEach(t => delete t.pos), o.reducedLen = (o.reducedLen || i) - .1 * i, o.reducedLen > .1 * i && t(o, i, s), !0) : (r += o[c].size, c++, !1));\n    }), ex(o, n), o;\n  };\n  let ey = a,\n    {\n      animate: eb,\n      animObject: ev,\n      stop: eM\n    } = tU,\n    {\n      deg2rad: ek,\n      doc: ew,\n      svg: eS,\n      SVG_NS: eA,\n      win: eT,\n      isFirefox: eP\n    } = O,\n    {\n      addEvent: eC,\n      attr: eO,\n      createElement: eE,\n      crisp: eL,\n      css: eB,\n      defined: eI,\n      erase: eD,\n      extend: eR,\n      fireEvent: eN,\n      getAlignFactor: ez,\n      isArray: eW,\n      isFunction: eG,\n      isNumber: eH,\n      isObject: eF,\n      isString: eX,\n      merge: eY,\n      objectEach: ej,\n      pick: eU,\n      pInt: eV,\n      pushUnique: e$,\n      replaceNested: e_,\n      syncTimeout: eq,\n      uniqueKey: eZ\n    } = tt;\n  class eK {\n    _defaultGetter(t) {\n      let e = eU(this[t + \"Value\"], this[t], this.element ? this.element.getAttribute(t) : null, 0);\n      return /^-?[\\d\\.]+$/.test(e) && (e = parseFloat(e)), e;\n    }\n    _defaultSetter(t, e, i) {\n      i.setAttribute(e, t);\n    }\n    add(t) {\n      let e;\n      let i = this.renderer,\n        s = this.element;\n      return t && (this.parentGroup = t), void 0 !== this.textStr && \"text\" === this.element.nodeName && i.buildText(this), this.added = !0, (!t || t.handleZ || this.zIndex) && (e = this.zIndexSetter()), e || (t ? t.element : i.box).appendChild(s), this.onAdd && this.onAdd(), this;\n    }\n    addClass(t, e) {\n      let i = e ? \"\" : this.attr(\"class\") || \"\";\n      return (t = (t || \"\").split(/ /g).reduce(function (t, e) {\n        return -1 === i.indexOf(e) && t.push(e), t;\n      }, i ? [i] : []).join(\" \")) !== i && this.attr(\"class\", t), this;\n    }\n    afterSetters() {\n      this.doTransform && (this.updateTransform(), this.doTransform = !1);\n    }\n    align(t, e, i, s = !0) {\n      let o = this.renderer,\n        r = o.alignedObjects,\n        n = !!t;\n      t ? (this.alignOptions = t, this.alignByTranslate = e, this.alignTo = i) : (t = this.alignOptions || {}, e = this.alignByTranslate, i = this.alignTo);\n      let a = !i || eX(i) ? i || \"renderer\" : void 0;\n      a && (n && e$(r, this), i = void 0);\n      let h = eU(i, o[a], o),\n        l = (h.x || 0) + (t.x || 0) + ((h.width || 0) - (t.width || 0)) * ez(t.align),\n        d = (h.y || 0) + (t.y || 0) + ((h.height || 0) - (t.height || 0)) * ez(t.verticalAlign),\n        c = {\n          \"text-align\": t?.align\n        };\n      return c[e ? \"translateX\" : \"x\"] = Math.round(l), c[e ? \"translateY\" : \"y\"] = Math.round(d), s && (this[this.placed ? \"animate\" : \"attr\"](c), this.placed = !0), this.alignAttr = c, this;\n    }\n    alignSetter(t) {\n      let e = {\n        left: \"start\",\n        center: \"middle\",\n        right: \"end\"\n      };\n      e[t] && (this.alignValue = t, this.element.setAttribute(\"text-anchor\", e[t]));\n    }\n    animate(t, e, i) {\n      let s = ev(eU(e, this.renderer.globalAnimation, !0)),\n        o = s.defer;\n      return ew.hidden && (s.duration = 0), 0 !== s.duration ? (i && (s.complete = i), eq(() => {\n        this.element && eb(this, t, s);\n      }, o)) : (this.attr(t, void 0, i || s.complete), ej(t, function (t, e) {\n        s.step && s.step.call(this, t, {\n          prop: e,\n          pos: 1,\n          elem: this\n        });\n      }, this)), this;\n    }\n    applyTextOutline(t) {\n      let e = this.element;\n      -1 !== t.indexOf(\"contrast\") && (t = t.replace(/contrast/g, this.renderer.getContrast(e.style.fill)));\n      let i = t.split(\" \"),\n        s = i[i.length - 1],\n        o = i[0];\n      if (o && \"none\" !== o && O.svg) {\n        this.fakeTS = !0, o = o.replace(/(^[\\d\\.]+)(.*?)$/g, function (t, e, i) {\n          return 2 * Number(e) + i;\n        }), this.removeTextOutline();\n        let t = ew.createElementNS(eA, \"tspan\");\n        eO(t, {\n          class: \"highcharts-text-outline\",\n          fill: s,\n          stroke: s,\n          \"stroke-width\": o,\n          \"stroke-linejoin\": \"round\"\n        });\n        let i = e.querySelector(\"textPath\") || e;\n        [].forEach.call(i.childNodes, e => {\n          let i = e.cloneNode(!0);\n          i.removeAttribute && [\"fill\", \"stroke\", \"stroke-width\", \"stroke\"].forEach(t => i.removeAttribute(t)), t.appendChild(i);\n        });\n        let r = 0;\n        [].forEach.call(i.querySelectorAll(\"text tspan\"), t => {\n          r += Number(t.getAttribute(\"dy\"));\n        });\n        let n = ew.createElementNS(eA, \"tspan\");\n        n.textContent = \"​\", eO(n, {\n          x: Number(e.getAttribute(\"x\")),\n          dy: -r\n        }), t.appendChild(n), i.insertBefore(t, i.firstChild);\n      }\n    }\n    attr(t, e, i, s) {\n      let {\n          element: o\n        } = this,\n        r = eK.symbolCustomAttribs,\n        n,\n        a,\n        h = this,\n        l;\n      return \"string\" == typeof t && void 0 !== e && (n = t, (t = {})[n] = e), \"string\" == typeof t ? h = (this[t + \"Getter\"] || this._defaultGetter).call(this, t, o) : (ej(t, function (e, i) {\n        l = !1, s || eM(this, i), this.symbolName && -1 !== r.indexOf(i) && (a || (this.symbolAttr(t), a = !0), l = !0), this.rotation && (\"x\" === i || \"y\" === i) && (this.doTransform = !0), l || (this[i + \"Setter\"] || this._defaultSetter).call(this, e, i, o);\n      }, this), this.afterSetters()), i && i.call(this), h;\n    }\n    clip(t) {\n      if (t && !t.clipPath) {\n        let e = eZ() + \"-\",\n          i = this.renderer.createElement(\"clipPath\").attr({\n            id: e\n          }).add(this.renderer.defs);\n        eR(t, {\n          clipPath: i,\n          id: e,\n          count: 0\n        }), t.add(i);\n      }\n      return this.attr(\"clip-path\", t ? `url(${this.renderer.url}#${t.id})` : \"none\");\n    }\n    crisp(t, e) {\n      e = Math.round(e || t.strokeWidth || 0);\n      let i = t.x || this.x || 0,\n        s = t.y || this.y || 0,\n        o = (t.width || this.width || 0) + i,\n        r = (t.height || this.height || 0) + s,\n        n = eL(i, e),\n        a = eL(s, e);\n      return eR(t, {\n        x: n,\n        y: a,\n        width: eL(o, e) - n,\n        height: eL(r, e) - a\n      }), eI(t.strokeWidth) && (t.strokeWidth = e), t;\n    }\n    complexColor(t, e, i) {\n      let s = this.renderer,\n        o,\n        r,\n        n,\n        a,\n        h,\n        l,\n        d,\n        c,\n        p,\n        u,\n        g = [],\n        f;\n      eN(this.renderer, \"complexColor\", {\n        args: arguments\n      }, function () {\n        if (t.radialGradient ? r = \"radialGradient\" : t.linearGradient && (r = \"linearGradient\"), r) {\n          if (n = t[r], h = s.gradients, l = t.stops, p = i.radialReference, eW(n) && (t[r] = n = {\n            x1: n[0],\n            y1: n[1],\n            x2: n[2],\n            y2: n[3],\n            gradientUnits: \"userSpaceOnUse\"\n          }), \"radialGradient\" === r && p && !eI(n.gradientUnits) && (a = n, n = eY(n, s.getRadialAttr(p, a), {\n            gradientUnits: \"userSpaceOnUse\"\n          })), ej(n, function (t, e) {\n            \"id\" !== e && g.push(e, t);\n          }), ej(l, function (t) {\n            g.push(t);\n          }), h[g = g.join(\",\")]) u = h[g].attr(\"id\");else {\n            n.id = u = eZ();\n            let t = h[g] = s.createElement(r).attr(n).add(s.defs);\n            t.radAttr = a, t.stops = [], l.forEach(function (e) {\n              0 === e[1].indexOf(\"rgba\") ? (d = (o = tO.parse(e[1])).get(\"rgb\"), c = o.get(\"a\")) : (d = e[1], c = 1);\n              let i = s.createElement(\"stop\").attr({\n                offset: e[0],\n                \"stop-color\": d,\n                \"stop-opacity\": c\n              }).add(t);\n              t.stops.push(i);\n            });\n          }\n          f = \"url(\" + s.url + \"#\" + u + \")\", i.setAttribute(e, f), i.gradient = g, t.toString = function () {\n            return f;\n          };\n        }\n      });\n    }\n    css(t) {\n      let e = this.styles,\n        i = {},\n        s = this.element,\n        o,\n        r = !e;\n      if (e && ej(t, function (t, s) {\n        e && e[s] !== t && (i[s] = t, r = !0);\n      }), r) {\n        e && (t = eR(e, i)), null === t.width || \"auto\" === t.width ? delete this.textWidth : \"text\" === s.nodeName.toLowerCase() && t.width && (o = this.textWidth = eV(t.width)), eR(this.styles, t), o && !eS && this.renderer.forExport && delete t.width;\n        let r = eP && t.fontSize || null;\n        r && (eH(r) || /^\\d+$/.test(r)) && (t.fontSize += \"px\");\n        let n = eY(t);\n        s.namespaceURI === this.SVG_NS && ([\"textOutline\", \"textOverflow\", \"whiteSpace\", \"width\"].forEach(t => n && delete n[t]), n.color && (n.fill = n.color)), eB(s, n);\n      }\n      return this.added && (\"text\" === this.element.nodeName && this.renderer.buildText(this), t.textOutline && this.applyTextOutline(t.textOutline)), this;\n    }\n    dashstyleSetter(t) {\n      let e,\n        i = this[\"stroke-width\"];\n      if (\"inherit\" === i && (i = 1), t = t && t.toLowerCase()) {\n        let s = t.replace(\"shortdashdotdot\", \"3,1,1,1,1,1,\").replace(\"shortdashdot\", \"3,1,1,1\").replace(\"shortdot\", \"1,1,\").replace(\"shortdash\", \"3,1,\").replace(\"longdash\", \"8,3,\").replace(/dot/g, \"1,3,\").replace(\"dash\", \"4,3,\").replace(/,$/, \"\").split(\",\");\n        for (e = s.length; e--;) s[e] = \"\" + eV(s[e]) * eU(i, NaN);\n        t = s.join(\",\").replace(/NaN/g, \"none\"), this.element.setAttribute(\"stroke-dasharray\", t);\n      }\n    }\n    destroy() {\n      let t = this,\n        e = t.element || {},\n        i = t.renderer,\n        s = e.ownerSVGElement,\n        o = \"SPAN\" === e.nodeName && t.parentGroup || void 0,\n        r,\n        n;\n      if (e.onclick = e.onmouseout = e.onmouseover = e.onmousemove = e.point = null, eM(t), t.clipPath && s) {\n        let e = t.clipPath;\n        [].forEach.call(s.querySelectorAll(\"[clip-path],[CLIP-PATH]\"), function (t) {\n          t.getAttribute(\"clip-path\").indexOf(e.element.id) > -1 && t.removeAttribute(\"clip-path\");\n        }), t.clipPath = e.destroy();\n      }\n      if (t.connector = t.connector?.destroy(), t.stops) {\n        for (n = 0; n < t.stops.length; n++) t.stops[n].destroy();\n        t.stops.length = 0, t.stops = void 0;\n      }\n      for (t.safeRemoveChild(e); o && o.div && 0 === o.div.childNodes.length;) r = o.parentGroup, t.safeRemoveChild(o.div), delete o.div, o = r;\n      t.alignOptions && eD(i.alignedObjects, t), ej(t, function (e, i) {\n        t[i] && t[i].parentGroup === t && t[i].destroy && t[i].destroy(), delete t[i];\n      });\n    }\n    dSetter(t, e, i) {\n      eW(t) && (\"string\" == typeof t[0] && (t = this.renderer.pathToSegments(t)), this.pathArray = t, t = t.reduce((t, e, i) => e && e.join ? (i ? t + \" \" : \"\") + e.join(\" \") : (e || \"\").toString(), \"\")), /(NaN| {2}|^$)/.test(t) && (t = \"M 0 0\"), this[e] !== t && (i.setAttribute(e, t), this[e] = t);\n    }\n    fillSetter(t, e, i) {\n      \"string\" == typeof t ? i.setAttribute(e, t) : t && this.complexColor(t, e, i);\n    }\n    hrefSetter(t, e, i) {\n      i.setAttributeNS(\"http://www.w3.org/1999/xlink\", e, t);\n    }\n    getBBox(t, e) {\n      let i, s, o, r;\n      let {\n          alignValue: n,\n          element: a,\n          renderer: h,\n          styles: l,\n          textStr: d\n        } = this,\n        {\n          cache: c,\n          cacheKeys: p\n        } = h,\n        u = a.namespaceURI === this.SVG_NS,\n        g = eU(e, this.rotation, 0),\n        f = h.styledMode ? a && eK.prototype.getStyle.call(a, \"font-size\") : l.fontSize;\n      if (eI(d) && (-1 === (r = d.toString()).indexOf(\"<\") && (r = r.replace(/\\d/g, \"0\")), r += [\"\", h.rootFontSize, f, g, this.textWidth, n, l.lineClamp, l.textOverflow, l.fontWeight].join(\",\")), r && !t && (i = c[r]), !i || i.polygon) {\n        if (u || h.forExport) {\n          try {\n            o = this.fakeTS && function (t) {\n              let e = a.querySelector(\".highcharts-text-outline\");\n              e && eB(e, {\n                display: t\n              });\n            }, eG(o) && o(\"none\"), i = a.getBBox ? eR({}, a.getBBox()) : {\n              width: a.offsetWidth,\n              height: a.offsetHeight,\n              x: 0,\n              y: 0\n            }, eG(o) && o(\"\");\n          } catch (t) {}\n          (!i || i.width < 0) && (i = {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n          });\n        } else i = this.htmlGetBBox();\n        s = i.height, u && (i.height = s = {\n          \"11px,17\": 14,\n          \"13px,20\": 16\n        }[`${f || \"\"},${Math.round(s)}`] || s), g && (i = this.getRotatedBox(i, g));\n        let t = {\n          bBox: i\n        };\n        eN(this, \"afterGetBBox\", t), i = t.bBox;\n      }\n      if (r && (\"\" === d || i.height > 0)) {\n        for (; p.length > 250;) delete c[p.shift()];\n        c[r] || p.push(r), c[r] = i;\n      }\n      return i;\n    }\n    getRotatedBox(t, e) {\n      let {\n          x: i,\n          y: s,\n          width: o,\n          height: r\n        } = t,\n        {\n          alignValue: n,\n          translateY: a,\n          rotationOriginX: h = 0,\n          rotationOriginY: l = 0\n        } = this,\n        d = ez(n),\n        c = Number(this.element.getAttribute(\"y\") || 0) - (a ? 0 : s),\n        p = e * ek,\n        u = (e - 90) * ek,\n        g = Math.cos(p),\n        f = Math.sin(p),\n        m = o * g,\n        x = o * f,\n        y = Math.cos(u),\n        b = Math.sin(u),\n        [[v, M], [k, w]] = [h, l].map(t => [t - t * g, t * f]),\n        S = i + d * (o - m) + v + w + c * y,\n        A = S + m,\n        T = A - r * y,\n        P = T - m,\n        C = s + c - d * x - M + k + c * b,\n        O = C + x,\n        E = O - r * b,\n        L = E - x,\n        B = Math.min(S, A, T, P),\n        I = Math.min(C, O, E, L),\n        D = Math.max(S, A, T, P) - B,\n        R = Math.max(C, O, E, L) - I;\n      return {\n        x: B,\n        y: I,\n        width: D,\n        height: R,\n        polygon: [[S, C], [A, O], [T, E], [P, L]]\n      };\n    }\n    getStyle(t) {\n      return eT.getComputedStyle(this.element || this, \"\").getPropertyValue(t);\n    }\n    hasClass(t) {\n      return -1 !== (\"\" + this.attr(\"class\")).split(\" \").indexOf(t);\n    }\n    hide() {\n      return this.attr({\n        visibility: \"hidden\"\n      });\n    }\n    htmlGetBBox() {\n      return {\n        height: 0,\n        width: 0,\n        x: 0,\n        y: 0\n      };\n    }\n    constructor(t, e) {\n      this.onEvents = {}, this.opacity = 1, this.SVG_NS = eA, this.element = \"span\" === e || \"body\" === e ? eE(e) : ew.createElementNS(this.SVG_NS, e), this.renderer = t, this.styles = {}, eN(this, \"afterInit\");\n    }\n    on(t, e) {\n      let {\n        onEvents: i\n      } = this;\n      return i[t] && i[t](), i[t] = eC(this.element, t, e), this;\n    }\n    opacitySetter(t, e, i) {\n      let s = Number(Number(t).toFixed(3));\n      this.opacity = s, i.setAttribute(e, s);\n    }\n    reAlign() {\n      this.alignOptions?.width && \"left\" !== this.alignOptions.align && (this.alignOptions.width = this.getBBox().width, this.placed = !1, this.align());\n    }\n    removeClass(t) {\n      return this.attr(\"class\", (\"\" + this.attr(\"class\")).replace(eX(t) ? RegExp(`(^| )${t}( |$)`) : t, \" \").replace(/ +/g, \" \").trim());\n    }\n    removeTextOutline() {\n      let t = this.element.querySelector(\"tspan.highcharts-text-outline\");\n      t && this.safeRemoveChild(t);\n    }\n    safeRemoveChild(t) {\n      let e = t.parentNode;\n      e && e.removeChild(t);\n    }\n    setRadialReference(t) {\n      let e = this.element.gradient && this.renderer.gradients[this.element.gradient];\n      return this.element.radialReference = t, e && e.radAttr && e.animate(this.renderer.getRadialAttr(t, e.radAttr)), this;\n    }\n    shadow(t) {\n      let {\n          renderer: e\n        } = this,\n        i = eY(this.parentGroup?.rotation === 90 ? {\n          offsetX: -1,\n          offsetY: -1\n        } : {}, eF(t) ? t : {}),\n        s = e.shadowDefinition(i);\n      return this.attr({\n        filter: t ? `url(${e.url}#${s})` : \"none\"\n      });\n    }\n    show(t = !0) {\n      return this.attr({\n        visibility: t ? \"inherit\" : \"visible\"\n      });\n    }\n    \"stroke-widthSetter\"(t, e, i) {\n      this[e] = t, i.setAttribute(e, t);\n    }\n    strokeWidth() {\n      if (!this.renderer.styledMode) return this[\"stroke-width\"] || 0;\n      let t = this.getStyle(\"stroke-width\"),\n        e = 0,\n        i;\n      return /px$/.test(t) ? e = eV(t) : \"\" !== t && (eO(i = ew.createElementNS(eA, \"rect\"), {\n        width: t,\n        \"stroke-width\": 0\n      }), this.element.parentNode.appendChild(i), e = i.getBBox().width, i.parentNode.removeChild(i)), e;\n    }\n    symbolAttr(t) {\n      let e = this;\n      eK.symbolCustomAttribs.forEach(function (i) {\n        e[i] = eU(t[i], e[i]);\n      }), e.attr({\n        d: e.renderer.symbols[e.symbolName](e.x, e.y, e.width, e.height, e)\n      });\n    }\n    textSetter(t) {\n      t !== this.textStr && (delete this.textPxLength, this.textStr = t, this.added && this.renderer.buildText(this), this.reAlign());\n    }\n    titleSetter(t) {\n      let e = this.element,\n        i = e.getElementsByTagName(\"title\")[0] || ew.createElementNS(this.SVG_NS, \"title\");\n      e.insertBefore ? e.insertBefore(i, e.firstChild) : e.appendChild(i), i.textContent = e_(eU(t, \"\"), [/<[^>]*>/g, \"\"]).replace(/&lt;/g, \"<\").replace(/&gt;/g, \">\");\n    }\n    toFront() {\n      let t = this.element;\n      return t.parentNode.appendChild(t), this;\n    }\n    translate(t, e) {\n      return this.attr({\n        translateX: t,\n        translateY: e\n      });\n    }\n    updateTransform(t = \"transform\") {\n      let {\n          element: e,\n          matrix: i,\n          rotation: s = 0,\n          rotationOriginX: o,\n          rotationOriginY: r,\n          scaleX: n,\n          scaleY: a,\n          translateX: h = 0,\n          translateY: l = 0\n        } = this,\n        d = [\"translate(\" + h + \",\" + l + \")\"];\n      eI(i) && d.push(\"matrix(\" + i.join(\",\") + \")\"), s && (d.push(\"rotate(\" + s + \" \" + eU(o, e.getAttribute(\"x\"), 0) + \" \" + eU(r, e.getAttribute(\"y\") || 0) + \")\"), this.text?.element.tagName === \"SPAN\" && this.text.attr({\n        rotation: s,\n        rotationOriginX: (o || 0) - this.padding,\n        rotationOriginY: (r || 0) - this.padding\n      })), (eI(n) || eI(a)) && d.push(\"scale(\" + eU(n, 1) + \" \" + eU(a, 1) + \")\"), d.length && !(this.text || this).textPath && e.setAttribute(t, d.join(\" \"));\n    }\n    visibilitySetter(t, e, i) {\n      \"inherit\" === t ? i.removeAttribute(e) : this[e] !== t && i.setAttribute(e, t), this[e] = t;\n    }\n    xGetter(t) {\n      return \"circle\" === this.element.nodeName && (\"x\" === t ? t = \"cx\" : \"y\" === t && (t = \"cy\")), this._defaultGetter(t);\n    }\n    zIndexSetter(t, e) {\n      let i = this.renderer,\n        s = this.parentGroup,\n        o = (s || i).element || i.box,\n        r = this.element,\n        n = o === i.box,\n        a,\n        h,\n        l,\n        d = !1,\n        c,\n        p = this.added,\n        u;\n      if (eI(t) ? (r.setAttribute(\"data-z-index\", t), t = +t, this[e] === t && (p = !1)) : eI(this[e]) && r.removeAttribute(\"data-z-index\"), this[e] = t, p) {\n        for ((t = this.zIndex) && s && (s.handleZ = !0), u = (a = o.childNodes).length - 1; u >= 0 && !d; u--) c = !eI(l = (h = a[u]).getAttribute(\"data-z-index\")), h !== r && (t < 0 && c && !n && !u ? (o.insertBefore(r, a[u]), d = !0) : (eV(l) <= t || c && (!eI(t) || t >= 0)) && (o.insertBefore(r, a[u + 1]), d = !0));\n        d || (o.insertBefore(r, a[n ? 3 : 0]), d = !0);\n      }\n      return d;\n    }\n  }\n  eK.symbolCustomAttribs = [\"anchorX\", \"anchorY\", \"clockwise\", \"end\", \"height\", \"innerR\", \"r\", \"start\", \"width\", \"x\", \"y\"], eK.prototype.strokeSetter = eK.prototype.fillSetter, eK.prototype.yGetter = eK.prototype.xGetter, eK.prototype.matrixSetter = eK.prototype.rotationOriginXSetter = eK.prototype.rotationOriginYSetter = eK.prototype.rotationSetter = eK.prototype.scaleXSetter = eK.prototype.scaleYSetter = eK.prototype.translateXSetter = eK.prototype.translateYSetter = eK.prototype.verticalAlignSetter = function (t, e) {\n    this[e] = t, this.doTransform = !0;\n  };\n  let eJ = eK,\n    {\n      defined: eQ,\n      extend: e0,\n      getAlignFactor: e1,\n      isNumber: e2,\n      merge: e3,\n      pick: e5,\n      removeEvent: e6\n    } = tt;\n  class e9 extends eJ {\n    constructor(t, e, i, s, o, r, n, a, h, l) {\n      let d;\n      super(t, \"g\"), this.paddingLeftSetter = this.paddingSetter, this.paddingRightSetter = this.paddingSetter, this.doUpdate = !1, this.textStr = e, this.x = i, this.y = s, this.anchorX = r, this.anchorY = n, this.baseline = h, this.className = l, this.addClass(\"button\" === l ? \"highcharts-no-tooltip\" : \"highcharts-label\"), l && this.addClass(\"highcharts-\" + l), this.text = t.text(void 0, 0, 0, a).attr({\n        zIndex: 1\n      }), \"string\" == typeof o && ((d = /^url\\((.*?)\\)$/.test(o)) || this.renderer.symbols[o]) && (this.symbolKey = o), this.bBox = e9.emptyBBox, this.padding = 3, this.baselineOffset = 0, this.needsBox = t.styledMode || d, this.deferredAttr = {}, this.alignFactor = 0;\n    }\n    alignSetter(t) {\n      let e = e1(t);\n      this.textAlign = t, e !== this.alignFactor && (this.alignFactor = e, this.bBox && e2(this.xSetting) && this.attr({\n        x: this.xSetting\n      }));\n    }\n    anchorXSetter(t, e) {\n      this.anchorX = t, this.boxAttr(e, Math.round(t) - this.getCrispAdjust() - this.xSetting);\n    }\n    anchorYSetter(t, e) {\n      this.anchorY = t, this.boxAttr(e, t - this.ySetting);\n    }\n    boxAttr(t, e) {\n      this.box ? this.box.attr(t, e) : this.deferredAttr[t] = e;\n    }\n    css(t) {\n      if (t) {\n        let e = {};\n        t = e3(t), e9.textProps.forEach(i => {\n          void 0 !== t[i] && (e[i] = t[i], delete t[i]);\n        }), this.text.css(e), \"fontSize\" in e || \"fontWeight\" in e ? this.updateTextPadding() : (\"width\" in e || \"textOverflow\" in e) && this.updateBoxSize();\n      }\n      return eJ.prototype.css.call(this, t);\n    }\n    destroy() {\n      e6(this.element, \"mouseenter\"), e6(this.element, \"mouseleave\"), this.text && this.text.destroy(), this.box && (this.box = this.box.destroy()), eJ.prototype.destroy.call(this);\n    }\n    fillSetter(t, e) {\n      t && (this.needsBox = !0), this.fill = t, this.boxAttr(e, t);\n    }\n    getBBox(t, e) {\n      this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();\n      let {\n          padding: i,\n          height: s = 0,\n          translateX: o = 0,\n          translateY: r = 0,\n          width: n = 0\n        } = this,\n        a = e5(this.paddingLeft, i),\n        h = e ?? (this.rotation || 0),\n        l = {\n          width: n,\n          height: s,\n          x: o + this.bBox.x - a,\n          y: r + this.bBox.y - i + this.baselineOffset\n        };\n      return h && (l = this.getRotatedBox(l, h)), l;\n    }\n    getCrispAdjust() {\n      return (this.renderer.styledMode && this.box ? this.box.strokeWidth() : this[\"stroke-width\"] ? parseInt(this[\"stroke-width\"], 10) : 0) % 2 / 2;\n    }\n    heightSetter(t) {\n      this.heightSetting = t, this.doUpdate = !0;\n    }\n    afterSetters() {\n      super.afterSetters(), this.doUpdate && (this.updateBoxSize(), this.doUpdate = !1);\n    }\n    onAdd() {\n      this.text.add(this), this.attr({\n        text: e5(this.textStr, \"\"),\n        x: this.x || 0,\n        y: this.y || 0\n      }), this.box && eQ(this.anchorX) && this.attr({\n        anchorX: this.anchorX,\n        anchorY: this.anchorY\n      });\n    }\n    paddingSetter(t, e) {\n      e2(t) ? t !== this[e] && (this[e] = t, this.updateTextPadding()) : this[e] = void 0;\n    }\n    rSetter(t, e) {\n      this.boxAttr(e, t);\n    }\n    strokeSetter(t, e) {\n      this.stroke = t, this.boxAttr(e, t);\n    }\n    \"stroke-widthSetter\"(t, e) {\n      t && (this.needsBox = !0), this[\"stroke-width\"] = t, this.boxAttr(e, t);\n    }\n    \"text-alignSetter\"(t) {\n      this.textAlign = this[\"text-align\"] = t, this.updateTextPadding();\n    }\n    textSetter(t) {\n      void 0 !== t && this.text.attr({\n        text: t\n      }), this.updateTextPadding(), this.reAlign();\n    }\n    updateBoxSize() {\n      let t;\n      let e = this.text,\n        i = {},\n        s = this.padding,\n        o = this.bBox = (!e2(this.widthSetting) || !e2(this.heightSetting) || this.textAlign) && eQ(e.textStr) ? e.getBBox(void 0, 0) : e9.emptyBBox;\n      this.width = this.getPaddedWidth(), this.height = (this.heightSetting || o.height || 0) + 2 * s;\n      let r = this.renderer.fontMetrics(e);\n      if (this.baselineOffset = s + Math.min((this.text.firstLineMetrics || r).b, o.height || 1 / 0), this.heightSetting && (this.baselineOffset += (this.heightSetting - r.h) / 2), this.needsBox && !e.textPath) {\n        if (!this.box) {\n          let t = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect();\n          t.addClass((\"button\" === this.className ? \"\" : \"highcharts-label-box\") + (this.className ? \" highcharts-\" + this.className + \"-box\" : \"\")), t.add(this);\n        }\n        t = this.getCrispAdjust(), i.x = t, i.y = (this.baseline ? -this.baselineOffset : 0) + t, i.width = Math.round(this.width), i.height = Math.round(this.height), this.box.attr(e0(i, this.deferredAttr)), this.deferredAttr = {};\n      }\n    }\n    updateTextPadding() {\n      let t = this.text,\n        e = t.styles.textAlign || this.textAlign;\n      if (!t.textPath) {\n        this.updateBoxSize();\n        let i = this.baseline ? 0 : this.baselineOffset,\n          s = (this.paddingLeft ?? this.padding) + e1(e) * (this.widthSetting ?? this.bBox.width);\n        (s !== t.x || i !== t.y) && (t.attr({\n          align: e,\n          x: s\n        }), void 0 !== i && t.attr(\"y\", i)), t.x = s, t.y = i;\n      }\n    }\n    widthSetter(t) {\n      this.widthSetting = e2(t) ? t : void 0, this.doUpdate = !0;\n    }\n    getPaddedWidth() {\n      let t = this.padding,\n        e = e5(this.paddingLeft, t),\n        i = e5(this.paddingRight, t);\n      return (this.widthSetting || this.bBox.width || 0) + e + i;\n    }\n    xSetter(t) {\n      this.x = t, this.alignFactor && (t -= this.alignFactor * this.getPaddedWidth(), this[\"forceAnimate:x\"] = !0), this.xSetting = Math.round(t), this.attr(\"translateX\", this.xSetting);\n    }\n    ySetter(t) {\n      this.ySetting = this.y = Math.round(t), this.attr(\"translateY\", this.ySetting);\n    }\n  }\n  e9.emptyBBox = {\n    width: 0,\n    height: 0,\n    x: 0,\n    y: 0\n  }, e9.textProps = [\"color\", \"direction\", \"fontFamily\", \"fontSize\", \"fontStyle\", \"fontWeight\", \"lineClamp\", \"lineHeight\", \"textAlign\", \"textDecoration\", \"textOutline\", \"textOverflow\", \"whiteSpace\", \"width\"];\n  let {\n    defined: e4,\n    isNumber: e8,\n    pick: e7\n  } = tt;\n  function it(t, e, i, s, o) {\n    let r = [];\n    if (o) {\n      let n = o.start || 0,\n        a = e7(o.r, i),\n        h = e7(o.r, s || i),\n        l = 2e-4 / (o.borderRadius ? 1 : Math.max(a, 1)),\n        d = Math.abs((o.end || 0) - n - 2 * Math.PI) < l,\n        c = (o.end || 0) - (d ? l : 0),\n        p = o.innerR,\n        u = e7(o.open, d),\n        g = Math.cos(n),\n        f = Math.sin(n),\n        m = Math.cos(c),\n        x = Math.sin(c),\n        y = e7(o.longArc, c - n - Math.PI < l ? 0 : 1),\n        b = [\"A\", a, h, 0, y, e7(o.clockwise, 1), t + a * m, e + h * x];\n      b.params = {\n        start: n,\n        end: c,\n        cx: t,\n        cy: e\n      }, r.push([\"M\", t + a * g, e + h * f], b), e4(p) && ((b = [\"A\", p, p, 0, y, e4(o.clockwise) ? 1 - o.clockwise : 0, t + p * g, e + p * f]).params = {\n        start: c,\n        end: n,\n        cx: t,\n        cy: e\n      }, r.push(u ? [\"M\", t + p * m, e + p * x] : [\"L\", t + p * m, e + p * x], b)), u || r.push([\"Z\"]);\n    }\n    return r;\n  }\n  function ie(t, e, i, s, o) {\n    return o && o.r ? ii(t, e, i, s, o) : [[\"M\", t, e], [\"L\", t + i, e], [\"L\", t + i, e + s], [\"L\", t, e + s], [\"Z\"]];\n  }\n  function ii(t, e, i, s, o) {\n    let r = o?.r || 0;\n    return [[\"M\", t + r, e], [\"L\", t + i - r, e], [\"A\", r, r, 0, 0, 1, t + i, e + r], [\"L\", t + i, e + s - r], [\"A\", r, r, 0, 0, 1, t + i - r, e + s], [\"L\", t + r, e + s], [\"A\", r, r, 0, 0, 1, t, e + s - r], [\"L\", t, e + r], [\"A\", r, r, 0, 0, 1, t + r, e], [\"Z\"]];\n  }\n  let is = {\n      arc: it,\n      callout: function (t, e, i, s, o) {\n        let r = Math.min(o && o.r || 0, i, s),\n          n = r + 6,\n          a = o && o.anchorX,\n          h = o && o.anchorY || 0,\n          l = ii(t, e, i, s, {\n            r\n          });\n        if (!e8(a) || a < i && a > 0 && h < s && h > 0) return l;\n        if (t + a > i - n) {\n          if (h > e + n && h < e + s - n) l.splice(3, 1, [\"L\", t + i, h - 6], [\"L\", t + i + 6, h], [\"L\", t + i, h + 6], [\"L\", t + i, e + s - r]);else if (a < i) {\n            let o = h < e + n,\n              d = o ? e : e + s;\n            l.splice(o ? 2 : 5, 0, [\"L\", a, h], [\"L\", t + i - r, d]);\n          } else l.splice(3, 1, [\"L\", t + i, s / 2], [\"L\", a, h], [\"L\", t + i, s / 2], [\"L\", t + i, e + s - r]);\n        } else if (t + a < n) {\n          if (h > e + n && h < e + s - n) l.splice(7, 1, [\"L\", t, h + 6], [\"L\", t - 6, h], [\"L\", t, h - 6], [\"L\", t, e + r]);else if (a > 0) {\n            let i = h < e + n,\n              o = i ? e : e + s;\n            l.splice(i ? 1 : 6, 0, [\"L\", a, h], [\"L\", t + r, o]);\n          } else l.splice(7, 1, [\"L\", t, s / 2], [\"L\", a, h], [\"L\", t, s / 2], [\"L\", t, e + r]);\n        } else h > s && a < i - n ? l.splice(5, 1, [\"L\", a + 6, e + s], [\"L\", a, e + s + 6], [\"L\", a - 6, e + s], [\"L\", t + r, e + s]) : h < 0 && a > n && l.splice(1, 1, [\"L\", a - 6, e], [\"L\", a, e - 6], [\"L\", a + 6, e], [\"L\", i - r, e]);\n        return l;\n      },\n      circle: function (t, e, i, s) {\n        return it(t + i / 2, e + s / 2, i / 2, s / 2, {\n          start: .5 * Math.PI,\n          end: 2.5 * Math.PI,\n          open: !1\n        });\n      },\n      diamond: function (t, e, i, s) {\n        return [[\"M\", t + i / 2, e], [\"L\", t + i, e + s / 2], [\"L\", t + i / 2, e + s], [\"L\", t, e + s / 2], [\"Z\"]];\n      },\n      rect: ie,\n      roundedRect: ii,\n      square: ie,\n      triangle: function (t, e, i, s) {\n        return [[\"M\", t + i / 2, e], [\"L\", t + i, e + s], [\"L\", t, e + s], [\"Z\"]];\n      },\n      \"triangle-down\": function (t, e, i, s) {\n        return [[\"M\", t, e], [\"L\", t + i, e], [\"L\", t + i / 2, e + s], [\"Z\"]];\n      }\n    },\n    {\n      doc: io,\n      SVG_NS: ir,\n      win: ia\n    } = O,\n    {\n      attr: ih,\n      extend: il,\n      fireEvent: id,\n      isString: ic,\n      objectEach: ip,\n      pick: iu\n    } = tt,\n    ig = (t, e) => t.substring(0, e) + \"…\",\n    im = class {\n      constructor(t) {\n        let e = t.styles;\n        this.renderer = t.renderer, this.svgElement = t, this.width = t.textWidth, this.textLineHeight = e && e.lineHeight, this.textOutline = e && e.textOutline, this.ellipsis = !!(e && \"ellipsis\" === e.textOverflow), this.lineClamp = e?.lineClamp, this.noWrap = !!(e && \"nowrap\" === e.whiteSpace);\n      }\n      buildSVG() {\n        let t = this.svgElement,\n          e = t.element,\n          i = t.renderer,\n          s = iu(t.textStr, \"\").toString(),\n          o = -1 !== s.indexOf(\"<\"),\n          r = e.childNodes,\n          n = !t.added && i.box,\n          a = [s, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, t.getStyle(\"font-size\"), t.styles.lineClamp, this.width].join(\",\");\n        if (a !== t.textCache) {\n          t.textCache = a, delete t.actualWidth;\n          for (let t = r.length; t--;) e.removeChild(r[t]);\n          if (o || this.ellipsis || this.width || t.textPath || -1 !== s.indexOf(\" \") && (!this.noWrap || /<br.*?>/g.test(s))) {\n            if (\"\" !== s) {\n              n && n.appendChild(e);\n              let i = new t6(s);\n              this.modifyTree(i.nodes), i.addToDOM(e), this.modifyDOM(), this.ellipsis && -1 !== (e.textContent || \"\").indexOf(\"…\") && t.attr(\"title\", this.unescapeEntities(t.textStr || \"\", [\"&lt;\", \"&gt;\"])), n && n.removeChild(e);\n            }\n          } else e.appendChild(io.createTextNode(this.unescapeEntities(s)));\n          ic(this.textOutline) && t.applyTextOutline && t.applyTextOutline(this.textOutline);\n        }\n      }\n      modifyDOM() {\n        let t;\n        let e = this.svgElement,\n          i = ih(e.element, \"x\");\n        for (e.firstLineMetrics = void 0; t = e.element.firstChild;) if (/^[\\s\\u200B]*$/.test(t.textContent || \" \")) e.element.removeChild(t);else break;\n        [].forEach.call(e.element.querySelectorAll(\"tspan.highcharts-br\"), (t, s) => {\n          t.nextSibling && t.previousSibling && (0 === s && 1 === t.previousSibling.nodeType && (e.firstLineMetrics = e.renderer.fontMetrics(t.previousSibling)), ih(t, {\n            dy: this.getLineHeight(t.nextSibling),\n            x: i\n          }));\n        });\n        let s = this.width || 0;\n        if (!s) return;\n        let o = (t, o) => {\n            let r = t.textContent || \"\",\n              n = r.replace(/([^\\^])-/g, \"$1- \").split(\" \"),\n              a = !this.noWrap && (n.length > 1 || e.element.childNodes.length > 1),\n              h = this.getLineHeight(o),\n              l = Math.max(0, s - .8 * h),\n              d = 0,\n              c = e.actualWidth;\n            if (a) {\n              let r = [],\n                a = [];\n              for (; o.firstChild && o.firstChild !== t;) a.push(o.firstChild), o.removeChild(o.firstChild);\n              for (; n.length;) if (n.length && !this.noWrap && d > 0 && (r.push(t.textContent || \"\"), t.textContent = n.join(\" \").replace(/- /g, \"-\")), this.truncate(t, void 0, n, 0 === d && c || 0, s, l, (t, e) => n.slice(0, e).join(\" \").replace(/- /g, \"-\")), c = e.actualWidth, d++, this.lineClamp && d >= this.lineClamp) {\n                n.length && (this.truncate(t, t.textContent || \"\", void 0, 0, s, l, ig), t.textContent = t.textContent?.replace(\"…\", \"\") + \"…\");\n                break;\n              }\n              a.forEach(e => {\n                o.insertBefore(e, t);\n              }), r.forEach(e => {\n                o.insertBefore(io.createTextNode(e), t);\n                let s = io.createElementNS(ir, \"tspan\");\n                s.textContent = \"​\", ih(s, {\n                  dy: h,\n                  x: i\n                }), o.insertBefore(s, t);\n              });\n            } else this.ellipsis && r && this.truncate(t, r, void 0, 0, s, l, ig);\n          },\n          r = t => {\n            [].slice.call(t.childNodes).forEach(i => {\n              i.nodeType === ia.Node.TEXT_NODE ? o(i, t) : (-1 !== i.className.baseVal.indexOf(\"highcharts-br\") && (e.actualWidth = 0), r(i));\n            });\n          };\n        r(e.element);\n      }\n      getLineHeight(t) {\n        let e = t.nodeType === ia.Node.TEXT_NODE ? t.parentElement : t;\n        return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(e || this.svgElement.element).h;\n      }\n      modifyTree(t) {\n        let e = (i, s) => {\n          let {\n              attributes: o = {},\n              children: r,\n              style: n = {},\n              tagName: a\n            } = i,\n            h = this.renderer.styledMode;\n          if (\"b\" === a || \"strong\" === a ? h ? o.class = \"highcharts-strong\" : n.fontWeight = \"bold\" : (\"i\" === a || \"em\" === a) && (h ? o.class = \"highcharts-emphasized\" : n.fontStyle = \"italic\"), n && n.color && (n.fill = n.color), \"br\" === a) {\n            o.class = \"highcharts-br\", i.textContent = \"​\";\n            let e = t[s + 1];\n            e && e.textContent && (e.textContent = e.textContent.replace(/^ +/gm, \"\"));\n          } else \"a\" === a && r && r.some(t => \"#text\" === t.tagName) && (i.children = [{\n            children: r,\n            tagName: \"tspan\"\n          }]);\n          \"#text\" !== a && \"a\" !== a && (i.tagName = \"tspan\"), il(i, {\n            attributes: o,\n            style: n\n          }), r && r.filter(t => \"#text\" !== t.tagName).forEach(e);\n        };\n        t.forEach(e), id(this.svgElement, \"afterModifyTree\", {\n          nodes: t\n        });\n      }\n      truncate(t, e, i, s, o, r, n) {\n        let a, h;\n        let l = this.svgElement,\n          {\n            rotation: d\n          } = l,\n          c = [],\n          p = i && !s ? 1 : 0,\n          u = (e || i || \"\").length,\n          g = u;\n        i || (o = r);\n        let f = function (e, o) {\n          let r = o || e,\n            n = t.parentNode;\n          if (n && void 0 === c[r] && n.getSubStringLength) try {\n            c[r] = s + n.getSubStringLength(0, i ? r + 1 : r);\n          } catch (t) {}\n          return c[r];\n        };\n        if (l.rotation = 0, s + (h = f(t.textContent.length)) > o) {\n          for (; p <= u;) g = Math.ceil((p + u) / 2), i && (a = n(i, g)), h = f(g, a && a.length - 1), p === u ? p = u + 1 : h > o ? u = g - 1 : p = g;\n          0 === u ? t.textContent = \"\" : e && u === e.length - 1 || (t.textContent = a || n(e || i, g)), this.ellipsis && h > o && this.truncate(t, t.textContent || \"\", void 0, 0, o, r, ig);\n        }\n        i && i.splice(0, g), l.actualWidth = h, l.rotation = d;\n      }\n      unescapeEntities(t, e) {\n        return ip(this.renderer.escapes, function (i, s) {\n          e && -1 !== e.indexOf(i) || (t = t.toString().replace(RegExp(i, \"g\"), s));\n        }), t;\n      }\n    },\n    {\n      defaultOptions: ix\n    } = tS,\n    {\n      charts: iy,\n      deg2rad: ib,\n      doc: iv,\n      isFirefox: iM,\n      isMS: ik,\n      isWebKit: iw,\n      noop: iS,\n      SVG_NS: iA,\n      symbolSizes: iT,\n      win: iP\n    } = O,\n    {\n      addEvent: iC,\n      attr: iO,\n      createElement: iE,\n      crisp: iL,\n      css: iB,\n      defined: iI,\n      destroyObjectProperties: iD,\n      extend: iR,\n      isArray: iN,\n      isNumber: iz,\n      isObject: iW,\n      isString: iG,\n      merge: iH,\n      pick: iF,\n      pInt: iX,\n      replaceNested: iY,\n      uniqueKey: ij\n    } = tt;\n  class iU {\n    constructor(t, e, i, s, o, r, n) {\n      let a, h;\n      let l = this.createElement(\"svg\").attr({\n          version: \"1.1\",\n          class: \"highcharts-root\"\n        }),\n        d = l.element;\n      n || l.css(this.getStyle(s || {})), t.appendChild(d), iO(t, \"dir\", \"ltr\"), -1 === t.innerHTML.indexOf(\"xmlns\") && iO(d, \"xmlns\", this.SVG_NS), this.box = d, this.boxWrapper = l, this.alignedObjects = [], this.url = this.getReferenceURL(), this.createElement(\"desc\").add().element.appendChild(iv.createTextNode(\"Created with Highcharts 12.1.2\")), this.defs = this.createElement(\"defs\").add(), this.allowHTML = r, this.forExport = o, this.styledMode = n, this.gradients = {}, this.cache = {}, this.cacheKeys = [], this.imgCount = 0, this.rootFontSize = l.getStyle(\"font-size\"), this.setSize(e, i, !1), iM && t.getBoundingClientRect && ((a = function () {\n        iB(t, {\n          left: 0,\n          top: 0\n        }), h = t.getBoundingClientRect(), iB(t, {\n          left: Math.ceil(h.left) - h.left + \"px\",\n          top: Math.ceil(h.top) - h.top + \"px\"\n        });\n      })(), this.unSubPixelFix = iC(iP, \"resize\", a));\n    }\n    definition(t) {\n      return new t6([t]).addToDOM(this.defs.element);\n    }\n    getReferenceURL() {\n      if ((iM || iw) && iv.getElementsByTagName(\"base\").length) {\n        if (!iI(e)) {\n          let t = ij(),\n            i = new t6([{\n              tagName: \"svg\",\n              attributes: {\n                width: 8,\n                height: 8\n              },\n              children: [{\n                tagName: \"defs\",\n                children: [{\n                  tagName: \"clipPath\",\n                  attributes: {\n                    id: t\n                  },\n                  children: [{\n                    tagName: \"rect\",\n                    attributes: {\n                      width: 4,\n                      height: 4\n                    }\n                  }]\n                }]\n              }, {\n                tagName: \"rect\",\n                attributes: {\n                  id: \"hitme\",\n                  width: 8,\n                  height: 8,\n                  \"clip-path\": `url(#${t})`,\n                  fill: \"rgba(0,0,0,0.001)\"\n                }\n              }]\n            }]).addToDOM(iv.body);\n          iB(i, {\n            position: \"fixed\",\n            top: 0,\n            left: 0,\n            zIndex: 9e5\n          });\n          let s = iv.elementFromPoint(6, 6);\n          e = \"hitme\" === (s && s.id), iv.body.removeChild(i);\n        }\n        if (e) return iY(iP.location.href.split(\"#\")[0], [/<[^>]*>/g, \"\"], [/([\\('\\)])/g, \"\\\\$1\"], [/ /g, \"%20\"]);\n      }\n      return \"\";\n    }\n    getStyle(t) {\n      return this.style = iR({\n        fontFamily: '-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", sans-serif',\n        fontSize: \"1rem\"\n      }, t), this.style;\n    }\n    setStyle(t) {\n      this.boxWrapper.css(this.getStyle(t));\n    }\n    isHidden() {\n      return !this.boxWrapper.getBBox().width;\n    }\n    destroy() {\n      let t = this.defs;\n      return this.box = null, this.boxWrapper = this.boxWrapper.destroy(), iD(this.gradients || {}), this.gradients = null, this.defs = t.destroy(), this.unSubPixelFix && this.unSubPixelFix(), this.alignedObjects = null, null;\n    }\n    createElement(t) {\n      return new this.Element(this, t);\n    }\n    getRadialAttr(t, e) {\n      return {\n        cx: t[0] - t[2] / 2 + (e.cx || 0) * t[2],\n        cy: t[1] - t[2] / 2 + (e.cy || 0) * t[2],\n        r: (e.r || 0) * t[2]\n      };\n    }\n    shadowDefinition(t) {\n      let e = [`highcharts-drop-shadow-${this.chartIndex}`, ...Object.keys(t).map(e => `${e}-${t[e]}`)].join(\"-\").toLowerCase().replace(/[^a-z\\d\\-]/g, \"\"),\n        i = iH({\n          color: \"#000000\",\n          offsetX: 1,\n          offsetY: 1,\n          opacity: .15,\n          width: 5\n        }, t);\n      return this.defs.element.querySelector(`#${e}`) || this.definition({\n        tagName: \"filter\",\n        attributes: {\n          id: e,\n          filterUnits: i.filterUnits\n        },\n        children: this.getShadowFilterContent(i)\n      }), e;\n    }\n    getShadowFilterContent(t) {\n      return [{\n        tagName: \"feDropShadow\",\n        attributes: {\n          dx: t.offsetX,\n          dy: t.offsetY,\n          \"flood-color\": t.color,\n          \"flood-opacity\": Math.min(5 * t.opacity, 1),\n          stdDeviation: t.width / 2\n        }\n      }];\n    }\n    buildText(t) {\n      new im(t).buildSVG();\n    }\n    getContrast(t) {\n      let e = tO.parse(t).rgba.map(t => {\n          let e = t / 255;\n          return e <= .03928 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4);\n        }),\n        i = .2126 * e[0] + .7152 * e[1] + .0722 * e[2];\n      return 1.05 / (i + .05) > (i + .05) / .05 ? \"#FFFFFF\" : \"#000000\";\n    }\n    button(t, e, i, s, o = {}, r, n, a, h, l) {\n      let d = this.label(t, e, i, h, void 0, void 0, l, void 0, \"button\"),\n        c = this.styledMode,\n        p = arguments,\n        u = 0;\n      o = iH(ix.global.buttonTheme, o), c && (delete o.fill, delete o.stroke, delete o[\"stroke-width\"]);\n      let g = o.states || {},\n        f = o.style || {};\n      delete o.states, delete o.style;\n      let m = [t6.filterUserAttributes(o)],\n        x = [f];\n      return c || [\"hover\", \"select\", \"disabled\"].forEach((t, e) => {\n        m.push(iH(m[0], t6.filterUserAttributes(p[e + 5] || g[t] || {}))), x.push(m[e + 1].style), delete m[e + 1].style;\n      }), iC(d.element, ik ? \"mouseover\" : \"mouseenter\", function () {\n        3 !== u && d.setState(1);\n      }), iC(d.element, ik ? \"mouseout\" : \"mouseleave\", function () {\n        3 !== u && d.setState(u);\n      }), d.setState = (t = 0) => {\n        if (1 !== t && (d.state = u = t), d.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass(\"highcharts-button-\" + [\"normal\", \"hover\", \"pressed\", \"disabled\"][t]), !c) {\n          d.attr(m[t]);\n          let e = x[t];\n          iW(e) && d.css(e);\n        }\n      }, d.attr(m[0]), !c && (d.css(iR({\n        cursor: \"default\"\n      }, f)), l && d.text.css({\n        pointerEvents: \"none\"\n      })), d.on(\"touchstart\", t => t.stopPropagation()).on(\"click\", function (t) {\n        3 !== u && s.call(d, t);\n      });\n    }\n    crispLine(t, e) {\n      let [i, s] = t;\n      return iI(i[1]) && i[1] === s[1] && (i[1] = s[1] = iL(i[1], e)), iI(i[2]) && i[2] === s[2] && (i[2] = s[2] = iL(i[2], e)), t;\n    }\n    path(t) {\n      let e = this.styledMode ? {} : {\n        fill: \"none\"\n      };\n      return iN(t) ? e.d = t : iW(t) && iR(e, t), this.createElement(\"path\").attr(e);\n    }\n    circle(t, e, i) {\n      let s = iW(t) ? t : void 0 === t ? {} : {\n          x: t,\n          y: e,\n          r: i\n        },\n        o = this.createElement(\"circle\");\n      return o.xSetter = o.ySetter = function (t, e, i) {\n        i.setAttribute(\"c\" + e, t);\n      }, o.attr(s);\n    }\n    arc(t, e, i, s, o, r) {\n      let n;\n      iW(t) ? (e = (n = t).y, i = n.r, s = n.innerR, o = n.start, r = n.end, t = n.x) : n = {\n        innerR: s,\n        start: o,\n        end: r\n      };\n      let a = this.symbol(\"arc\", t, e, i, i, n);\n      return a.r = i, a;\n    }\n    rect(t, e, i, s, o, r) {\n      let n = iW(t) ? t : void 0 === t ? {} : {\n          x: t,\n          y: e,\n          r: o,\n          width: Math.max(i || 0, 0),\n          height: Math.max(s || 0, 0)\n        },\n        a = this.createElement(\"rect\");\n      return this.styledMode || (void 0 !== r && (n[\"stroke-width\"] = r, iR(n, a.crisp(n))), n.fill = \"none\"), a.rSetter = function (t, e, i) {\n        a.r = t, iO(i, {\n          rx: t,\n          ry: t\n        });\n      }, a.rGetter = function () {\n        return a.r || 0;\n      }, a.attr(n);\n    }\n    roundedRect(t) {\n      return this.symbol(\"roundedRect\").attr(t);\n    }\n    setSize(t, e, i) {\n      this.width = t, this.height = e, this.boxWrapper.animate({\n        width: t,\n        height: e\n      }, {\n        step: function () {\n          this.attr({\n            viewBox: \"0 0 \" + this.attr(\"width\") + \" \" + this.attr(\"height\")\n          });\n        },\n        duration: iF(i, !0) ? void 0 : 0\n      }), this.alignElements();\n    }\n    g(t) {\n      let e = this.createElement(\"g\");\n      return t ? e.attr({\n        class: \"highcharts-\" + t\n      }) : e;\n    }\n    image(t, e, i, s, o, r) {\n      let n = {\n        preserveAspectRatio: \"none\"\n      };\n      iz(e) && (n.x = e), iz(i) && (n.y = i), iz(s) && (n.width = s), iz(o) && (n.height = o);\n      let a = this.createElement(\"image\").attr(n),\n        h = function (e) {\n          a.attr({\n            href: t\n          }), r.call(a, e);\n        };\n      if (r) {\n        a.attr({\n          href: \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"\n        });\n        let e = new iP.Image();\n        iC(e, \"load\", h), e.src = t, e.complete && h({});\n      } else a.attr({\n        href: t\n      });\n      return a;\n    }\n    symbol(t, e, i, s, o, r) {\n      let n, a, h, l;\n      let d = this,\n        c = /^url\\((.*?)\\)$/,\n        p = c.test(t),\n        u = !p && (this.symbols[t] ? t : \"circle\"),\n        g = u && this.symbols[u];\n      if (g) \"number\" == typeof e && (a = g.call(this.symbols, e || 0, i || 0, s || 0, o || 0, r)), n = this.path(a), d.styledMode || n.attr(\"fill\", \"none\"), iR(n, {\n        symbolName: u || void 0,\n        x: e,\n        y: i,\n        width: s,\n        height: o\n      }), r && iR(n, r);else if (p) {\n        h = t.match(c)[1];\n        let s = n = this.image(h);\n        s.imgwidth = iF(r && r.width, iT[h] && iT[h].width), s.imgheight = iF(r && r.height, iT[h] && iT[h].height), l = t => t.attr({\n          width: t.width,\n          height: t.height\n        }), [\"width\", \"height\"].forEach(t => {\n          s[`${t}Setter`] = function (t, e) {\n            this[e] = t;\n            let {\n                alignByTranslate: i,\n                element: s,\n                width: o,\n                height: n,\n                imgwidth: a,\n                imgheight: h\n              } = this,\n              l = \"width\" === e ? a : h,\n              d = 1;\n            r && \"within\" === r.backgroundSize && o && n && a && h ? (d = Math.min(o / a, n / h), iO(s, {\n              width: Math.round(a * d),\n              height: Math.round(h * d)\n            })) : s && l && s.setAttribute(e, l), !i && a && h && this.translate(((o || 0) - a * d) / 2, ((n || 0) - h * d) / 2);\n          };\n        }), iI(e) && s.attr({\n          x: e,\n          y: i\n        }), s.isImg = !0, s.symbolUrl = t, iI(s.imgwidth) && iI(s.imgheight) ? l(s) : (s.attr({\n          width: 0,\n          height: 0\n        }), iE(\"img\", {\n          onload: function () {\n            let t = iy[d.chartIndex];\n            0 === this.width && (iB(this, {\n              position: \"absolute\",\n              top: \"-999em\"\n            }), iv.body.appendChild(this)), iT[h] = {\n              width: this.width,\n              height: this.height\n            }, s.imgwidth = this.width, s.imgheight = this.height, s.element && l(s), this.parentNode && this.parentNode.removeChild(this), d.imgCount--, d.imgCount || !t || t.hasLoaded || t.onload();\n          },\n          src: h\n        }), this.imgCount++);\n      }\n      return n;\n    }\n    clipRect(t, e, i, s) {\n      return this.rect(t, e, i, s, 0);\n    }\n    text(t, e, i, s) {\n      let o = {};\n      if (s && (this.allowHTML || !this.forExport)) return this.html(t, e, i);\n      o.x = Math.round(e || 0), i && (o.y = Math.round(i)), iI(t) && (o.text = t);\n      let r = this.createElement(\"text\").attr(o);\n      return s && (!this.forExport || this.allowHTML) || (r.xSetter = function (t, e, i) {\n        let s = i.getElementsByTagName(\"tspan\"),\n          o = i.getAttribute(e);\n        for (let i = 0, r; i < s.length; i++) (r = s[i]).getAttribute(e) === o && r.setAttribute(e, t);\n        i.setAttribute(e, t);\n      }), r;\n    }\n    fontMetrics(t) {\n      let e = iX(eJ.prototype.getStyle.call(t, \"font-size\") || 0),\n        i = e < 24 ? e + 3 : Math.round(1.2 * e),\n        s = Math.round(.8 * i);\n      return {\n        h: i,\n        b: s,\n        f: e\n      };\n    }\n    rotCorr(t, e, i) {\n      let s = t;\n      return e && i && (s = Math.max(s * Math.cos(e * ib), 4)), {\n        x: -t / 3 * Math.sin(e * ib),\n        y: s\n      };\n    }\n    pathToSegments(t) {\n      let e = [],\n        i = [],\n        s = {\n          A: 8,\n          C: 7,\n          H: 2,\n          L: 3,\n          M: 3,\n          Q: 5,\n          S: 5,\n          T: 3,\n          V: 2\n        };\n      for (let o = 0; o < t.length; o++) iG(i[0]) && iz(t[o]) && i.length === s[i[0].toUpperCase()] && t.splice(o, 0, i[0].replace(\"M\", \"L\").replace(\"m\", \"l\")), \"string\" == typeof t[o] && (i.length && e.push(i.slice(0)), i.length = 0), i.push(t[o]);\n      return e.push(i.slice(0)), e;\n    }\n    label(t, e, i, s, o, r, n, a, h) {\n      return new e9(this, t, e, i, s, o, r, n, a, h);\n    }\n    alignElements() {\n      this.alignedObjects.forEach(t => t.align());\n    }\n  }\n  iR(iU.prototype, {\n    Element: eJ,\n    SVG_NS: iA,\n    escapes: {\n      \"&\": \"&amp;\",\n      \"<\": \"&lt;\",\n      \">\": \"&gt;\",\n      \"'\": \"&#39;\",\n      '\"': \"&quot;\"\n    },\n    symbols: is,\n    draw: iS\n  }), eu.registerRendererType(\"svg\", iU, !0);\n  let {\n      composed: iV\n    } = O,\n    {\n      attr: i$,\n      css: i_,\n      createElement: iq,\n      defined: iZ,\n      extend: iK,\n      getAlignFactor: iJ,\n      isNumber: iQ,\n      pInt: i0,\n      pushUnique: i1\n    } = tt;\n  function i2(t, e, i) {\n    let s = this.div?.style || i.style;\n    eJ.prototype[`${e}Setter`].call(this, t, e, i), s && (s[e] = t);\n  }\n  let i3 = (t, e) => {\n    if (!t.div) {\n      let i = i$(t.element, \"class\"),\n        s = t.css,\n        o = iq(\"div\", i ? {\n          className: i\n        } : void 0, {\n          position: \"absolute\",\n          left: `${t.translateX || 0}px`,\n          top: `${t.translateY || 0}px`,\n          ...t.styles,\n          display: t.display,\n          opacity: t.opacity,\n          visibility: t.visibility\n        }, t.parentGroup?.div || e);\n      t.classSetter = (t, e, i) => {\n        i.setAttribute(\"class\", t), o.className = t;\n      }, t.translateXSetter = t.translateYSetter = (e, i) => {\n        t[i] = e, o.style[\"translateX\" === i ? \"left\" : \"top\"] = `${e}px`, t.doTransform = !0;\n      }, t.opacitySetter = t.visibilitySetter = i2, t.css = e => (s.call(t, e), e.cursor && (o.style.cursor = e.cursor), e.pointerEvents && (o.style.pointerEvents = e.pointerEvents), t), t.on = function () {\n        return eJ.prototype.on.apply({\n          element: o,\n          onEvents: t.onEvents\n        }, arguments), t;\n      }, t.div = o;\n    }\n    return t.div;\n  };\n  class i5 extends eJ {\n    static compose(t) {\n      i1(iV, this.compose) && (t.prototype.html = function (t, e, i) {\n        return new i5(this, \"span\").attr({\n          text: t,\n          x: Math.round(e),\n          y: Math.round(i)\n        });\n      });\n    }\n    constructor(t, e) {\n      super(t, e), this.css({\n        position: \"absolute\",\n        ...(t.styledMode ? {} : {\n          fontFamily: t.style.fontFamily,\n          fontSize: t.style.fontSize\n        })\n      });\n    }\n    getSpanCorrection(t, e, i) {\n      this.xCorr = -t * i, this.yCorr = -e;\n    }\n    css(t) {\n      let e;\n      let {\n          element: i\n        } = this,\n        s = \"SPAN\" === i.tagName && t && \"width\" in t,\n        o = s && t.width;\n      return s && (delete t.width, this.textWidth = i0(o) || void 0, e = !0), t?.textOverflow === \"ellipsis\" && (t.overflow = \"hidden\"), t?.lineClamp && (t.display = \"-webkit-box\", t.WebkitLineClamp = t.lineClamp, t.WebkitBoxOrient = \"vertical\", t.overflow = \"hidden\"), iQ(Number(t?.fontSize)) && (t.fontSize = t.fontSize + \"px\"), iK(this.styles, t), i_(i, t), e && this.updateTransform(), this;\n    }\n    htmlGetBBox() {\n      let {\n        element: t\n      } = this;\n      return {\n        x: t.offsetLeft,\n        y: t.offsetTop,\n        width: t.offsetWidth,\n        height: t.offsetHeight\n      };\n    }\n    updateTransform() {\n      if (!this.added) {\n        this.alignOnAdd = !0;\n        return;\n      }\n      let {\n          element: t,\n          renderer: e,\n          rotation: i,\n          rotationOriginX: s,\n          rotationOriginY: o,\n          scaleX: r,\n          scaleY: n,\n          styles: a,\n          textAlign: h = \"left\",\n          textWidth: l,\n          translateX: d = 0,\n          translateY: c = 0,\n          x: p = 0,\n          y: u = 0\n        } = this,\n        {\n          display: g = \"block\",\n          whiteSpace: f\n        } = a;\n      if (i_(t, {\n        marginLeft: `${d}px`,\n        marginTop: `${c}px`\n      }), \"SPAN\" === t.tagName) {\n        let a;\n        let d = [i, h, t.innerHTML, l, this.textAlign].join(\",\"),\n          c = -(this.parentGroup?.padding * 1) || 0;\n        if (l !== this.oldTextWidth) {\n          let e = this.textPxLength ? this.textPxLength : (i_(t, {\n              width: \"\",\n              whiteSpace: f || \"nowrap\"\n            }), t.offsetWidth),\n            s = l || 0;\n          (s > this.oldTextWidth || e > s) && (/[ \\-]/.test(t.textContent || t.innerText) || \"ellipsis\" === t.style.textOverflow) && (i_(t, {\n            width: e > s || i || r ? l + \"px\" : \"auto\",\n            display: g,\n            whiteSpace: f || \"normal\"\n          }), this.oldTextWidth = l);\n        }\n        d !== this.cTT && (a = e.fontMetrics(t).b, iZ(i) && (i !== (this.oldRotation || 0) || h !== this.oldAlign) && this.setSpanRotation(i, c, c), this.getSpanCorrection(!iZ(i) && !this.textWidth && this.textPxLength || t.offsetWidth, a, iJ(h)));\n        let {\n            xCorr: m = 0,\n            yCorr: x = 0\n          } = this,\n          y = {\n            left: `${p + m}px`,\n            top: `${u + x}px`,\n            textAlign: h,\n            transformOrigin: `${(s ?? p) - m - p - c}px ${(o ?? u) - x - u - c}px`\n          };\n        (r || n) && (y.transform = `scale(${r ?? 1},${n ?? 1})`), i_(t, y), this.cTT = d, this.oldRotation = i, this.oldAlign = h;\n      }\n    }\n    setSpanRotation(t, e, i) {\n      i_(this.element, {\n        transform: `rotate(${t}deg)`,\n        transformOrigin: `${e}% ${i}px`\n      });\n    }\n    add(t) {\n      let e;\n      let i = this.renderer.box.parentNode,\n        s = [];\n      if (this.parentGroup = t, t && !(e = t.div)) {\n        let o = t;\n        for (; o;) s.push(o), o = o.parentGroup;\n        for (let t of s.reverse()) e = i3(t, i);\n      }\n      return (e || i).appendChild(this.element), this.added = !0, this.alignOnAdd && this.updateTransform(), this;\n    }\n    textSetter(t) {\n      t !== this.textStr && (delete this.bBox, delete this.oldTextWidth, t6.setElementHTML(this.element, t ?? \"\"), this.textStr = t, this.doTransform = !0);\n    }\n    alignSetter(t) {\n      this.alignValue = this.textAlign = t, this.doTransform = !0;\n    }\n    xSetter(t, e) {\n      this[e] = t, this.doTransform = !0;\n    }\n  }\n  let i6 = i5.prototype;\n  i6.visibilitySetter = i6.opacitySetter = i2, i6.ySetter = i6.rotationSetter = i6.rotationOriginXSetter = i6.rotationOriginYSetter = i6.xSetter, function (t) {\n    t.xAxis = {\n      alignTicks: !0,\n      allowDecimals: void 0,\n      panningEnabled: !0,\n      zIndex: 2,\n      zoomEnabled: !0,\n      dateTimeLabelFormats: {\n        millisecond: {\n          main: \"%[HMSL]\",\n          range: !1\n        },\n        second: {\n          main: \"%[HMS]\",\n          range: !1\n        },\n        minute: {\n          main: \"%[HM]\",\n          range: !1\n        },\n        hour: {\n          main: \"%[HM]\",\n          range: !1\n        },\n        day: {\n          main: \"%[eb]\"\n        },\n        week: {\n          main: \"%[eb]\"\n        },\n        month: {\n          main: \"%[bY]\"\n        },\n        year: {\n          main: \"%Y\"\n        }\n      },\n      endOnTick: !1,\n      gridLineDashStyle: \"Solid\",\n      gridZIndex: 1,\n      labels: {\n        autoRotationLimit: 80,\n        distance: 15,\n        enabled: !0,\n        indentation: 10,\n        overflow: \"justify\",\n        reserveSpace: void 0,\n        rotation: void 0,\n        staggerLines: 0,\n        step: 0,\n        useHTML: !1,\n        zIndex: 7,\n        style: {\n          color: \"#333333\",\n          cursor: \"default\",\n          fontSize: \"0.8em\",\n          textOverflow: \"ellipsis\"\n        }\n      },\n      maxPadding: .01,\n      minorGridLineDashStyle: \"Solid\",\n      minorTickLength: 2,\n      minorTickPosition: \"outside\",\n      minorTicksPerMajor: 5,\n      minPadding: .01,\n      offset: void 0,\n      reversed: void 0,\n      reversedStacks: !1,\n      showEmpty: !0,\n      showFirstLabel: !0,\n      showLastLabel: !0,\n      startOfWeek: 1,\n      startOnTick: !1,\n      tickLength: 10,\n      tickPixelInterval: 100,\n      tickmarkPlacement: \"between\",\n      tickPosition: \"outside\",\n      title: {\n        align: \"middle\",\n        useHTML: !1,\n        x: 0,\n        y: 0,\n        style: {\n          color: \"#666666\",\n          fontSize: \"0.8em\"\n        }\n      },\n      visible: !0,\n      minorGridLineColor: \"#f2f2f2\",\n      minorGridLineWidth: 1,\n      minorTickColor: \"#999999\",\n      lineColor: \"#333333\",\n      lineWidth: 1,\n      gridLineColor: \"#e6e6e6\",\n      gridLineWidth: void 0,\n      tickColor: \"#333333\"\n    }, t.yAxis = {\n      reversedStacks: !0,\n      endOnTick: !0,\n      maxPadding: .05,\n      minPadding: .05,\n      tickPixelInterval: 72,\n      showLastLabel: !0,\n      labels: {\n        x: void 0\n      },\n      startOnTick: !0,\n      title: {\n        text: \"Values\"\n      },\n      stackLabels: {\n        animation: {},\n        allowOverlap: !1,\n        enabled: !1,\n        crop: !0,\n        overflow: \"justify\",\n        formatter: function () {\n          let {\n            numberFormatter: t\n          } = this.axis.chart;\n          return t(this.total || 0, -1);\n        },\n        style: {\n          color: \"#000000\",\n          fontSize: \"0.7em\",\n          fontWeight: \"bold\",\n          textOutline: \"1px contrast\"\n        }\n      },\n      gridLineWidth: 1,\n      lineWidth: 0\n    };\n  }(h || (h = {}));\n  let i9 = h,\n    {\n      addEvent: i4,\n      isFunction: i8,\n      objectEach: i7,\n      removeEvent: st\n    } = tt;\n  (l || (l = {})).registerEventOptions = function (t, e) {\n    t.eventOptions = t.eventOptions || {}, i7(e.events, function (e, i) {\n      t.eventOptions[i] !== e && (t.eventOptions[i] && (st(t, i, t.eventOptions[i]), delete t.eventOptions[i]), i8(e) && (t.eventOptions[i] = e, i4(t, i, e, {\n        order: 0\n      })));\n    });\n  };\n  let se = l,\n    {\n      deg2rad: si\n    } = O,\n    {\n      clamp: ss,\n      correctFloat: so,\n      defined: sr,\n      destroyObjectProperties: sn,\n      extend: sa,\n      fireEvent: sh,\n      getAlignFactor: sl,\n      isNumber: sd,\n      merge: sc,\n      objectEach: sp,\n      pick: su\n    } = tt,\n    sg = class {\n      constructor(t, e, i, s, o) {\n        this.isNew = !0, this.isNewLabel = !0, this.axis = t, this.pos = e, this.type = i || \"\", this.parameters = o || {}, this.tickmarkOffset = this.parameters.tickmarkOffset, this.options = this.parameters.options, sh(this, \"init\"), i || s || this.addLabel();\n      }\n      addLabel() {\n        let t = this,\n          e = t.axis,\n          i = e.options,\n          s = e.chart,\n          o = e.categories,\n          r = e.logarithmic,\n          n = e.names,\n          a = t.pos,\n          h = su(t.options && t.options.labels, i.labels),\n          l = e.tickPositions,\n          d = a === l[0],\n          c = a === l[l.length - 1],\n          p = (!h.step || 1 === h.step) && 1 === e.tickInterval,\n          u = l.info,\n          g = t.label,\n          f,\n          m,\n          x,\n          y = this.parameters.category || (o ? su(o[a], n[a], a) : a);\n        r && sd(y) && (y = so(r.lin2log(y))), e.dateTime && (u ? f = (m = s.time.resolveDTLFormat(i.dateTimeLabelFormats[!i.grid && u.higherRanks[a] || u.unitName])).main : sd(y) && (f = e.dateTime.getXDateFormat(y, i.dateTimeLabelFormats || {}))), t.isFirst = d, t.isLast = c;\n        let b = {\n          axis: e,\n          chart: s,\n          dateTimeLabelFormat: f,\n          isFirst: d,\n          isLast: c,\n          pos: a,\n          tick: t,\n          tickPositionInfo: u,\n          value: y\n        };\n        sh(this, \"labelFormat\", b);\n        let v = t => h.formatter ? h.formatter.call(t, t) : h.format ? (t.text = e.defaultLabelFormatter.call(t), ep.format(h.format, t, s)) : e.defaultLabelFormatter.call(t),\n          M = v.call(b, b),\n          k = m && m.list;\n        k ? t.shortenLabel = function () {\n          for (x = 0; x < k.length; x++) if (sa(b, {\n            dateTimeLabelFormat: k[x]\n          }), g.attr({\n            text: v.call(b, b)\n          }), g.getBBox().width < e.getSlotWidth(t) - 2 * (h.padding || 0)) return;\n          g.attr({\n            text: \"\"\n          });\n        } : t.shortenLabel = void 0, p && e._addedPlotLB && t.moveLabel(M, h), sr(g) || t.movedLabel ? g && g.textStr !== M && !p && (!g.textWidth || h.style.width || g.styles.width || g.css({\n          width: null\n        }), g.attr({\n          text: M\n        }), g.textPxLength = g.getBBox().width) : (t.label = g = t.createLabel(M, h), t.rotation = 0);\n      }\n      createLabel(t, e, i) {\n        let s = this.axis,\n          {\n            renderer: o,\n            styledMode: r\n          } = s.chart,\n          n = sr(t) && e.enabled ? o.text(t, i?.x, i?.y, e.useHTML).add(s.labelGroup) : void 0;\n        if (n) {\n          let t = e.style.whiteSpace || \"normal\";\n          r || n.css(sc(e.style, {\n            whiteSpace: \"nowrap\"\n          })), n.textPxLength = n.getBBox().width, r || n.css({\n            whiteSpace: t\n          });\n        }\n        return n;\n      }\n      destroy() {\n        sn(this, this.axis);\n      }\n      getPosition(t, e, i, s) {\n        let o = this.axis,\n          r = o.chart,\n          n = s && r.oldChartHeight || r.chartHeight,\n          a = {\n            x: t ? so(o.translate(e + i, void 0, void 0, s) + o.transB) : o.left + o.offset + (o.opposite ? (s && r.oldChartWidth || r.chartWidth) - o.right - o.left : 0),\n            y: t ? n - o.bottom + o.offset - (o.opposite ? o.height : 0) : so(n - o.translate(e + i, void 0, void 0, s) - o.transB)\n          };\n        return a.y = ss(a.y, -1e9, 1e9), sh(this, \"afterGetPosition\", {\n          pos: a\n        }), a;\n      }\n      getLabelPosition(t, e, i, s, o, r, n, a) {\n        let h, l;\n        let d = this.axis,\n          c = d.transA,\n          p = d.isLinked && d.linkedParent ? d.linkedParent.reversed : d.reversed,\n          u = d.staggerLines,\n          g = d.tickRotCorr || {\n            x: 0,\n            y: 0\n          },\n          f = s || d.reserveSpaceDefault ? 0 : -d.labelOffset * (\"center\" === d.labelAlign ? .5 : 1),\n          m = o.distance,\n          x = {};\n        return h = 0 === d.side ? i.rotation ? -m : -i.getBBox().height : 2 === d.side ? g.y + m : Math.cos(i.rotation * si) * (g.y - i.getBBox(!1, 0).height / 2), sr(o.y) && (h = 0 === d.side && d.horiz ? o.y + h : o.y), t = t + su(o.x, [0, 1, 0, -1][d.side] * m) + f + g.x - (r && s ? r * c * (p ? -1 : 1) : 0), e = e + h - (r && !s ? r * c * (p ? 1 : -1) : 0), u && (l = n / (a || 1) % u, d.opposite && (l = u - l - 1), e += l * (d.labelOffset / u)), x.x = t, x.y = Math.round(e), sh(this, \"afterGetLabelPosition\", {\n          pos: x,\n          tickmarkOffset: r,\n          index: n\n        }), x;\n      }\n      getLabelSize() {\n        return this.label ? this.label.getBBox()[this.axis.horiz ? \"height\" : \"width\"] : 0;\n      }\n      getMarkPath(t, e, i, s, o = !1, r) {\n        return r.crispLine([[\"M\", t, e], [\"L\", t + (o ? 0 : -i), e + (o ? i : 0)]], s);\n      }\n      handleOverflow(t) {\n        let e = this.axis,\n          i = e.options.labels,\n          s = t.x,\n          o = e.chart.chartWidth,\n          r = e.chart.spacing,\n          n = su(e.labelLeft, Math.min(e.pos, r[3])),\n          a = su(e.labelRight, Math.max(e.isRadial ? 0 : e.pos + e.len, o - r[1])),\n          h = this.label,\n          l = this.rotation,\n          d = sl(e.labelAlign || h.attr(\"align\")),\n          c = h.getBBox().width,\n          p = e.getSlotWidth(this),\n          u = p,\n          g = 1,\n          f,\n          m,\n          x;\n        l || \"justify\" !== i.overflow ? l < 0 && s - d * c < n ? x = Math.round(s / Math.cos(l * si) - n) : l > 0 && s + d * c > a && (x = Math.round((o - s) / Math.cos(l * si))) : (f = s - d * c, m = s + (1 - d) * c, f < n ? u = t.x + u * (1 - d) - n : m > a && (u = a - t.x + u * d, g = -1), (u = Math.min(p, u)) < p && \"center\" === e.labelAlign && (t.x += g * (p - u - d * (p - Math.min(c, u)))), (c > u || e.autoRotation && (h.styles || {}).width) && (x = u)), x && h && (this.shortenLabel ? this.shortenLabel() : h.css(sa({}, {\n          width: Math.floor(x) + \"px\",\n          lineClamp: e.isRadial ? 0 : 1\n        })));\n      }\n      moveLabel(t, e) {\n        let i = this,\n          s = i.label,\n          o = i.axis,\n          r = !1,\n          n;\n        s && s.textStr === t ? (i.movedLabel = s, r = !0, delete i.label) : sp(o.ticks, function (e) {\n          r || e.isNew || e === i || !e.label || e.label.textStr !== t || (i.movedLabel = e.label, r = !0, e.labelPos = i.movedLabel.xy, delete e.label);\n        }), !r && (i.labelPos || s) && (n = i.labelPos || s.xy, i.movedLabel = i.createLabel(t, e, n), i.movedLabel && i.movedLabel.attr({\n          opacity: 0\n        }));\n      }\n      render(t, e, i) {\n        let s = this.axis,\n          o = s.horiz,\n          r = this.pos,\n          n = su(this.tickmarkOffset, s.tickmarkOffset),\n          a = this.getPosition(o, r, n, e),\n          h = a.x,\n          l = a.y,\n          d = s.pos,\n          c = d + s.len,\n          p = o ? h : l;\n        !s.chart.polar && this.isNew && (so(p) < d || p > c) && (i = 0);\n        let u = su(i, this.label && this.label.newOpacity, 1);\n        i = su(i, 1), this.isActive = !0, this.renderGridLine(e, i), this.renderMark(a, i), this.renderLabel(a, e, u, t), this.isNew = !1, sh(this, \"afterRender\");\n      }\n      renderGridLine(t, e) {\n        let i = this.axis,\n          s = i.options,\n          o = {},\n          r = this.pos,\n          n = this.type,\n          a = su(this.tickmarkOffset, i.tickmarkOffset),\n          h = i.chart.renderer,\n          l = this.gridLine,\n          d,\n          c = s.gridLineWidth,\n          p = s.gridLineColor,\n          u = s.gridLineDashStyle;\n        \"minor\" === this.type && (c = s.minorGridLineWidth, p = s.minorGridLineColor, u = s.minorGridLineDashStyle), l || (i.chart.styledMode || (o.stroke = p, o[\"stroke-width\"] = c || 0, o.dashstyle = u), n || (o.zIndex = 1), t && (e = 0), this.gridLine = l = h.path().attr(o).addClass(\"highcharts-\" + (n ? n + \"-\" : \"\") + \"grid-line\").add(i.gridGroup)), l && (d = i.getPlotLinePath({\n          value: r + a,\n          lineWidth: l.strokeWidth(),\n          force: \"pass\",\n          old: t,\n          acrossPanes: !1\n        })) && l[t || this.isNew ? \"attr\" : \"animate\"]({\n          d: d,\n          opacity: e\n        });\n      }\n      renderMark(t, e) {\n        let i = this.axis,\n          s = i.options,\n          o = i.chart.renderer,\n          r = this.type,\n          n = i.tickSize(r ? r + \"Tick\" : \"tick\"),\n          a = t.x,\n          h = t.y,\n          l = su(s[\"minor\" !== r ? \"tickWidth\" : \"minorTickWidth\"], !r && i.isXAxis ? 1 : 0),\n          d = s[\"minor\" !== r ? \"tickColor\" : \"minorTickColor\"],\n          c = this.mark,\n          p = !c;\n        n && (i.opposite && (n[0] = -n[0]), c || (this.mark = c = o.path().addClass(\"highcharts-\" + (r ? r + \"-\" : \"\") + \"tick\").add(i.axisGroup), i.chart.styledMode || c.attr({\n          stroke: d,\n          \"stroke-width\": l\n        })), c[p ? \"attr\" : \"animate\"]({\n          d: this.getMarkPath(a, h, n[0], c.strokeWidth(), i.horiz, o),\n          opacity: e\n        }));\n      }\n      renderLabel(t, e, i, s) {\n        let o = this.axis,\n          r = o.horiz,\n          n = o.options,\n          a = this.label,\n          h = n.labels,\n          l = h.step,\n          d = su(this.tickmarkOffset, o.tickmarkOffset),\n          c = t.x,\n          p = t.y,\n          u = !0;\n        a && sd(c) && (a.xy = t = this.getLabelPosition(c, p, a, r, h, d, s, l), (!this.isFirst || this.isLast || n.showFirstLabel) && (!this.isLast || this.isFirst || n.showLastLabel) ? !r || h.step || h.rotation || e || 0 === i || this.handleOverflow(t) : u = !1, l && s % l && (u = !1), u && sd(t.y) ? (t.opacity = i, a[this.isNewLabel ? \"attr\" : \"animate\"](t).show(!0), this.isNewLabel = !1) : (a.hide(), this.isNewLabel = !0));\n      }\n      replaceMovedLabel() {\n        let t = this.label,\n          e = this.axis;\n        t && !this.isNew && (t.animate({\n          opacity: 0\n        }, void 0, t.destroy), delete this.label), e.isDirty = !0, this.label = this.movedLabel, delete this.movedLabel;\n      }\n    },\n    {\n      animObject: sf\n    } = tU,\n    {\n      xAxis: sm,\n      yAxis: sx\n    } = i9,\n    {\n      defaultOptions: sy\n    } = tS,\n    {\n      registerEventOptions: sb\n    } = se,\n    {\n      deg2rad: sv\n    } = O,\n    {\n      arrayMax: sM,\n      arrayMin: sk,\n      clamp: sw,\n      correctFloat: sS,\n      defined: sA,\n      destroyObjectProperties: sT,\n      erase: sP,\n      error: sC,\n      extend: sO,\n      fireEvent: sE,\n      getClosestDistance: sL,\n      insertItem: sB,\n      isArray: sI,\n      isNumber: sD,\n      isString: sR,\n      merge: sN,\n      normalizeTickInterval: sz,\n      objectEach: sW,\n      pick: sG,\n      relativeLength: sH,\n      removeEvent: sF,\n      splat: sX,\n      syncTimeout: sY\n    } = tt,\n    sj = (t, e) => sz(e, void 0, void 0, sG(t.options.allowDecimals, e < .5 || void 0 !== t.tickAmount), !!t.tickAmount);\n  sO(sy, {\n    xAxis: sm,\n    yAxis: sN(sm, sx)\n  });\n  let sU = /*#__PURE__*/(() => {\n    class sU {\n      constructor(t, e, i) {\n        this.init(t, e, i);\n      }\n      init(t, e, i = this.coll) {\n        let s = \"xAxis\" === i,\n          o = this.isZAxis || (t.inverted ? !s : s);\n        this.chart = t, this.horiz = o, this.isXAxis = s, this.coll = i, sE(this, \"init\", {\n          userOptions: e\n        }), this.opposite = sG(e.opposite, this.opposite), this.side = sG(e.side, this.side, o ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3), this.setOptions(e);\n        let r = this.options,\n          n = r.labels;\n        this.type ?? (this.type = r.type || \"linear\"), this.uniqueNames ?? (this.uniqueNames = r.uniqueNames ?? !0), sE(this, \"afterSetType\"), this.userOptions = e, this.minPixelPadding = 0, this.reversed = sG(r.reversed, this.reversed), this.visible = r.visible, this.zoomEnabled = r.zoomEnabled, this.hasNames = \"category\" === this.type || !0 === r.categories, this.categories = sI(r.categories) && r.categories || (this.hasNames ? [] : void 0), this.names || (this.names = [], this.names.keys = {}), this.plotLinesAndBandsGroups = {}, this.positiveValuesOnly = !!this.logarithmic, this.isLinked = sA(r.linkedTo), this.ticks = {}, this.labelEdge = [], this.minorTicks = {}, this.plotLinesAndBands = [], this.alternateBands = {}, this.len ?? (this.len = 0), this.minRange = this.userMinRange = r.minRange || r.maxZoom, this.range = r.range, this.offset = r.offset || 0, this.max = void 0, this.min = void 0;\n        let a = sG(r.crosshair, sX(t.options.tooltip.crosshairs)[s ? 0 : 1]);\n        this.crosshair = !0 === a ? {} : a, -1 === t.axes.indexOf(this) && (s ? t.axes.splice(t.xAxis.length, 0, this) : t.axes.push(this), sB(this, t[this.coll])), t.orderItems(this.coll), this.series = this.series || [], t.inverted && !this.isZAxis && s && !sA(this.reversed) && (this.reversed = !0), this.labelRotation = sD(n.rotation) ? n.rotation : void 0, sb(this, r), sE(this, \"afterInit\");\n      }\n      setOptions(t) {\n        let e = this.horiz ? {\n          labels: {\n            autoRotation: [-45],\n            padding: 3\n          },\n          margin: 15\n        } : {\n          labels: {\n            padding: 1\n          },\n          title: {\n            rotation: 90 * this.side\n          }\n        };\n        this.options = sN(e, sy[this.coll], t), sE(this, \"afterSetOptions\", {\n          userOptions: t\n        });\n      }\n      defaultLabelFormatter() {\n        let t = this.axis,\n          {\n            numberFormatter: e\n          } = this.chart,\n          i = sD(this.value) ? this.value : NaN,\n          s = t.chart.time,\n          o = t.categories,\n          r = this.dateTimeLabelFormat,\n          n = sy.lang,\n          a = n.numericSymbols,\n          h = n.numericSymbolMagnitude || 1e3,\n          l = t.logarithmic ? Math.abs(i) : t.tickInterval,\n          d = a && a.length,\n          c,\n          p;\n        if (o) p = `${this.value}`;else if (r) p = s.dateFormat(r, i, !0);else if (d && a && l >= 1e3) for (; d-- && void 0 === p;) l >= (c = Math.pow(h, d + 1)) && 10 * i % c == 0 && null !== a[d] && 0 !== i && (p = e(i / c, -1) + a[d]);\n        return void 0 === p && (p = Math.abs(i) >= 1e4 ? e(i, -1) : e(i, -1, void 0, \"\")), p;\n      }\n      getSeriesExtremes() {\n        let t;\n        let e = this;\n        sE(this, \"getSeriesExtremes\", null, function () {\n          e.hasVisibleSeries = !1, e.dataMin = e.dataMax = e.threshold = void 0, e.softThreshold = !e.isXAxis, e.series.forEach(i => {\n            if (i.reserveSpace()) {\n              let s = i.options,\n                o,\n                r = s.threshold,\n                n,\n                a;\n              if (e.hasVisibleSeries = !0, e.positiveValuesOnly && 0 >= (r || 0) && (r = void 0), e.isXAxis) (o = i.getColumn(\"x\")).length && (o = e.logarithmic ? o.filter(t => t > 0) : o, n = (t = i.getXExtremes(o)).min, a = t.max, sD(n) || n instanceof Date || (o = o.filter(sD), n = (t = i.getXExtremes(o)).min, a = t.max), o.length && (e.dataMin = Math.min(sG(e.dataMin, n), n), e.dataMax = Math.max(sG(e.dataMax, a), a)));else {\n                let t = i.applyExtremes();\n                sD(t.dataMin) && (n = t.dataMin, e.dataMin = Math.min(sG(e.dataMin, n), n)), sD(t.dataMax) && (a = t.dataMax, e.dataMax = Math.max(sG(e.dataMax, a), a)), sA(r) && (e.threshold = r), (!s.softThreshold || e.positiveValuesOnly) && (e.softThreshold = !1);\n              }\n            }\n          });\n        }), sE(this, \"afterGetSeriesExtremes\");\n      }\n      translate(t, e, i, s, o, r) {\n        let n = this.linkedParent || this,\n          a = s && n.old ? n.old.min : n.min;\n        if (!sD(a)) return NaN;\n        let h = n.minPixelPadding,\n          l = (n.isOrdinal || n.brokenAxis?.hasBreaks || n.logarithmic && o) && n.lin2val,\n          d = 1,\n          c = 0,\n          p = s && n.old ? n.old.transA : n.transA,\n          u = 0;\n        return p || (p = n.transA), i && (d *= -1, c = n.len), n.reversed && (d *= -1, c -= d * (n.sector || n.len)), e ? (u = (t = t * d + c - h) / p + a, l && (u = n.lin2val(u))) : (l && (t = n.val2lin(t)), u = d * (t - a) * p + c + d * h + (sD(r) ? p * r : 0), n.isRadial || (u = sS(u))), u;\n      }\n      toPixels(t, e) {\n        return this.translate(this.chart?.time.parse(t) ?? NaN, !1, !this.horiz, void 0, !0) + (e ? 0 : this.pos);\n      }\n      toValue(t, e) {\n        return this.translate(t - (e ? 0 : this.pos), !0, !this.horiz, void 0, !0);\n      }\n      getPlotLinePath(t) {\n        let e = this,\n          i = e.chart,\n          s = e.left,\n          o = e.top,\n          r = t.old,\n          n = t.value,\n          a = t.lineWidth,\n          h = r && i.oldChartHeight || i.chartHeight,\n          l = r && i.oldChartWidth || i.chartWidth,\n          d = e.transB,\n          c = t.translatedValue,\n          p = t.force,\n          u,\n          g,\n          f,\n          m,\n          x;\n        function y(t, e, i) {\n          return \"pass\" !== p && (t < e || t > i) && (p ? t = sw(t, e, i) : x = !0), t;\n        }\n        let b = {\n          value: n,\n          lineWidth: a,\n          old: r,\n          force: p,\n          acrossPanes: t.acrossPanes,\n          translatedValue: c\n        };\n        return sE(this, \"getPlotLinePath\", b, function (t) {\n          u = f = (c = sw(c = sG(c, e.translate(n, void 0, void 0, r)), -1e9, 1e9)) + d, g = m = h - c - d, sD(c) ? e.horiz ? (g = o, m = h - e.bottom + (e.options.isInternal ? 0 : i.scrollablePixelsY || 0), u = f = y(u, s, s + e.width)) : (u = s, f = l - e.right + (i.scrollablePixelsX || 0), g = m = y(g, o, o + e.height)) : (x = !0, p = !1), t.path = x && !p ? void 0 : i.renderer.crispLine([[\"M\", u, g], [\"L\", f, m]], a || 1);\n        }), b.path;\n      }\n      getLinearTickPositions(t, e, i) {\n        let s, o, r;\n        let n = sS(Math.floor(e / t) * t),\n          a = sS(Math.ceil(i / t) * t),\n          h = [];\n        if (sS(n + t) === n && (r = 20), this.single) return [e];\n        for (s = n; s <= a && (h.push(s), (s = sS(s + t, r)) !== o);) o = s;\n        return h;\n      }\n      getMinorTickInterval() {\n        let {\n          minorTicks: t,\n          minorTickInterval: e\n        } = this.options;\n        return !0 === t ? sG(e, \"auto\") : !1 !== t ? e : void 0;\n      }\n      getMinorTickPositions() {\n        let t = this.options,\n          e = this.tickPositions,\n          i = this.minorTickInterval,\n          s = this.pointRangePadding || 0,\n          o = (this.min || 0) - s,\n          r = (this.max || 0) + s,\n          n = this.brokenAxis?.hasBreaks ? this.brokenAxis.unitLength : r - o,\n          a = [],\n          h;\n        if (n && n / i < this.len / 3) {\n          let s = this.logarithmic;\n          if (s) this.paddedTicks.forEach(function (t, e, o) {\n            e && a.push.apply(a, s.getLogTickPositions(i, o[e - 1], o[e], !0));\n          });else if (this.dateTime && \"auto\" === this.getMinorTickInterval()) a = a.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(i), o, r, t.startOfWeek));else for (h = o + (e[0] - o) % i; h <= r && h !== a[0]; h += i) a.push(h);\n        }\n        return 0 !== a.length && this.trimTicks(a), a;\n      }\n      adjustForMinRange() {\n        let t = this.options,\n          e = this.logarithmic,\n          i = this.chart.time,\n          {\n            max: s,\n            min: o,\n            minRange: r\n          } = this,\n          n,\n          a,\n          h,\n          l;\n        this.isXAxis && void 0 === r && !e && (r = sA(t.min) || sA(t.max) || sA(t.floor) || sA(t.ceiling) ? null : Math.min(5 * (sL(this.series.map(t => {\n          let e = t.getColumn(\"x\");\n          return t.xIncrement ? e.slice(0, 2) : e;\n        })) || 0), this.dataMax - this.dataMin)), sD(s) && sD(o) && sD(r) && s - o < r && (a = this.dataMax - this.dataMin >= r, n = (r - s + o) / 2, h = [o - n, i.parse(t.min) ?? o - n], a && (h[2] = e ? e.log2lin(this.dataMin) : this.dataMin), l = [(o = sM(h)) + r, i.parse(t.max) ?? o + r], a && (l[2] = e ? e.log2lin(this.dataMax) : this.dataMax), (s = sk(l)) - o < r && (h[0] = s - r, h[1] = i.parse(t.min) ?? s - r, o = sM(h))), this.minRange = r, this.min = o, this.max = s;\n      }\n      getClosest() {\n        let t, e;\n        if (this.categories) e = 1;else {\n          let i = [];\n          this.series.forEach(function (t) {\n            let s = t.closestPointRange,\n              o = t.getColumn(\"x\");\n            1 === o.length ? i.push(o[0]) : t.sorted && sA(s) && t.reserveSpace() && (e = sA(e) ? Math.min(e, s) : s);\n          }), i.length && (i.sort((t, e) => t - e), t = sL([i]));\n        }\n        return t && e ? Math.min(t, e) : t || e;\n      }\n      nameToX(t) {\n        let e = sI(this.options.categories),\n          i = e ? this.categories : this.names,\n          s = t.options.x,\n          o;\n        return t.series.requireSorting = !1, sA(s) || (s = this.uniqueNames && i ? e ? i.indexOf(t.name) : sG(i.keys[t.name], -1) : t.series.autoIncrement()), -1 === s ? !e && i && (o = i.length) : sD(s) && (o = s), void 0 !== o ? (this.names[o] = t.name, this.names.keys[t.name] = o) : t.x && (o = t.x), o;\n      }\n      updateNames() {\n        let t = this,\n          e = this.names;\n        e.length > 0 && (Object.keys(e.keys).forEach(function (t) {\n          delete e.keys[t];\n        }), e.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(e => {\n          e.xIncrement = null, (!e.points || e.isDirtyData) && (t.max = Math.max(t.max || 0, e.dataTable.rowCount - 1), e.processData(), e.generatePoints());\n          let i = e.getColumn(\"x\").slice();\n          e.data.forEach((e, s) => {\n            let o = i[s];\n            e?.options && void 0 !== e.name && void 0 !== (o = t.nameToX(e)) && o !== e.x && (i[s] = e.x = o);\n          }), e.dataTable.setColumn(\"x\", i);\n        }));\n      }\n      setAxisTranslation() {\n        let t = this,\n          e = t.max - t.min,\n          i = t.linkedParent,\n          s = !!t.categories,\n          o = t.isXAxis,\n          r = t.axisPointRange || 0,\n          n,\n          a = 0,\n          h = 0,\n          l,\n          d = t.transA;\n        (o || s || r) && (n = t.getClosest(), i ? (a = i.minPointOffset, h = i.pointRangePadding) : t.series.forEach(function (e) {\n          let i = s ? 1 : o ? sG(e.options.pointRange, n, 0) : t.axisPointRange || 0,\n            l = e.options.pointPlacement;\n          if (r = Math.max(r, i), !t.single || s) {\n            let t = e.is(\"xrange\") ? !o : o;\n            a = Math.max(a, t && sR(l) ? 0 : i / 2), h = Math.max(h, t && \"on\" === l ? 0 : i);\n          }\n        }), l = t.ordinal && t.ordinal.slope && n ? t.ordinal.slope / n : 1, t.minPointOffset = a *= l, t.pointRangePadding = h *= l, t.pointRange = Math.min(r, t.single && s ? 1 : e), o && n && (t.closestPointRange = n)), t.translationSlope = t.transA = d = t.staticScale || t.len / (e + h || 1), t.transB = t.horiz ? t.left : t.bottom, t.minPixelPadding = d * a, sE(this, \"afterSetAxisTranslation\");\n      }\n      minFromRange() {\n        let {\n          max: t,\n          min: e\n        } = this;\n        return sD(t) && sD(e) && t - e || void 0;\n      }\n      setTickInterval(t) {\n        let {\n            categories: e,\n            chart: i,\n            dataMax: s,\n            dataMin: o,\n            dateTime: r,\n            isXAxis: n,\n            logarithmic: a,\n            options: h,\n            softThreshold: l\n          } = this,\n          d = i.time,\n          c = sD(this.threshold) ? this.threshold : void 0,\n          p = this.minRange || 0,\n          {\n            ceiling: u,\n            floor: g,\n            linkedTo: f,\n            softMax: m,\n            softMin: x\n          } = h,\n          y = sD(f) && i[this.coll]?.[f],\n          b = h.tickPixelInterval,\n          v = h.maxPadding,\n          M = h.minPadding,\n          k = 0,\n          w,\n          S = sD(h.tickInterval) && h.tickInterval >= 0 ? h.tickInterval : void 0,\n          A,\n          T,\n          P,\n          C;\n        if (r || e || y || this.getTickAmount(), P = sG(this.userMin, d.parse(h.min)), C = sG(this.userMax, d.parse(h.max)), y ? (this.linkedParent = y, w = y.getExtremes(), this.min = sG(w.min, w.dataMin), this.max = sG(w.max, w.dataMax), this.type !== y.type && sC(11, !0, i)) : (l && sA(c) && sD(s) && sD(o) && (o >= c ? (A = c, M = 0) : s <= c && (T = c, v = 0)), this.min = sG(P, A, o), this.max = sG(C, T, s)), sD(this.max) && sD(this.min) && (a && (this.positiveValuesOnly && !t && 0 >= Math.min(this.min, sG(o, this.min)) && sC(10, !0, i), this.min = sS(a.log2lin(this.min), 16), this.max = sS(a.log2lin(this.max), 16)), this.range && sD(o) && (this.userMin = this.min = P = Math.max(o, this.minFromRange() || 0), this.userMax = C = this.max, this.range = void 0)), sE(this, \"foundExtremes\"), this.adjustForMinRange(), sD(this.min) && sD(this.max)) {\n          if (!sD(this.userMin) && sD(x) && x < this.min && (this.min = P = x), !sD(this.userMax) && sD(m) && m > this.max && (this.max = C = m), e || this.axisPointRange || this.stacking?.usePercentage || y || !(k = this.max - this.min) || (!sA(P) && M && (this.min -= k * M), sA(C) || !v || (this.max += k * v)), !sD(this.userMin) && sD(g) && (this.min = Math.max(this.min, g)), !sD(this.userMax) && sD(u) && (this.max = Math.min(this.max, u)), l && sD(o) && sD(s)) {\n            let t = c || 0;\n            !sA(P) && this.min < t && o >= t ? this.min = h.minRange ? Math.min(t, this.max - p) : t : !sA(C) && this.max > t && s <= t && (this.max = h.minRange ? Math.max(t, this.min + p) : t);\n          }\n          !i.polar && this.min > this.max && (sA(h.min) ? this.max = this.min : sA(h.max) && (this.min = this.max)), k = this.max - this.min;\n        }\n        if (this.min !== this.max && sD(this.min) && sD(this.max) ? y && !S && b === y.options.tickPixelInterval ? this.tickInterval = S = y.tickInterval : this.tickInterval = sG(S, this.tickAmount ? k / Math.max(this.tickAmount - 1, 1) : void 0, e ? 1 : k * b / Math.max(this.len, b)) : this.tickInterval = 1, n && !t) {\n          let t = this.min !== this.old?.min || this.max !== this.old?.max;\n          this.series.forEach(function (e) {\n            e.forceCrop = e.forceCropping?.(), e.processData(t);\n          }), sE(this, \"postProcessData\", {\n            hasExtremesChanged: t\n          });\n        }\n        this.setAxisTranslation(), sE(this, \"initialAxisTranslation\"), this.pointRange && !S && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));\n        let O = sG(h.minTickInterval, r && !this.series.some(t => !t.sorted) ? this.closestPointRange : 0);\n        !S && this.tickInterval < O && (this.tickInterval = O), r || a || S || (this.tickInterval = sj(this, this.tickInterval)), this.tickAmount || (this.tickInterval = this.unsquish()), this.setTickPositions();\n      }\n      setTickPositions() {\n        let t = this.options,\n          e = t.tickPositions,\n          i = t.tickPositioner,\n          s = this.getMinorTickInterval(),\n          o = !this.isPanning,\n          r = o && t.startOnTick,\n          n = o && t.endOnTick,\n          a = [],\n          h;\n        if (this.tickmarkOffset = this.categories && \"between\" === t.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0, this.single = this.min === this.max && sA(this.min) && !this.tickAmount && (this.min % 1 == 0 || !1 !== t.allowDecimals), e) a = e.slice();else if (sD(this.min) && sD(this.max)) {\n          if (!this.ordinal?.positions && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) a = [this.min, this.max], sC(19, !1, this.chart);else if (this.dateTime) a = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, t.units), this.min, this.max, t.startOfWeek, this.ordinal?.positions, this.closestPointRange, !0);else if (this.logarithmic) a = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);else {\n            let t = this.tickInterval,\n              e = t;\n            for (; e <= 2 * t;) if (a = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && a.length > this.tickAmount) this.tickInterval = sj(this, e *= 1.1);else break;\n          }\n          a.length > this.len && (a = [a[0], a[a.length - 1]])[0] === a[1] && (a.length = 1), i && (this.tickPositions = a, (h = i.apply(this, [this.min, this.max])) && (a = h));\n        }\n        this.tickPositions = a, this.minorTickInterval = \"auto\" === s && this.tickInterval ? this.tickInterval / t.minorTicksPerMajor : s, this.paddedTicks = a.slice(0), this.trimTicks(a, r, n), !this.isLinked && sD(this.min) && sD(this.max) && (this.single && a.length < 2 && !this.categories && !this.series.some(t => t.is(\"heatmap\") && \"between\" === t.options.pointPlacement) && (this.min -= .5, this.max += .5), e || h || this.adjustTickAmount()), sE(this, \"afterSetTickPositions\");\n      }\n      trimTicks(t, e, i) {\n        let s = t[0],\n          o = t[t.length - 1],\n          r = !this.isOrdinal && this.minPointOffset || 0;\n        if (sE(this, \"trimTicks\"), !this.isLinked) {\n          if (e && s !== -1 / 0) this.min = s;else for (; this.min - r > t[0];) t.shift();\n          if (i) this.max = o;else for (; this.max + r < t[t.length - 1];) t.pop();\n          0 === t.length && sA(s) && !this.options.tickPositions && t.push((o + s) / 2);\n        }\n      }\n      alignToOthers() {\n        let t;\n        let e = this,\n          i = e.chart,\n          s = [this],\n          o = e.options,\n          r = i.options.chart,\n          n = \"yAxis\" === this.coll && r.alignThresholds,\n          a = [];\n        if (e.thresholdAlignment = void 0, (!1 !== r.alignTicks && o.alignTicks || n) && !1 !== o.startOnTick && !1 !== o.endOnTick && !e.logarithmic) {\n          let o = t => {\n              let {\n                horiz: e,\n                options: i\n              } = t;\n              return [e ? i.left : i.top, i.width, i.height, i.pane].join(\",\");\n            },\n            r = o(this);\n          i[this.coll].forEach(function (i) {\n            let {\n              series: n\n            } = i;\n            n.length && n.some(t => t.visible) && i !== e && o(i) === r && (t = !0, s.push(i));\n          });\n        }\n        if (t && n) {\n          s.forEach(t => {\n            let i = t.getThresholdAlignment(e);\n            sD(i) && a.push(i);\n          });\n          let t = a.length > 1 ? a.reduce((t, e) => t += e, 0) / a.length : void 0;\n          s.forEach(e => {\n            e.thresholdAlignment = t;\n          });\n        }\n        return t;\n      }\n      getThresholdAlignment(t) {\n        if ((!sD(this.dataMin) || this !== t && this.series.some(t => t.isDirty || t.isDirtyData)) && this.getSeriesExtremes(), sD(this.threshold)) {\n          let t = sw((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1);\n          return this.options.reversed && (t = 1 - t), t;\n        }\n      }\n      getTickAmount() {\n        let t = this.options,\n          e = t.tickPixelInterval,\n          i = t.tickAmount;\n        sA(t.tickInterval) || i || !(this.len < e) || this.isRadial || this.logarithmic || !t.startOnTick || !t.endOnTick || (i = 2), !i && this.alignToOthers() && (i = Math.ceil(this.len / e) + 1), i < 4 && (this.finalTickAmt = i, i = 5), this.tickAmount = i;\n      }\n      adjustTickAmount() {\n        let t = this,\n          {\n            finalTickAmt: e,\n            max: i,\n            min: s,\n            options: o,\n            tickPositions: r,\n            tickAmount: n,\n            thresholdAlignment: a\n          } = t,\n          h = r?.length,\n          l = sG(t.threshold, t.softThreshold ? 0 : null),\n          d,\n          c,\n          p = t.tickInterval,\n          u,\n          g = () => r.push(sS(r[r.length - 1] + p)),\n          f = () => r.unshift(sS(r[0] - p));\n        if (sD(a) && (u = a < .5 ? Math.ceil(a * (n - 1)) : Math.floor(a * (n - 1)), o.reversed && (u = n - 1 - u)), t.hasData() && sD(s) && sD(i)) {\n          let a = () => {\n            t.transA *= (h - 1) / (n - 1), t.min = o.startOnTick ? r[0] : Math.min(s, r[0]), t.max = o.endOnTick ? r[r.length - 1] : Math.max(i, r[r.length - 1]);\n          };\n          if (sD(u) && sD(t.threshold)) {\n            for (; r[u] !== l || r.length !== n || r[0] > s || r[r.length - 1] < i;) {\n              for (r.length = 0, r.push(t.threshold); r.length < n;) void 0 === r[u] || r[u] > t.threshold ? f() : g();\n              if (p > 8 * t.tickInterval) break;\n              p *= 2;\n            }\n            a();\n          } else if (h < n) {\n            for (; r.length < n;) r.length % 2 || s === l ? g() : f();\n            a();\n          }\n          if (sA(e)) {\n            for (c = d = r.length; c--;) (3 === e && c % 2 == 1 || e <= 2 && c > 0 && c < d - 1) && r.splice(c, 1);\n            t.finalTickAmt = void 0;\n          }\n        }\n      }\n      setScale() {\n        let {\n            coll: t,\n            stacking: e\n          } = this,\n          i = !1,\n          s = !1;\n        this.series.forEach(t => {\n          i = i || t.isDirtyData || t.isDirty, s = s || t.xAxis && t.xAxis.isDirty || !1;\n        }), this.setAxisSize();\n        let o = this.len !== (this.old && this.old.len);\n        o || i || s || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (e && \"yAxis\" === t && e.buildStacks(), this.forceRedraw = !1, this.userMinRange || (this.minRange = void 0), this.getSeriesExtremes(), this.setTickInterval(), e && \"xAxis\" === t && e.buildStacks(), this.isDirty || (this.isDirty = o || this.min !== this.old?.min || this.max !== this.old?.max)) : e && e.cleanStacks(), i && delete this.allExtremes, sE(this, \"afterSetScale\");\n      }\n      setExtremes(t, e, i = !0, s, o) {\n        let r = this.chart;\n        this.series.forEach(t => {\n          delete t.kdTree;\n        }), t = r.time.parse(t), e = r.time.parse(e), sE(this, \"setExtremes\", o = sO(o, {\n          min: t,\n          max: e\n        }), t => {\n          this.userMin = t.min, this.userMax = t.max, this.eventArgs = t, i && r.redraw(s);\n        });\n      }\n      setAxisSize() {\n        let t = this.chart,\n          e = this.options,\n          i = e.offsets || [0, 0, 0, 0],\n          s = this.horiz,\n          o = this.width = Math.round(sH(sG(e.width, t.plotWidth - i[3] + i[1]), t.plotWidth)),\n          r = this.height = Math.round(sH(sG(e.height, t.plotHeight - i[0] + i[2]), t.plotHeight)),\n          n = this.top = Math.round(sH(sG(e.top, t.plotTop + i[0]), t.plotHeight, t.plotTop)),\n          a = this.left = Math.round(sH(sG(e.left, t.plotLeft + i[3]), t.plotWidth, t.plotLeft));\n        this.bottom = t.chartHeight - r - n, this.right = t.chartWidth - o - a, this.len = Math.max(s ? o : r, 0), this.pos = s ? a : n;\n      }\n      getExtremes() {\n        let t = this.logarithmic;\n        return {\n          min: t ? sS(t.lin2log(this.min)) : this.min,\n          max: t ? sS(t.lin2log(this.max)) : this.max,\n          dataMin: this.dataMin,\n          dataMax: this.dataMax,\n          userMin: this.userMin,\n          userMax: this.userMax\n        };\n      }\n      getThreshold(t) {\n        let e = this.logarithmic,\n          i = e ? e.lin2log(this.min) : this.min,\n          s = e ? e.lin2log(this.max) : this.max;\n        return null === t || t === -1 / 0 ? t = i : t === 1 / 0 ? t = s : i > t ? t = i : s < t && (t = s), this.translate(t, 0, 1, 0, 1);\n      }\n      autoLabelAlign(t) {\n        let e = (sG(t, 0) - 90 * this.side + 720) % 360,\n          i = {\n            align: \"center\"\n          };\n        return sE(this, \"autoLabelAlign\", i, function (t) {\n          e > 15 && e < 165 ? t.align = \"right\" : e > 195 && e < 345 && (t.align = \"left\");\n        }), i.align;\n      }\n      tickSize(t) {\n        let e = this.options,\n          i = sG(e[\"tick\" === t ? \"tickWidth\" : \"minorTickWidth\"], \"tick\" === t && this.isXAxis && !this.categories ? 1 : 0),\n          s = e[\"tick\" === t ? \"tickLength\" : \"minorTickLength\"],\n          o;\n        i && s && (\"inside\" === e[t + \"Position\"] && (s = -s), o = [s, i]);\n        let r = {\n          tickSize: o\n        };\n        return sE(this, \"afterTickSize\", r), r.tickSize;\n      }\n      labelMetrics() {\n        let t = this.chart.renderer,\n          e = this.ticks,\n          i = e[Object.keys(e)[0]] || {};\n        return this.chart.renderer.fontMetrics(i.label || i.movedLabel || t.box);\n      }\n      unsquish() {\n        let t = this.options.labels,\n          e = t.padding || 0,\n          i = this.horiz,\n          s = this.tickInterval,\n          o = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / s),\n          r = t.rotation,\n          n = sS(.8 * this.labelMetrics().h),\n          a = Math.max(this.max - this.min, 0),\n          h = function (t) {\n            let i = (t + 2 * e) / (o || 1);\n            return (i = i > 1 ? Math.ceil(i) : 1) * s > a && t !== 1 / 0 && o !== 1 / 0 && a && (i = Math.ceil(a / s)), sS(i * s);\n          },\n          l = s,\n          d,\n          c = Number.MAX_VALUE,\n          p;\n        if (i) {\n          if (!t.staggerLines && (sD(r) ? p = [r] : o < t.autoRotationLimit && (p = t.autoRotation)), p) {\n            let t, e;\n            for (let i of p) (i === r || i && i >= -90 && i <= 90) && (e = (t = h(Math.abs(n / Math.sin(sv * i)))) + Math.abs(i / 360)) < c && (c = e, d = i, l = t);\n          }\n        } else l = h(.75 * n);\n        return this.autoRotation = p, this.labelRotation = sG(d, sD(r) ? r : 0), t.step ? s : l;\n      }\n      getSlotWidth(t) {\n        let e = this.chart,\n          i = this.horiz,\n          s = this.options.labels,\n          o = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n          r = e.margin[3];\n        if (t && sD(t.slotWidth)) return t.slotWidth;\n        if (i && s.step < 2 && !this.isRadial) return s.rotation ? 0 : (this.staggerLines || 1) * this.len / o;\n        if (!i) {\n          let t = s.style.width;\n          if (void 0 !== t) return parseInt(String(t), 10);\n          if (r) return r - e.spacing[3];\n        }\n        return .33 * e.chartWidth;\n      }\n      renderUnsquish() {\n        let t = this.chart,\n          e = t.renderer,\n          i = this.tickPositions,\n          s = this.ticks,\n          o = this.options.labels,\n          r = o.style,\n          n = this.horiz,\n          a = this.getSlotWidth(),\n          h = Math.max(1, Math.round(a - (n ? 2 * (o.padding || 0) : o.distance || 0))),\n          l = {},\n          d = this.labelMetrics(),\n          c = r.lineClamp,\n          p,\n          u = c ?? (Math.floor(this.len / (i.length * d.h)) || 1),\n          g = 0;\n        sR(o.rotation) || (l.rotation = o.rotation || 0), i.forEach(function (t) {\n          let e = s[t];\n          e.movedLabel && e.replaceMovedLabel();\n          let i = e.label?.textPxLength || 0;\n          i > g && (g = i);\n        }), this.maxLabelLength = g, this.autoRotation ? g > h && g > d.h ? l.rotation = this.labelRotation : this.labelRotation = 0 : a && (p = h), l.rotation && (p = g > .5 * t.chartHeight ? .33 * t.chartHeight : g, c || (u = 1)), this.labelAlign = o.align || this.autoLabelAlign(this.labelRotation), this.labelAlign && (l.align = this.labelAlign), i.forEach(function (t) {\n          let e = s[t],\n            i = e && e.label,\n            o = r.width,\n            n = {};\n          i && (i.attr(l), e.shortenLabel ? e.shortenLabel() : p && !o && \"nowrap\" !== r.whiteSpace && (p < (i.textPxLength || 0) || \"SPAN\" === i.element.tagName) ? i.css(sO(n, {\n            width: `${p}px`,\n            lineClamp: u\n          })) : !i.styles.width || n.width || o || i.css({\n            width: \"auto\"\n          }), e.rotation = l.rotation);\n        }, this), this.tickRotCorr = e.rotCorr(d.b, this.labelRotation || 0, 0 !== this.side);\n      }\n      hasData() {\n        return this.series.some(function (t) {\n          return t.hasData();\n        }) || this.options.showEmpty && sA(this.min) && sA(this.max);\n      }\n      addTitle(t) {\n        let e;\n        let i = this.chart.renderer,\n          s = this.horiz,\n          o = this.opposite,\n          r = this.options.title,\n          n = this.chart.styledMode;\n        this.axisTitle || ((e = r.textAlign) || (e = (s ? {\n          low: \"left\",\n          middle: \"center\",\n          high: \"right\"\n        } : {\n          low: o ? \"right\" : \"left\",\n          middle: \"center\",\n          high: o ? \"left\" : \"right\"\n        })[r.align]), this.axisTitle = i.text(r.text || \"\", 0, 0, r.useHTML).attr({\n          zIndex: 7,\n          rotation: r.rotation || 0,\n          align: e\n        }).addClass(\"highcharts-axis-title\"), n || this.axisTitle.css(sN(r.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0), n || r.style.width || this.isRadial || this.axisTitle.css({\n          width: this.len + \"px\"\n        }), this.axisTitle[t ? \"show\" : \"hide\"](t);\n      }\n      generateTick(t) {\n        let e = this.ticks;\n        e[t] ? e[t].addLabel() : e[t] = new sg(this, t);\n      }\n      createGroups() {\n        let {\n            axisParent: t,\n            chart: e,\n            coll: i,\n            options: s\n          } = this,\n          o = e.renderer,\n          r = (e, r, n) => o.g(e).attr({\n            zIndex: n\n          }).addClass(`highcharts-${i.toLowerCase()}${r} ` + (this.isRadial ? `highcharts-radial-axis${r} ` : \"\") + (s.className || \"\")).add(t);\n        this.axisGroup || (this.gridGroup = r(\"grid\", \"-grid\", s.gridZIndex), this.axisGroup = r(\"axis\", \"\", s.zIndex), this.labelGroup = r(\"axis-labels\", \"-labels\", s.labels.zIndex));\n      }\n      getOffset() {\n        let t = this,\n          {\n            chart: e,\n            horiz: i,\n            options: s,\n            side: o,\n            ticks: r,\n            tickPositions: n,\n            coll: a\n          } = t,\n          h = e.inverted && !t.isZAxis ? [1, 0, 3, 2][o] : o,\n          l = t.hasData(),\n          d = s.title,\n          c = s.labels,\n          p = sD(s.crossing),\n          u = e.axisOffset,\n          g = e.clipOffset,\n          f = [-1, 1, 1, -1][o],\n          m,\n          x = 0,\n          y,\n          b = 0,\n          v = 0,\n          M,\n          k;\n        if (t.showAxis = m = l || s.showEmpty, t.staggerLines = t.horiz && c.staggerLines || void 0, t.createGroups(), l || t.isLinked ? (n.forEach(function (e) {\n          t.generateTick(e);\n        }), t.renderUnsquish(), t.reserveSpaceDefault = 0 === o || 2 === o || {\n          1: \"left\",\n          3: \"right\"\n        }[o] === t.labelAlign, sG(c.reserveSpace, !p && null, \"center\" === t.labelAlign || null, t.reserveSpaceDefault) && n.forEach(function (t) {\n          v = Math.max(r[t].getLabelSize(), v);\n        }), t.staggerLines && (v *= t.staggerLines), t.labelOffset = v * (t.opposite ? -1 : 1)) : sW(r, function (t, e) {\n          t.destroy(), delete r[e];\n        }), d?.text && !1 !== d.enabled && (t.addTitle(m), m && !p && !1 !== d.reserveSpace && (t.titleOffset = x = t.axisTitle.getBBox()[i ? \"height\" : \"width\"], b = sA(y = d.offset) ? 0 : sG(d.margin, i ? 5 : 10))), t.renderLine(), t.offset = f * sG(s.offset, u[o] ? u[o] + (s.margin || 0) : 0), t.tickRotCorr = t.tickRotCorr || {\n          x: 0,\n          y: 0\n        }, k = 0 === o ? -t.labelMetrics().h : 2 === o ? t.tickRotCorr.y : 0, M = Math.abs(v) + b, v && (M -= k, M += f * (i ? sG(c.y, t.tickRotCorr.y + f * c.distance) : sG(c.x, f * c.distance))), t.axisTitleMargin = sG(y, M), t.getMaxLabelDimensions && (t.maxLabelDimensions = t.getMaxLabelDimensions(r, n)), \"colorAxis\" !== a && g) {\n          let e = this.tickSize(\"tick\");\n          u[o] = Math.max(u[o], (t.axisTitleMargin || 0) + x + f * t.offset, M, n && n.length && e ? e[0] + f * t.offset : 0);\n          let i = !t.axisLine || s.offset ? 0 : t.axisLine.strokeWidth() / 2;\n          g[h] = Math.max(g[h], i);\n        }\n        sE(this, \"afterGetOffset\");\n      }\n      getLinePath(t) {\n        let e = this.chart,\n          i = this.opposite,\n          s = this.offset,\n          o = this.horiz,\n          r = this.left + (i ? this.width : 0) + s,\n          n = e.chartHeight - this.bottom - (i ? this.height : 0) + s;\n        return i && (t *= -1), e.renderer.crispLine([[\"M\", o ? this.left : r, o ? n : this.top], [\"L\", o ? e.chartWidth - this.right : r, o ? n : e.chartHeight - this.bottom]], t);\n      }\n      renderLine() {\n        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass(\"highcharts-axis-line\").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({\n          stroke: this.options.lineColor,\n          \"stroke-width\": this.options.lineWidth,\n          zIndex: 7\n        }));\n      }\n      getTitlePosition(t) {\n        let e = this.horiz,\n          i = this.left,\n          s = this.top,\n          o = this.len,\n          r = this.options.title,\n          n = e ? i : s,\n          a = this.opposite,\n          h = this.offset,\n          l = r.x,\n          d = r.y,\n          c = this.chart.renderer.fontMetrics(t),\n          p = t ? Math.max(t.getBBox(!1, 0).height - c.h - 1, 0) : 0,\n          u = {\n            low: n + (e ? 0 : o),\n            middle: n + o / 2,\n            high: n + (e ? o : 0)\n          }[r.align],\n          g = (e ? s + this.height : i) + (e ? 1 : -1) * (a ? -1 : 1) * (this.axisTitleMargin || 0) + [-p, p, c.f, -p][this.side],\n          f = {\n            x: e ? u + l : g + (a ? this.width : 0) + h + l,\n            y: e ? g + d - (a ? this.height : 0) + h : u + d\n          };\n        return sE(this, \"afterGetTitlePosition\", {\n          titlePosition: f\n        }), f;\n      }\n      renderMinorTick(t, e) {\n        let i = this.minorTicks;\n        i[t] || (i[t] = new sg(this, t, \"minor\")), e && i[t].isNew && i[t].render(null, !0), i[t].render(null, !1, 1);\n      }\n      renderTick(t, e, i) {\n        let s = this.isLinked,\n          o = this.ticks;\n        (!s || t >= this.min && t <= this.max || this.grid && this.grid.isColumn) && (o[t] || (o[t] = new sg(this, t)), i && o[t].isNew && o[t].render(e, !0, -1), o[t].render(e));\n      }\n      render() {\n        let t, e;\n        let i = this,\n          s = i.chart,\n          o = i.logarithmic,\n          r = s.renderer,\n          n = i.options,\n          a = i.isLinked,\n          h = i.tickPositions,\n          l = i.axisTitle,\n          d = i.ticks,\n          c = i.minorTicks,\n          p = i.alternateBands,\n          u = n.stackLabels,\n          g = n.alternateGridColor,\n          f = n.crossing,\n          m = i.tickmarkOffset,\n          x = i.axisLine,\n          y = i.showAxis,\n          b = sf(r.globalAnimation);\n        if (i.labelEdge.length = 0, i.overlap = !1, [d, c, p].forEach(function (t) {\n          sW(t, function (t) {\n            t.isActive = !1;\n          });\n        }), sD(f)) {\n          let t = this.isXAxis ? s.yAxis[0] : s.xAxis[0],\n            e = [1, -1, -1, 1][this.side];\n          if (t) {\n            let s = t.toPixels(f, !0);\n            i.horiz && (s = t.len - s), i.offset = e * s;\n          }\n        }\n        if (i.hasData() || a) {\n          let r = i.chart.hasRendered && i.old && sD(i.old.min);\n          i.minorTickInterval && !i.categories && i.getMinorTickPositions().forEach(function (t) {\n            i.renderMinorTick(t, r);\n          }), h.length && (h.forEach(function (t, e) {\n            i.renderTick(t, e, r);\n          }), m && (0 === i.min || i.single) && (d[-1] || (d[-1] = new sg(i, -1, null, !0)), d[-1].render(-1))), g && h.forEach(function (r, n) {\n            e = void 0 !== h[n + 1] ? h[n + 1] + m : i.max - m, n % 2 == 0 && r < i.max && e <= i.max + (s.polar ? -m : m) && (p[r] || (p[r] = new O.PlotLineOrBand(i, {})), t = r + m, p[r].options = {\n              from: o ? o.lin2log(t) : t,\n              to: o ? o.lin2log(e) : e,\n              color: g,\n              className: \"highcharts-alternate-grid\"\n            }, p[r].render(), p[r].isActive = !0);\n          }), i._addedPlotLB || (i._addedPlotLB = !0, (n.plotLines || []).concat(n.plotBands || []).forEach(function (t) {\n            i.addPlotBandOrLine(t);\n          }));\n        }\n        [d, c, p].forEach(function (t) {\n          let e = [],\n            i = b.duration;\n          sW(t, function (t, i) {\n            t.isActive || (t.render(i, !1, 0), t.isActive = !1, e.push(i));\n          }), sY(function () {\n            let i = e.length;\n            for (; i--;) t[e[i]] && !t[e[i]].isActive && (t[e[i]].destroy(), delete t[e[i]]);\n          }, t !== p && s.hasRendered && i ? i : 0);\n        }), x && (x[x.isPlaced ? \"animate\" : \"attr\"]({\n          d: this.getLinePath(x.strokeWidth())\n        }), x.isPlaced = !0, x[y ? \"show\" : \"hide\"](y)), l && y && (l[l.isNew ? \"attr\" : \"animate\"](i.getTitlePosition(l)), l.isNew = !1), u && u.enabled && i.stacking && i.stacking.renderStackTotals(), i.old = {\n          len: i.len,\n          max: i.max,\n          min: i.min,\n          transA: i.transA,\n          userMax: i.userMax,\n          userMin: i.userMin\n        }, i.isDirty = !1, sE(this, \"afterRender\");\n      }\n      redraw() {\n        this.visible && (this.render(), this.plotLinesAndBands.forEach(function (t) {\n          t.render();\n        })), this.series.forEach(function (t) {\n          t.isDirty = !0;\n        });\n      }\n      getKeepProps() {\n        return this.keepProps || sU.keepProps;\n      }\n      destroy(t) {\n        let e = this,\n          i = e.plotLinesAndBands,\n          s = this.eventOptions;\n        if (sE(this, \"destroy\", {\n          keepEvents: t\n        }), t || sF(e), [e.ticks, e.minorTicks, e.alternateBands].forEach(function (t) {\n          sT(t);\n        }), i) {\n          let t = i.length;\n          for (; t--;) i[t].destroy();\n        }\n        for (let t in [\"axisLine\", \"axisTitle\", \"axisGroup\", \"gridGroup\", \"labelGroup\", \"cross\", \"scrollbar\"].forEach(function (t) {\n          e[t] && (e[t] = e[t].destroy());\n        }), e.plotLinesAndBandsGroups) e.plotLinesAndBandsGroups[t] = e.plotLinesAndBandsGroups[t].destroy();\n        sW(e, function (t, i) {\n          -1 === e.getKeepProps().indexOf(i) && delete e[i];\n        }), this.eventOptions = s;\n      }\n      drawCrosshair(t, e) {\n        let i = this.crosshair,\n          s = sG(i && i.snap, !0),\n          o = this.chart,\n          r,\n          n,\n          a,\n          h = this.cross,\n          l;\n        if (sE(this, \"drawCrosshair\", {\n          e: t,\n          point: e\n        }), t || (t = this.cross && this.cross.e), i && !1 !== (sA(e) || !s)) {\n          if (s ? sA(e) && (n = sG(\"colorAxis\" !== this.coll ? e.crosshairPos : null, this.isXAxis ? e.plotX : this.len - e.plotY)) : n = t && (this.horiz ? t.chartX - this.pos : this.len - t.chartY + this.pos), sA(n) && (l = {\n            value: e && (this.isXAxis ? e.x : sG(e.stackY, e.y)),\n            translatedValue: n\n          }, o.polar && sO(l, {\n            isCrosshair: !0,\n            chartX: t && t.chartX,\n            chartY: t && t.chartY,\n            point: e\n          }), r = this.getPlotLinePath(l) || null), !sA(r)) {\n            this.hideCrosshair();\n            return;\n          }\n          a = this.categories && !this.isRadial, h || (this.cross = h = o.renderer.path().addClass(\"highcharts-crosshair highcharts-crosshair-\" + (a ? \"category \" : \"thin \") + (i.className || \"\")).attr({\n            zIndex: sG(i.zIndex, 2)\n          }).add(), !o.styledMode && (h.attr({\n            stroke: i.color || (a ? tO.parse(\"#ccd3ff\").setOpacity(.25).get() : \"#cccccc\"),\n            \"stroke-width\": sG(i.width, 1)\n          }).css({\n            \"pointer-events\": \"none\"\n          }), i.dashStyle && h.attr({\n            dashstyle: i.dashStyle\n          }))), h.show().attr({\n            d: r\n          }), a && !i.width && h.attr({\n            \"stroke-width\": this.transA\n          }), this.cross.e = t;\n        } else this.hideCrosshair();\n        sE(this, \"afterDrawCrosshair\", {\n          e: t,\n          point: e\n        });\n      }\n      hideCrosshair() {\n        this.cross && this.cross.hide(), sE(this, \"afterHideCrosshair\");\n      }\n      update(t, e) {\n        let i = this.chart;\n        t = sN(this.userOptions, t), this.destroy(!0), this.init(i, t), i.isDirtyBox = !0, sG(e, !0) && i.redraw();\n      }\n      remove(t) {\n        let e = this.chart,\n          i = this.coll,\n          s = this.series,\n          o = s.length;\n        for (; o--;) s[o] && s[o].remove(!1);\n        sP(e.axes, this), sP(e[i] || [], this), e.orderItems(i), this.destroy(), e.isDirtyBox = !0, sG(t, !0) && e.redraw();\n      }\n      setTitle(t, e) {\n        this.update({\n          title: t\n        }, e);\n      }\n      setCategories(t, e) {\n        this.update({\n          categories: t\n        }, e);\n      }\n    }\n    sU.keepProps = [\"coll\", \"extKey\", \"hcEvents\", \"len\", \"names\", \"series\", \"userMax\", \"userMin\"];\n    return sU;\n  })();\n  let {\n    addEvent: sV,\n    getMagnitude: s$,\n    normalizeTickInterval: s_,\n    timeUnits: sq\n  } = tt;\n  !function (t) {\n    function e() {\n      return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);\n    }\n    function i() {\n      if (\"datetime\" !== this.type) {\n        this.dateTime = void 0;\n        return;\n      }\n      this.dateTime || (this.dateTime = new s(this));\n    }\n    t.compose = function (t) {\n      return t.keepProps.includes(\"dateTime\") || (t.keepProps.push(\"dateTime\"), t.prototype.getTimeTicks = e, sV(t, \"afterSetType\", i)), t;\n    };\n    class s {\n      constructor(t) {\n        this.axis = t;\n      }\n      normalizeTimeTickInterval(t, e) {\n        let i = e || [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2]], [\"week\", [1, 2]], [\"month\", [1, 2, 3, 4, 6]], [\"year\", null]],\n          s = i[i.length - 1],\n          o = sq[s[0]],\n          r = s[1],\n          n;\n        for (n = 0; n < i.length && (o = sq[(s = i[n])[0]], r = s[1], !i[n + 1] || !(t <= (o * r[r.length - 1] + sq[i[n + 1][0]]) / 2)); n++);\n        o === sq.year && t < 5 * o && (r = [1, 2, 5]);\n        let a = s_(t / o, r, \"year\" === s[0] ? Math.max(s$(t / o), 1) : 1);\n        return {\n          unitRange: o,\n          count: a,\n          unitName: s[0]\n        };\n      }\n      getXDateFormat(t, e) {\n        let {\n            axis: i\n          } = this,\n          s = i.chart.time;\n        return i.closestPointRange ? s.getDateFormat(i.closestPointRange, t, i.options.startOfWeek, e) || s.resolveDTLFormat(e.year).main : s.resolveDTLFormat(e.day).main;\n      }\n    }\n    t.Additions = s;\n  }(d || (d = {}));\n  let sZ = d,\n    {\n      addEvent: sK,\n      normalizeTickInterval: sJ,\n      pick: sQ\n    } = tt;\n  !function (t) {\n    function e() {\n      \"logarithmic\" !== this.type ? this.logarithmic = void 0 : this.logarithmic ?? (this.logarithmic = new s(this));\n    }\n    function i() {\n      let t = this.logarithmic;\n      t && (this.lin2val = function (e) {\n        return t.lin2log(e);\n      }, this.val2lin = function (e) {\n        return t.log2lin(e);\n      });\n    }\n    t.compose = function (t) {\n      return t.keepProps.includes(\"logarithmic\") || (t.keepProps.push(\"logarithmic\"), sK(t, \"afterSetType\", e), sK(t, \"afterInit\", i)), t;\n    };\n    class s {\n      constructor(t) {\n        this.axis = t;\n      }\n      getLogTickPositions(t, e, i, s) {\n        let o = this.axis,\n          r = o.len,\n          n = o.options,\n          a = [];\n        if (s || (this.minorAutoInterval = void 0), t >= .5) t = Math.round(t), a = o.getLinearTickPositions(t, e, i);else if (t >= .08) {\n          let o, r, n, h, l, d, c;\n          let p = Math.floor(e);\n          for (o = t > .3 ? [1, 2, 4] : t > .15 ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9], r = p; r < i + 1 && !c; r++) for (n = 0, h = o.length; n < h && !c; n++) (l = this.log2lin(this.lin2log(r) * o[n])) > e && (!s || d <= i) && void 0 !== d && a.push(d), d > i && (c = !0), d = l;\n        } else {\n          let h = this.lin2log(e),\n            l = this.lin2log(i),\n            d = s ? o.getMinorTickInterval() : n.tickInterval,\n            c = n.tickPixelInterval / (s ? 5 : 1),\n            p = s ? r / o.tickPositions.length : r;\n          t = sJ(t = sQ(\"auto\" === d ? null : d, this.minorAutoInterval, (l - h) * c / (p || 1))), a = o.getLinearTickPositions(t, h, l).map(this.log2lin), s || (this.minorAutoInterval = t / 5);\n        }\n        return s || (o.tickInterval = t), a;\n      }\n      lin2log(t) {\n        return Math.pow(10, t);\n      }\n      log2lin(t) {\n        return Math.log(t) / Math.LN10;\n      }\n    }\n    t.Additions = s;\n  }(c || (c = {}));\n  let s0 = c,\n    {\n      erase: s1,\n      extend: s2,\n      isNumber: s3\n    } = tt;\n  !function (t) {\n    let e;\n    function i(t) {\n      return this.addPlotBandOrLine(t, \"plotBands\");\n    }\n    function s(t, i) {\n      let s = this.userOptions,\n        o = new e(this, t);\n      if (this.visible && (o = o.render()), o) {\n        if (this._addedPlotLB || (this._addedPlotLB = !0, (s.plotLines || []).concat(s.plotBands || []).forEach(t => {\n          this.addPlotBandOrLine(t);\n        })), i) {\n          let e = s[i] || [];\n          e.push(t), s[i] = e;\n        }\n        this.plotLinesAndBands.push(o);\n      }\n      return o;\n    }\n    function o(t) {\n      return this.addPlotBandOrLine(t, \"plotLines\");\n    }\n    function r(t, e, i) {\n      i = i || this.options;\n      let s = this.getPlotLinePath({\n          value: e,\n          force: !0,\n          acrossPanes: i.acrossPanes\n        }),\n        o = [],\n        r = this.horiz,\n        n = !s3(this.min) || !s3(this.max) || t < this.min && e < this.min || t > this.max && e > this.max,\n        a = this.getPlotLinePath({\n          value: t,\n          force: !0,\n          acrossPanes: i.acrossPanes\n        }),\n        h,\n        l = 1,\n        d;\n      if (a && s) for (n && (d = a.toString() === s.toString(), l = 0), h = 0; h < a.length; h += 2) {\n        let t = a[h],\n          e = a[h + 1],\n          i = s[h],\n          n = s[h + 1];\n        (\"M\" === t[0] || \"L\" === t[0]) && (\"M\" === e[0] || \"L\" === e[0]) && (\"M\" === i[0] || \"L\" === i[0]) && (\"M\" === n[0] || \"L\" === n[0]) && (r && i[1] === t[1] ? (i[1] += l, n[1] += l) : r || i[2] !== t[2] || (i[2] += l, n[2] += l), o.push([\"M\", t[1], t[2]], [\"L\", e[1], e[2]], [\"L\", n[1], n[2]], [\"L\", i[1], i[2]], [\"Z\"])), o.isFlat = d;\n      }\n      return o;\n    }\n    function n(t) {\n      this.removePlotBandOrLine(t);\n    }\n    function a(t) {\n      let e = this.plotLinesAndBands,\n        i = this.options,\n        s = this.userOptions;\n      if (e) {\n        let o = e.length;\n        for (; o--;) e[o].id === t && e[o].destroy();\n        [i.plotLines || [], s.plotLines || [], i.plotBands || [], s.plotBands || []].forEach(function (e) {\n          for (o = e.length; o--;) (e[o] || {}).id === t && s1(e, e[o]);\n        });\n      }\n    }\n    function h(t) {\n      this.removePlotBandOrLine(t);\n    }\n    t.compose = function (t, l) {\n      let d = l.prototype;\n      return d.addPlotBand || (e = t, s2(d, {\n        addPlotBand: i,\n        addPlotLine: o,\n        addPlotBandOrLine: s,\n        getPlotBandPath: r,\n        removePlotBand: n,\n        removePlotLine: h,\n        removePlotBandOrLine: a\n      })), l;\n    };\n  }(p || (p = {}));\n  let s5 = p,\n    {\n      addEvent: s6,\n      arrayMax: s9,\n      arrayMin: s4,\n      defined: s8,\n      destroyObjectProperties: s7,\n      erase: ot,\n      fireEvent: oe,\n      merge: oi,\n      objectEach: os,\n      pick: oo\n    } = tt;\n  class or {\n    static compose(t, e) {\n      return s6(t, \"afterInit\", function () {\n        this.labelCollectors.push(() => {\n          let t = [];\n          for (let e of this.axes) for (let {\n            label: i,\n            options: s\n          } of e.plotLinesAndBands) i && !s?.label?.allowOverlap && t.push(i);\n          return t;\n        });\n      }), s5.compose(or, e);\n    }\n    constructor(t, e) {\n      this.axis = t, this.options = e, this.id = e.id;\n    }\n    render() {\n      oe(this, \"render\");\n      let {\n          axis: t,\n          options: e\n        } = this,\n        {\n          horiz: i,\n          logarithmic: s\n        } = t,\n        {\n          color: o,\n          events: r,\n          zIndex: n = 0\n        } = e,\n        {\n          renderer: a,\n          time: h\n        } = t.chart,\n        l = {},\n        d = h.parse(e.to),\n        c = h.parse(e.from),\n        p = h.parse(e.value),\n        u = e.borderWidth,\n        g = e.label,\n        {\n          label: f,\n          svgElem: m\n        } = this,\n        x = [],\n        y,\n        b = s8(c) && s8(d),\n        v = s8(p),\n        M = !m,\n        k = {\n          class: \"highcharts-plot-\" + (b ? \"band \" : \"line \") + (e.className || \"\")\n        },\n        w = b ? \"bands\" : \"lines\";\n      if (!t.chart.styledMode && (v ? (k.stroke = o || \"#999999\", k[\"stroke-width\"] = oo(e.width, 1), e.dashStyle && (k.dashstyle = e.dashStyle)) : b && (k.fill = o || \"#e6e9ff\", u && (k.stroke = e.borderColor, k[\"stroke-width\"] = u))), l.zIndex = n, w += \"-\" + n, (y = t.plotLinesAndBandsGroups[w]) || (t.plotLinesAndBandsGroups[w] = y = a.g(\"plot-\" + w).attr(l).add()), m || (this.svgElem = m = a.path().attr(k).add(y)), s8(p)) x = t.getPlotLinePath({\n        value: s?.log2lin(p) ?? p,\n        lineWidth: m.strokeWidth(),\n        acrossPanes: e.acrossPanes\n      });else {\n        if (!(s8(c) && s8(d))) return;\n        x = t.getPlotBandPath(s?.log2lin(c) ?? c, s?.log2lin(d) ?? d, e);\n      }\n      return !this.eventsAdded && r && (os(r, (t, e) => {\n        m?.on(e, t => {\n          r[e].apply(this, [t]);\n        });\n      }), this.eventsAdded = !0), (M || !m.d) && x?.length ? m.attr({\n        d: x\n      }) : m && (x ? (m.show(), m.animate({\n        d: x\n      })) : m.d && (m.hide(), f && (this.label = f = f.destroy()))), g && (s8(g.text) || s8(g.formatter)) && x?.length && t.width > 0 && t.height > 0 && !x.isFlat ? (g = oi({\n        align: i && b ? \"center\" : void 0,\n        x: i ? !b && 4 : 10,\n        verticalAlign: !i && b ? \"middle\" : void 0,\n        y: i ? b ? 16 : 10 : b ? 6 : -4,\n        rotation: i && !b ? 90 : 0,\n        ...(b ? {\n          inside: !0\n        } : {})\n      }, g), this.renderLabel(g, x, b, n)) : f && f.hide(), this;\n    }\n    renderLabel(t, e, i, s) {\n      let o = this.axis,\n        r = o.chart.renderer,\n        n = t.inside,\n        a = this.label;\n      a || (this.label = a = r.text(this.getLabelText(t), 0, 0, t.useHTML).attr({\n        align: t.textAlign || t.align,\n        rotation: t.rotation,\n        class: \"highcharts-plot-\" + (i ? \"band\" : \"line\") + \"-label \" + (t.className || \"\"),\n        zIndex: s\n      }), o.chart.styledMode || a.css(oi({\n        fontSize: \"0.8em\",\n        textOverflow: i && !n ? \"\" : \"ellipsis\"\n      }, t.style)), a.add());\n      let h = e.xBounds || [e[0][1], e[1][1], i ? e[2][1] : e[0][1]],\n        l = e.yBounds || [e[0][2], e[1][2], i ? e[2][2] : e[0][2]],\n        d = s4(h),\n        c = s4(l),\n        p = s9(h) - d;\n      a.align(t, !1, {\n        x: d,\n        y: c,\n        width: p,\n        height: s9(l) - c\n      }), (!a.alignValue || \"left\" === a.alignValue || s8(n)) && a.css({\n        width: (t.style?.width || (i && n ? p : 90 === a.rotation ? o.height - (a.alignAttr.y - o.top) : (t.clip ? o.width : o.chart.chartWidth) - (a.alignAttr.x - o.left))) + \"px\"\n      }), a.show(!0);\n    }\n    getLabelText(t) {\n      return s8(t.formatter) ? t.formatter.call(this) : t.text;\n    }\n    destroy() {\n      ot(this.axis.plotLinesAndBands, this), delete this.axis, s7(this);\n    }\n  }\n  let {\n      animObject: on\n    } = tU,\n    {\n      format: oa\n    } = ep,\n    {\n      composed: oh,\n      dateFormats: ol,\n      doc: od,\n      isSafari: oc\n    } = O,\n    {\n      distribute: op\n    } = ey,\n    {\n      addEvent: ou,\n      clamp: og,\n      css: of,\n      discardElement: om,\n      extend: ox,\n      fireEvent: oy,\n      isArray: ob,\n      isNumber: ov,\n      isObject: oM,\n      isString: ok,\n      merge: ow,\n      pick: oS,\n      pushUnique: oA,\n      splat: oT,\n      syncTimeout: oP\n    } = tt;\n  class oC {\n    constructor(t, e, i) {\n      this.allowShared = !0, this.crosshairs = [], this.distance = 0, this.isHidden = !0, this.isSticky = !1, this.options = {}, this.outside = !1, this.chart = t, this.init(t, e), this.pointer = i;\n    }\n    bodyFormatter(t) {\n      return t.map(t => {\n        let e = t.series.tooltipOptions,\n          i = t.formatPrefix || \"point\";\n        return (e[i + \"Formatter\"] || t.tooltipFormatter).call(t, e[i + \"Format\"] || \"\");\n      });\n    }\n    cleanSplit(t) {\n      this.chart.series.forEach(function (e) {\n        let i = e && e.tt;\n        i && (!i.isActive || t ? e.tt = i.destroy() : i.isActive = !1);\n      });\n    }\n    defaultFormatter(t) {\n      let e;\n      let i = this.points || oT(this);\n      return (e = (e = [t.headerFooterFormatter(i[0])]).concat(t.bodyFormatter(i))).push(t.headerFooterFormatter(i[0], !0)), e;\n    }\n    destroy() {\n      this.label && (this.label = this.label.destroy()), this.split && (this.cleanSplit(!0), this.tt && (this.tt = this.tt.destroy())), this.renderer && (this.renderer = this.renderer.destroy(), om(this.container)), tt.clearTimeout(this.hideTimer);\n    }\n    getAnchor(t, e) {\n      let i;\n      let {\n          chart: s,\n          pointer: o\n        } = this,\n        r = s.inverted,\n        n = s.plotTop,\n        a = s.plotLeft;\n      if ((t = oT(t))[0].series && t[0].series.yAxis && !t[0].series.yAxis.options.reversedStacks && (t = t.slice().reverse()), this.followPointer && e) void 0 === e.chartX && (e = o.normalize(e)), i = [e.chartX - a, e.chartY - n];else if (t[0].tooltipPos) i = t[0].tooltipPos;else {\n        let s = 0,\n          o = 0;\n        t.forEach(function (t) {\n          let e = t.pos(!0);\n          e && (s += e[0], o += e[1]);\n        }), s /= t.length, o /= t.length, this.shared && t.length > 1 && e && (r ? s = e.chartX : o = e.chartY), i = [s - a, o - n];\n      }\n      return i.map(Math.round);\n    }\n    getClassName(t, e, i) {\n      let s = this.options,\n        o = t.series,\n        r = o.options;\n      return [s.className, \"highcharts-label\", i && \"highcharts-tooltip-header\", e ? \"highcharts-tooltip-box\" : \"highcharts-tooltip\", !i && \"highcharts-color-\" + oS(t.colorIndex, o.colorIndex), r && r.className].filter(ok).join(\" \");\n    }\n    getLabel({\n      anchorX: t,\n      anchorY: e\n    } = {\n      anchorX: 0,\n      anchorY: 0\n    }) {\n      let i = this,\n        s = this.chart.styledMode,\n        o = this.options,\n        r = this.split && this.allowShared,\n        n = this.container,\n        a = this.chart.renderer;\n      if (this.label) {\n        let t = !this.label.hasClass(\"highcharts-label\");\n        (!r && t || r && !t) && this.destroy();\n      }\n      if (!this.label) {\n        if (this.outside) {\n          let t = this.chart,\n            e = t.options.chart.style,\n            i = eu.getRendererType();\n          this.container = n = O.doc.createElement(\"div\"), n.className = \"highcharts-tooltip-container \" + (t.renderTo.className.match(/(highcharts[a-zA-Z0-9-]+)\\s?/gm) || \"\"), of(n, {\n            position: \"absolute\",\n            top: \"1px\",\n            pointerEvents: \"none\",\n            zIndex: Math.max(this.options.style.zIndex || 0, (e && e.zIndex || 0) + 3)\n          }), this.renderer = a = new i(n, 0, 0, e, void 0, void 0, a.styledMode);\n        }\n        if (r ? this.label = a.g(\"tooltip\") : (this.label = a.label(\"\", t, e, o.shape, void 0, void 0, o.useHTML, void 0, \"tooltip\").attr({\n          padding: o.padding,\n          r: o.borderRadius\n        }), s || this.label.attr({\n          fill: o.backgroundColor,\n          \"stroke-width\": o.borderWidth || 0\n        }).css(o.style).css({\n          pointerEvents: o.style.pointerEvents || (this.shouldStickOnContact() ? \"auto\" : \"none\")\n        })), i.outside) {\n          let t = this.label;\n          [t.xSetter, t.ySetter].forEach((e, s) => {\n            t[s ? \"ySetter\" : \"xSetter\"] = o => {\n              e.call(t, i.distance), t[s ? \"y\" : \"x\"] = o, n && (n.style[s ? \"top\" : \"left\"] = `${o}px`);\n            };\n          });\n        }\n        this.label.attr({\n          zIndex: 8\n        }).shadow(o.shadow).add();\n      }\n      return n && !n.parentElement && O.doc.body.appendChild(n), this.label;\n    }\n    getPlayingField() {\n      let {\n          body: t,\n          documentElement: e\n        } = od,\n        {\n          chart: i,\n          distance: s,\n          outside: o\n        } = this;\n      return {\n        width: o ? Math.max(t.scrollWidth, e.scrollWidth, t.offsetWidth, e.offsetWidth, e.clientWidth) - 2 * s - 2 : i.chartWidth,\n        height: o ? Math.max(t.scrollHeight, e.scrollHeight, t.offsetHeight, e.offsetHeight, e.clientHeight) : i.chartHeight\n      };\n    }\n    getPosition(t, e, i) {\n      let {\n          distance: s,\n          chart: o,\n          outside: r,\n          pointer: n\n        } = this,\n        {\n          inverted: a,\n          plotLeft: h,\n          plotTop: l,\n          polar: d\n        } = o,\n        {\n          plotX: c = 0,\n          plotY: p = 0\n        } = i,\n        u = {},\n        g = a && i.h || 0,\n        {\n          height: f,\n          width: m\n        } = this.getPlayingField(),\n        x = n.getChartPosition(),\n        y = t => t * x.scaleX,\n        b = t => t * x.scaleY,\n        v = i => {\n          let n = \"x\" === i;\n          return [i, n ? m : f, n ? t : e].concat(r ? [n ? y(t) : b(e), n ? x.left - s + y(c + h) : x.top - s + b(p + l), 0, n ? m : f] : [n ? t : e, n ? c + h : p + l, n ? h : l, n ? h + o.plotWidth : l + o.plotHeight]);\n        },\n        M = v(\"y\"),\n        k = v(\"x\"),\n        w,\n        S = !!i.negative;\n      !d && o.hoverSeries?.yAxis?.reversed && (S = !S);\n      let A = !this.followPointer && oS(i.ttBelow, !d && !a === S),\n        T = function (t, e, i, o, n, a, h) {\n          let l = r ? \"y\" === t ? b(s) : y(s) : s,\n            d = (i - o) / 2,\n            c = o < n - s,\n            p = n + s + o < e,\n            f = n - l - i + d,\n            m = n + l - d;\n          if (A && p) u[t] = m;else if (!A && c) u[t] = f;else if (c) u[t] = Math.min(h - o, f - g < 0 ? f : f - g);else {\n            if (!p) return !1;\n            u[t] = Math.max(a, m + g + i > e ? m : m + g);\n          }\n        },\n        P = function (t, e, i, o, r) {\n          if (r < s || r > e - s) return !1;\n          r < i / 2 ? u[t] = 1 : r > e - o / 2 ? u[t] = e - o - 2 : u[t] = r - i / 2;\n        },\n        C = function (t) {\n          [M, k] = [k, M], w = t;\n        },\n        O = () => {\n          !1 !== T.apply(0, M) ? !1 !== P.apply(0, k) || w || (C(!0), O()) : w ? u.x = u.y = 0 : (C(!0), O());\n        };\n      return (a && !d || this.len > 1) && C(), O(), u;\n    }\n    hide(t) {\n      let e = this;\n      tt.clearTimeout(this.hideTimer), t = oS(t, this.options.hideDelay), this.isHidden || (this.hideTimer = oP(function () {\n        let i = e.getLabel();\n        e.getLabel().animate({\n          opacity: 0\n        }, {\n          duration: t ? 150 : t,\n          complete: () => {\n            i.hide(), e.container && e.container.remove();\n          }\n        }), e.isHidden = !0;\n      }, t));\n    }\n    init(t, e) {\n      this.chart = t, this.options = e, this.crosshairs = [], this.isHidden = !0, this.split = e.split && !t.inverted && !t.polar, this.shared = e.shared || this.split, this.outside = oS(e.outside, !!(t.scrollablePixelsX || t.scrollablePixelsY));\n    }\n    shouldStickOnContact(t) {\n      return !!(!this.followPointer && this.options.stickOnContact && (!t || this.pointer.inClass(t.target, \"highcharts-tooltip\")));\n    }\n    move(t, e, i, s) {\n      let o = this,\n        r = on(!o.isHidden && o.options.animation),\n        n = o.followPointer || (o.len || 0) > 1,\n        a = {\n          x: t,\n          y: e\n        };\n      n || (a.anchorX = i, a.anchorY = s), r.step = () => o.drawTracker(), o.getLabel().animate(a, r);\n    }\n    refresh(t, e) {\n      let {\n          chart: i,\n          options: s,\n          pointer: o,\n          shared: r\n        } = this,\n        n = oT(t),\n        a = n[0],\n        h = s.format,\n        l = s.formatter || this.defaultFormatter,\n        d = i.styledMode,\n        c = this.allowShared;\n      if (!s.enabled || !a.series) return;\n      tt.clearTimeout(this.hideTimer), this.allowShared = !(!ob(t) && t.series && t.series.noSharedTooltip), c = c && !this.allowShared, this.followPointer = !this.split && a.series.tooltipOptions.followPointer;\n      let p = this.getAnchor(t, e),\n        u = p[0],\n        g = p[1];\n      r && this.allowShared && (o.applyInactiveState(n), n.forEach(t => t.setState(\"hover\")), a.points = n), this.len = n.length;\n      let f = ok(h) ? oa(h, a, i) : l.call(a, this);\n      a.points = void 0;\n      let m = a.series;\n      if (this.distance = oS(m.tooltipOptions.distance, 16), !1 === f) this.hide();else {\n        if (this.split && this.allowShared) this.renderSplit(f, n);else {\n          let t = u,\n            r = g;\n          if (e && o.isDirectTouch && (t = e.chartX - i.plotLeft, r = e.chartY - i.plotTop), i.polar || !1 === m.options.clip || n.some(e => o.isDirectTouch || e.series.shouldShowTooltip(t, r))) {\n            let t = this.getLabel(c && this.tt || {});\n            (!s.style.width || d) && t.css({\n              width: (this.outside ? this.getPlayingField() : i.spacingBox).width + \"px\"\n            }), t.attr({\n              class: this.getClassName(a),\n              text: f && f.join ? f.join(\"\") : f\n            }), this.outside && t.attr({\n              x: og(t.x || 0, 0, this.getPlayingField().width - (t.width || 0) - 1)\n            }), d || t.attr({\n              stroke: s.borderColor || a.color || m.color || \"#666666\"\n            }), this.updatePosition({\n              plotX: u,\n              plotY: g,\n              negative: a.negative,\n              ttBelow: a.ttBelow,\n              h: p[2] || 0\n            });\n          } else {\n            this.hide();\n            return;\n          }\n        }\n        this.isHidden && this.label && this.label.attr({\n          opacity: 1\n        }).show(), this.isHidden = !1;\n      }\n      oy(this, \"refresh\");\n    }\n    renderSplit(t, e) {\n      let i = this,\n        {\n          chart: s,\n          chart: {\n            chartWidth: o,\n            chartHeight: r,\n            plotHeight: n,\n            plotLeft: a,\n            plotTop: h,\n            scrollablePixelsY: l = 0,\n            scrollablePixelsX: d,\n            styledMode: c\n          },\n          distance: p,\n          options: u,\n          options: {\n            positioner: g\n          },\n          pointer: f\n        } = i,\n        {\n          scrollLeft: m = 0,\n          scrollTop: x = 0\n        } = s.scrollablePlotArea?.scrollingContainer || {},\n        y = i.outside && \"number\" != typeof d ? od.documentElement.getBoundingClientRect() : {\n          left: m,\n          right: m + o,\n          top: x,\n          bottom: x + r\n        },\n        b = i.getLabel(),\n        v = this.renderer || s.renderer,\n        M = !!(s.xAxis[0] && s.xAxis[0].opposite),\n        {\n          left: k,\n          top: w\n        } = f.getChartPosition(),\n        S = h + x,\n        A = 0,\n        T = n - l;\n      function P(t, e, s, o, r = !0) {\n        let n, a;\n        return s ? (n = M ? 0 : T, a = og(t - o / 2, y.left, y.right - o - (i.outside ? k : 0))) : (n = e - S, a = og(a = r ? t - o - p : t + p, r ? a : y.left, y.right)), {\n          x: a,\n          y: n\n        };\n      }\n      ok(t) && (t = [!1, t]);\n      let C = t.slice(0, e.length + 1).reduce(function (t, s, o) {\n        if (!1 !== s && \"\" !== s) {\n          let r = e[o - 1] || {\n              isHeader: !0,\n              plotX: e[0].plotX,\n              plotY: n,\n              series: {}\n            },\n            l = r.isHeader,\n            d = l ? i : r.series,\n            f = d.tt = function (t, e, s) {\n              let o = t,\n                {\n                  isHeader: r,\n                  series: n\n                } = e;\n              if (!o) {\n                let t = {\n                  padding: u.padding,\n                  r: u.borderRadius\n                };\n                c || (t.fill = u.backgroundColor, t[\"stroke-width\"] = u.borderWidth ?? 1), o = v.label(\"\", 0, 0, u[r ? \"headerShape\" : \"shape\"], void 0, void 0, u.useHTML).addClass(i.getClassName(e, !0, r)).attr(t).add(b);\n              }\n              return o.isActive = !0, o.attr({\n                text: s\n              }), c || o.css(u.style).attr({\n                stroke: u.borderColor || e.color || n.color || \"#333333\"\n              }), o;\n            }(d.tt, r, s.toString()),\n            m = f.getBBox(),\n            x = m.width + f.strokeWidth();\n          l && (A = m.height, T += A, M && (S -= A));\n          let {\n            anchorX: k,\n            anchorY: w\n          } = function (t) {\n            let e, i;\n            let {\n              isHeader: s,\n              plotX: o = 0,\n              plotY: r = 0,\n              series: l\n            } = t;\n            if (s) e = Math.max(a + o, a), i = h + n / 2;else {\n              let {\n                xAxis: t,\n                yAxis: s\n              } = l;\n              e = t.pos + og(o, -p, t.len + p), l.shouldShowTooltip(0, s.pos - h + r, {\n                ignoreX: !0\n              }) && (i = s.pos + r);\n            }\n            return {\n              anchorX: e = og(e, y.left - p, y.right + p),\n              anchorY: i\n            };\n          }(r);\n          if (\"number\" == typeof w) {\n            let e = m.height + 1,\n              s = g ? g.call(i, x, e, r) : P(k, w, l, x);\n            t.push({\n              align: g ? 0 : void 0,\n              anchorX: k,\n              anchorY: w,\n              boxWidth: x,\n              point: r,\n              rank: oS(s.rank, l ? 1 : 0),\n              size: e,\n              target: s.y,\n              tt: f,\n              x: s.x\n            });\n          } else f.isActive = !1;\n        }\n        return t;\n      }, []);\n      !g && C.some(t => {\n        let {\n            outside: e\n          } = i,\n          s = (e ? k : 0) + t.anchorX;\n        return s < y.left && s + t.boxWidth < y.right || s < k - y.left + t.boxWidth && y.right - s > s;\n      }) && (C = C.map(t => {\n        let {\n          x: e,\n          y: i\n        } = P(t.anchorX, t.anchorY, t.point.isHeader, t.boxWidth, !1);\n        return ox(t, {\n          target: i,\n          x: e\n        });\n      })), i.cleanSplit(), op(C, T);\n      let O = {\n        left: k,\n        right: k\n      };\n      C.forEach(function (t) {\n        let {\n          x: e,\n          boxWidth: s,\n          isHeader: o\n        } = t;\n        !o && (i.outside && k + e < O.left && (O.left = k + e), !o && i.outside && O.left + s > O.right && (O.right = k + e));\n      }), C.forEach(function (t) {\n        let {\n            x: e,\n            anchorX: s,\n            anchorY: o,\n            pos: r,\n            point: {\n              isHeader: n\n            }\n          } = t,\n          a = {\n            visibility: void 0 === r ? \"hidden\" : \"inherit\",\n            x: e,\n            y: (r || 0) + S,\n            anchorX: s,\n            anchorY: o\n          };\n        if (i.outside && e < s) {\n          let t = k - O.left;\n          t > 0 && (n || (a.x = e + t, a.anchorX = s + t), n && (a.x = (O.right - O.left) / 2, a.anchorX = s + t));\n        }\n        t.tt.attr(a);\n      });\n      let {\n        container: E,\n        outside: L,\n        renderer: B\n      } = i;\n      if (L && E && B) {\n        let {\n          width: t,\n          height: e,\n          x: i,\n          y: s\n        } = b.getBBox();\n        B.setSize(t + i, e + s, !1), E.style.left = O.left + \"px\", E.style.top = w + \"px\";\n      }\n      oc && b.attr({\n        opacity: 1 === b.opacity ? .999 : 1\n      });\n    }\n    drawTracker() {\n      if (!this.shouldStickOnContact()) {\n        this.tracker && (this.tracker = this.tracker.destroy());\n        return;\n      }\n      let t = this.chart,\n        e = this.label,\n        i = this.shared ? t.hoverPoints : t.hoverPoint;\n      if (!e || !i) return;\n      let s = {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        },\n        o = this.getAnchor(i),\n        r = e.getBBox();\n      o[0] += t.plotLeft - (e.translateX || 0), o[1] += t.plotTop - (e.translateY || 0), s.x = Math.min(0, o[0]), s.y = Math.min(0, o[1]), s.width = o[0] < 0 ? Math.max(Math.abs(o[0]), r.width - o[0]) : Math.max(Math.abs(o[0]), r.width), s.height = o[1] < 0 ? Math.max(Math.abs(o[1]), r.height - Math.abs(o[1])) : Math.max(Math.abs(o[1]), r.height), this.tracker ? this.tracker.attr(s) : (this.tracker = e.renderer.rect(s).addClass(\"highcharts-tracker\").add(e), t.styledMode || this.tracker.attr({\n        fill: \"rgba(0,0,0,0)\"\n      }));\n    }\n    styledModeFormat(t) {\n      return t.replace('style=\"font-size: 0.8em\"', 'class=\"highcharts-header\"').replace(/style=\"color:{(point|series)\\.color}\"/g, 'class=\"highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}\"');\n    }\n    headerFooterFormatter(t, e) {\n      let i = t.series,\n        s = i.tooltipOptions,\n        o = i.xAxis,\n        r = o && o.dateTime,\n        n = {\n          isFooter: e,\n          point: t\n        },\n        a = s.xDateFormat || \"\",\n        h = s[e ? \"footerFormat\" : \"headerFormat\"];\n      return oy(this, \"headerFormatter\", n, function (e) {\n        if (r && !a && ov(t.key) && (a = r.getXDateFormat(t.key, s.dateTimeLabelFormats)), r && a) {\n          if (oM(a)) {\n            let t = a;\n            ol[0] = e => i.chart.time.dateFormat(t, e), a = \"%0\";\n          }\n          (t.tooltipDateKeys || [\"key\"]).forEach(t => {\n            h = h.replace(RegExp(\"point\\\\.\" + t + \"([ \\\\)}])\", \"\"), `(point.${t}:${a})$1`);\n          });\n        }\n        i.chart.styledMode && (h = this.styledModeFormat(h)), e.text = oa(h, t, this.chart);\n      }), n.text || \"\";\n    }\n    update(t) {\n      this.destroy(), this.init(this.chart, ow(!0, this.options, t));\n    }\n    updatePosition(t) {\n      let {\n          chart: e,\n          container: i,\n          distance: s,\n          options: o,\n          pointer: r,\n          renderer: n\n        } = this,\n        {\n          height: a = 0,\n          width: h = 0\n        } = this.getLabel(),\n        {\n          left: l,\n          top: d,\n          scaleX: c,\n          scaleY: p\n        } = r.getChartPosition(),\n        u = (o.positioner || this.getPosition).call(this, h, a, t),\n        g = O.doc,\n        f = (t.plotX || 0) + e.plotLeft,\n        m = (t.plotY || 0) + e.plotTop,\n        x;\n      n && i && (o.positioner && (u.x += l - s, u.y += d - s), x = (o.borderWidth || 0) + 2 * s + 2, n.setSize(og(h + x, 0, g.documentElement.clientWidth) - 1, a + x, !1), (1 !== c || 1 !== p) && (of(i, {\n        transform: `scale(${c}, ${p})`\n      }), f *= c, m *= p), f += l - u.x, m += d - u.y), this.move(Math.round(u.x), Math.round(u.y || 0), f, m);\n    }\n  }\n  !function (t) {\n    t.compose = function (e) {\n      oA(oh, \"Core.Tooltip\") && ou(e, \"afterInit\", function () {\n        let e = this.chart;\n        e.options.tooltip && (e.tooltip = new t(e, e.options.tooltip, this));\n      });\n    };\n  }(oC || (oC = {}));\n  let oO = oC,\n    {\n      animObject: oE\n    } = tU,\n    {\n      defaultOptions: oL\n    } = tS,\n    {\n      format: oB\n    } = ep,\n    {\n      addEvent: oI,\n      crisp: oD,\n      erase: oR,\n      extend: oN,\n      fireEvent: oz,\n      getNestedProperty: oW,\n      isArray: oG,\n      isFunction: oH,\n      isNumber: oF,\n      isObject: oX,\n      merge: oY,\n      pick: oj,\n      syncTimeout: oU,\n      removeEvent: oV,\n      uniqueKey: o$\n    } = tt;\n  class o_ {\n    animateBeforeDestroy() {\n      let t = this,\n        e = {\n          x: t.startXPos,\n          opacity: 0\n        },\n        i = t.getGraphicalProps();\n      i.singular.forEach(function (i) {\n        t[i] = t[i].animate(\"dataLabel\" === i ? {\n          x: t[i].startXPos,\n          y: t[i].startYPos,\n          opacity: 0\n        } : e);\n      }), i.plural.forEach(function (e) {\n        t[e].forEach(function (e) {\n          e.element && e.animate(oN({\n            x: t.startXPos\n          }, e.startYPos ? {\n            x: e.startXPos,\n            y: e.startYPos\n          } : {}));\n        });\n      });\n    }\n    applyOptions(t, e) {\n      let i = this.series,\n        s = i.options.pointValKey || i.pointValKey;\n      return oN(this, t = o_.prototype.optionsToObject.call(this, t)), this.options = this.options ? oN(this.options, t) : t, t.group && delete this.group, t.dataLabels && delete this.dataLabels, s && (this.y = o_.prototype.getNestedProperty.call(this, s)), this.selected && (this.state = \"select\"), \"name\" in this && void 0 === e && i.xAxis && i.xAxis.hasNames && (this.x = i.xAxis.nameToX(this)), void 0 === this.x && i ? this.x = e ?? i.autoIncrement() : oF(t.x) && i.options.relativeXValue ? this.x = i.autoIncrement(t.x) : \"string\" == typeof this.x && (e ?? (e = i.chart.time.parse(this.x)), oF(e) && (this.x = e)), this.isNull = this.isValid && !this.isValid(), this.formatPrefix = this.isNull ? \"null\" : \"point\", this;\n    }\n    destroy() {\n      if (!this.destroyed) {\n        let t = this,\n          e = t.series,\n          i = e.chart,\n          s = e.options.dataSorting,\n          o = i.hoverPoints,\n          r = oE(t.series.chart.renderer.globalAnimation),\n          n = () => {\n            for (let e in (t.graphic || t.graphics || t.dataLabel || t.dataLabels) && (oV(t), t.destroyElements()), t) delete t[e];\n          };\n        t.legendItem && i.legend.destroyItem(t), o && (t.setState(), oR(o, t), o.length || (i.hoverPoints = null)), t === i.hoverPoint && t.onMouseOut(), s && s.enabled ? (this.animateBeforeDestroy(), oU(n, r.duration)) : n(), i.pointCount--;\n      }\n      this.destroyed = !0;\n    }\n    destroyElements(t) {\n      let e = this,\n        i = e.getGraphicalProps(t);\n      i.singular.forEach(function (t) {\n        e[t] = e[t].destroy();\n      }), i.plural.forEach(function (t) {\n        e[t].forEach(function (t) {\n          t && t.element && t.destroy();\n        }), delete e[t];\n      });\n    }\n    firePointEvent(t, e, i) {\n      let s = this,\n        o = this.series.options;\n      s.manageEvent(t), \"click\" === t && o.allowPointSelect && (i = function (t) {\n        !s.destroyed && s.select && s.select(null, t.ctrlKey || t.metaKey || t.shiftKey);\n      }), oz(s, t, e, i);\n    }\n    getClassName() {\n      return \"highcharts-point\" + (this.selected ? \" highcharts-point-select\" : \"\") + (this.negative ? \" highcharts-negative\" : \"\") + (this.isNull ? \" highcharts-null-point\" : \"\") + (void 0 !== this.colorIndex ? \" highcharts-color-\" + this.colorIndex : \"\") + (this.options.className ? \" \" + this.options.className : \"\") + (this.zone && this.zone.className ? \" \" + this.zone.className.replace(\"highcharts-negative\", \"\") : \"\");\n    }\n    getGraphicalProps(t) {\n      let e, i;\n      let s = this,\n        o = [],\n        r = {\n          singular: [],\n          plural: []\n        };\n      for ((t = t || {\n        graphic: 1,\n        dataLabel: 1\n      }).graphic && o.push(\"graphic\", \"connector\"), t.dataLabel && o.push(\"dataLabel\", \"dataLabelPath\", \"dataLabelUpper\"), i = o.length; i--;) s[e = o[i]] && r.singular.push(e);\n      return [\"graphic\", \"dataLabel\"].forEach(function (e) {\n        let i = e + \"s\";\n        t[e] && s[i] && r.plural.push(i);\n      }), r;\n    }\n    getNestedProperty(t) {\n      return t ? 0 === t.indexOf(\"custom.\") ? oW(t, this.options) : this[t] : void 0;\n    }\n    getZone() {\n      let t = this.series,\n        e = t.zones,\n        i = t.zoneAxis || \"y\",\n        s,\n        o = 0;\n      for (s = e[0]; this[i] >= s.value;) s = e[++o];\n      return this.nonZonedColor || (this.nonZonedColor = this.color), s && s.color && !this.options.color ? this.color = s.color : this.color = this.nonZonedColor, s;\n    }\n    hasNewShapeType() {\n      return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;\n    }\n    constructor(t, e, i) {\n      this.formatPrefix = \"point\", this.visible = !0, this.point = this, this.series = t, this.applyOptions(e, i), this.id ?? (this.id = o$()), this.resolveColor(), t.chart.pointCount++, oz(this, \"afterInit\");\n    }\n    isValid() {\n      return (oF(this.x) || this.x instanceof Date) && oF(this.y);\n    }\n    optionsToObject(t) {\n      let e = this.series,\n        i = e.options.keys,\n        s = i || e.pointArrayMap || [\"y\"],\n        o = s.length,\n        r = {},\n        n,\n        a = 0,\n        h = 0;\n      if (oF(t) || null === t) r[s[0]] = t;else if (oG(t)) for (!i && t.length > o && (\"string\" == (n = typeof t[0]) ? e.xAxis?.dateTime ? r.x = e.chart.time.parse(t[0]) : r.name = t[0] : \"number\" === n && (r.x = t[0]), a++); h < o;) i && void 0 === t[a] || (s[h].indexOf(\".\") > 0 ? o_.prototype.setNestedProperty(r, t[a], s[h]) : r[s[h]] = t[a]), a++, h++;else \"object\" == typeof t && (r = t, t.dataLabels && (e.hasDataLabels = () => !0), t.marker && (e._hasPointMarkers = !0));\n      return r;\n    }\n    pos(t, e = this.plotY) {\n      if (!this.destroyed) {\n        let {\n            plotX: i,\n            series: s\n          } = this,\n          {\n            chart: o,\n            xAxis: r,\n            yAxis: n\n          } = s,\n          a = 0,\n          h = 0;\n        if (oF(i) && oF(e)) return t && (a = r ? r.pos : o.plotLeft, h = n ? n.pos : o.plotTop), o.inverted && r && n ? [n.len - e + h, r.len - i + a] : [i + a, e + h];\n      }\n    }\n    resolveColor() {\n      let t = this.series,\n        e = t.chart.options.chart,\n        i = t.chart.styledMode,\n        s,\n        o,\n        r = e.colorCount,\n        n;\n      delete this.nonZonedColor, t.options.colorByPoint ? (i || (s = (o = t.options.colors || t.chart.options.colors)[t.colorCounter], r = o.length), n = t.colorCounter, t.colorCounter++, t.colorCounter === r && (t.colorCounter = 0)) : (i || (s = t.color), n = t.colorIndex), this.colorIndex = oj(this.options.colorIndex, n), this.color = oj(this.options.color, s);\n    }\n    setNestedProperty(t, e, i) {\n      return i.split(\".\").reduce(function (t, i, s, o) {\n        let r = o.length - 1 === s;\n        return t[i] = r ? e : oX(t[i], !0) ? t[i] : {}, t[i];\n      }, t), t;\n    }\n    shouldDraw() {\n      return !this.isNull;\n    }\n    tooltipFormatter(t) {\n      let {\n          chart: e,\n          pointArrayMap: i = [\"y\"],\n          tooltipOptions: s\n        } = this.series,\n        {\n          valueDecimals: o = \"\",\n          valuePrefix: r = \"\",\n          valueSuffix: n = \"\"\n        } = s;\n      return e.styledMode && (t = e.tooltip?.styledModeFormat(t) || t), i.forEach(e => {\n        e = \"{point.\" + e, (r || n) && (t = t.replace(RegExp(e + \"}\", \"g\"), r + e + \"}\" + n)), t = t.replace(RegExp(e + \"}\", \"g\"), e + \":,.\" + o + \"f}\");\n      }), oB(t, this, e);\n    }\n    update(t, e, i, s) {\n      let o;\n      let r = this,\n        n = r.series,\n        a = r.graphic,\n        h = n.chart,\n        l = n.options;\n      function d() {\n        r.applyOptions(t);\n        let s = a && r.hasMockGraphic,\n          d = null === r.y ? !s : s;\n        a && d && (r.graphic = a.destroy(), delete r.hasMockGraphic), oX(t, !0) && (a && a.element && t && t.marker && void 0 !== t.marker.symbol && (r.graphic = a.destroy()), t?.dataLabels && r.dataLabel && (r.dataLabel = r.dataLabel.destroy())), o = r.index;\n        let c = {};\n        for (let t of n.dataColumnKeys()) c[t] = r[t];\n        n.dataTable.setRow(c, o), l.data[o] = oX(l.data[o], !0) || oX(t, !0) ? r.options : oj(t, l.data[o]), n.isDirty = n.isDirtyData = !0, !n.fixedBox && n.hasCartesianSeries && (h.isDirtyBox = !0), \"point\" === l.legendType && (h.isDirtyLegend = !0), e && h.redraw(i);\n      }\n      e = oj(e, !0), !1 === s ? d() : r.firePointEvent(\"update\", {\n        options: t\n      }, d);\n    }\n    remove(t, e) {\n      this.series.removePoint(this.series.data.indexOf(this), t, e);\n    }\n    select(t, e) {\n      let i = this,\n        s = i.series,\n        o = s.chart;\n      t = oj(t, !i.selected), this.selectedStaging = t, i.firePointEvent(t ? \"select\" : \"unselect\", {\n        accumulate: e\n      }, function () {\n        i.selected = i.options.selected = t, s.options.data[s.data.indexOf(i)] = i.options, i.setState(t && \"select\"), e || o.getSelectedPoints().forEach(function (t) {\n          let e = t.series;\n          t.selected && t !== i && (t.selected = t.options.selected = !1, e.options.data[e.data.indexOf(t)] = t.options, t.setState(o.hoverPoints && e.options.inactiveOtherPoints ? \"inactive\" : \"\"), t.firePointEvent(\"unselect\"));\n        });\n      }), delete this.selectedStaging;\n    }\n    onMouseOver(t) {\n      let {\n        inverted: e,\n        pointer: i\n      } = this.series.chart;\n      i && (t = t ? i.normalize(t) : i.getChartCoordinatesFromPoint(this, e), i.runPointActions(t, this));\n    }\n    onMouseOut() {\n      let t = this.series.chart;\n      this.firePointEvent(\"mouseOut\"), this.series.options.inactiveOtherPoints || (t.hoverPoints || []).forEach(function (t) {\n        t.setState();\n      }), t.hoverPoints = t.hoverPoint = null;\n    }\n    manageEvent(t) {\n      let e = oY(this.series.options.point, this.options),\n        i = e.events?.[t];\n      oH(i) && (!this.hcEvents?.[t] || this.hcEvents?.[t]?.map(t => t.fn).indexOf(i) === -1) ? (this.importedUserEvent?.(), this.importedUserEvent = oI(this, t, i), this.hcEvents && (this.hcEvents[t].userEvent = !0)) : this.importedUserEvent && !i && this.hcEvents?.[t] && this.hcEvents?.[t].userEvent && (oV(this, t), delete this.hcEvents[t], Object.keys(this.hcEvents) || delete this.importedUserEvent);\n    }\n    setState(t, e) {\n      let i = this.series,\n        s = this.state,\n        o = i.options.states[t || \"normal\"] || {},\n        r = oL.plotOptions[i.type].marker && i.options.marker,\n        n = r && !1 === r.enabled,\n        a = r && r.states && r.states[t || \"normal\"] || {},\n        h = !1 === a.enabled,\n        l = this.marker || {},\n        d = i.chart,\n        c = r && i.markerAttribs,\n        p = i.halo,\n        u,\n        g,\n        f,\n        m = i.stateMarkerGraphic,\n        x;\n      if ((t = t || \"\") === this.state && !e || this.selected && \"select\" !== t || !1 === o.enabled || t && (h || n && !1 === a.enabled) || t && l.states && l.states[t] && !1 === l.states[t].enabled) return;\n      if (this.state = t, c && (u = i.markerAttribs(this, t)), this.graphic && !this.hasMockGraphic) {\n        if (s && this.graphic.removeClass(\"highcharts-point-\" + s), t && this.graphic.addClass(\"highcharts-point-\" + t), !d.styledMode) {\n          g = i.pointAttribs(this, t), f = oj(d.options.chart.animation, o.animation);\n          let e = g.opacity;\n          i.options.inactiveOtherPoints && oF(e) && (this.dataLabels || []).forEach(function (t) {\n            t && !t.hasClass(\"highcharts-data-label-hidden\") && (t.animate({\n              opacity: e\n            }, f), t.connector && t.connector.animate({\n              opacity: e\n            }, f));\n          }), this.graphic.animate(g, f);\n        }\n        u && this.graphic.animate(u, oj(d.options.chart.animation, a.animation, r.animation)), m && m.hide();\n      } else t && a && (x = l.symbol || i.symbol, m && m.currentSymbol !== x && (m = m.destroy()), u && (m ? m[e ? \"animate\" : \"attr\"]({\n        x: u.x,\n        y: u.y\n      }) : x && (i.stateMarkerGraphic = m = d.renderer.symbol(x, u.x, u.y, u.width, u.height, oY(r, a)).add(i.markerGroup), m.currentSymbol = x)), !d.styledMode && m && \"inactive\" !== this.state && m.attr(i.pointAttribs(this, t))), m && (m[t && this.isInside ? \"show\" : \"hide\"](), m.element.point = this, m.addClass(this.getClassName(), !0));\n      let y = o.halo,\n        b = this.graphic || m,\n        v = b && b.visibility || \"inherit\";\n      y && y.size && b && \"hidden\" !== v && !this.isCluster ? (p || (i.halo = p = d.renderer.path().add(b.parentGroup)), p.show()[e ? \"animate\" : \"attr\"]({\n        d: this.haloPath(y.size)\n      }), p.attr({\n        class: \"highcharts-halo highcharts-color-\" + oj(this.colorIndex, i.colorIndex) + (this.className ? \" \" + this.className : \"\"),\n        visibility: v,\n        zIndex: -1\n      }), p.point = this, d.styledMode || p.attr(oN({\n        fill: this.color || i.color,\n        \"fill-opacity\": y.opacity\n      }, t6.filterUserAttributes(y.attributes || {})))) : p?.point?.haloPath && !p.point.destroyed && p.animate({\n        d: p.point.haloPath(0)\n      }, null, p.hide), oz(this, \"afterSetState\", {\n        state: t\n      });\n    }\n    haloPath(t) {\n      let e = this.pos();\n      return e ? this.series.chart.renderer.symbols.circle(oD(e[0], 1) - t, e[1] - t, 2 * t, 2 * t) : [];\n    }\n  }\n  let oq = o_,\n    {\n      parse: oZ\n    } = tO,\n    {\n      charts: oK,\n      composed: oJ,\n      isTouchDevice: oQ\n    } = O,\n    {\n      addEvent: o0,\n      attr: o1,\n      css: o2,\n      extend: o3,\n      find: o5,\n      fireEvent: o6,\n      isNumber: o9,\n      isObject: o4,\n      objectEach: o8,\n      offset: o7,\n      pick: rt,\n      pushUnique: re,\n      splat: ri\n    } = tt;\n  class rs {\n    applyInactiveState(t) {\n      let e = [],\n        i;\n      (t || []).forEach(function (t) {\n        i = t.series, e.push(i), i.linkedParent && e.push(i.linkedParent), i.linkedSeries && (e = e.concat(i.linkedSeries)), i.navigatorSeries && e.push(i.navigatorSeries);\n      }), this.chart.series.forEach(function (t) {\n        -1 === e.indexOf(t) ? t.setState(\"inactive\", !0) : t.options.inactiveOtherPoints && t.setAllPointsToState(\"inactive\");\n      });\n    }\n    destroy() {\n      let t = this;\n      this.eventsToUnbind.forEach(t => t()), this.eventsToUnbind = [], !O.chartCount && (rs.unbindDocumentMouseUp.forEach(t => t.unbind()), rs.unbindDocumentMouseUp.length = 0, rs.unbindDocumentTouchEnd && (rs.unbindDocumentTouchEnd = rs.unbindDocumentTouchEnd())), clearInterval(t.tooltipTimeout), o8(t, function (e, i) {\n        t[i] = void 0;\n      });\n    }\n    getSelectionMarkerAttrs(t, e) {\n      let i = {\n        args: {\n          chartX: t,\n          chartY: e\n        },\n        attrs: {},\n        shapeType: \"rect\"\n      };\n      return o6(this, \"getSelectionMarkerAttrs\", i, i => {\n        let s;\n        let {\n            chart: o,\n            zoomHor: r,\n            zoomVert: n\n          } = this,\n          {\n            mouseDownX: a = 0,\n            mouseDownY: h = 0\n          } = o,\n          l = i.attrs;\n        l.x = o.plotLeft, l.y = o.plotTop, l.width = r ? 1 : o.plotWidth, l.height = n ? 1 : o.plotHeight, r && (s = t - a, l.width = Math.max(1, Math.abs(s)), l.x = (s > 0 ? 0 : s) + a), n && (s = e - h, l.height = Math.max(1, Math.abs(s)), l.y = (s > 0 ? 0 : s) + h);\n      }), i;\n    }\n    drag(t) {\n      let {\n          chart: e\n        } = this,\n        {\n          mouseDownX: i = 0,\n          mouseDownY: s = 0\n        } = e,\n        {\n          panning: o,\n          panKey: r,\n          selectionMarkerFill: n\n        } = e.options.chart,\n        a = e.plotLeft,\n        h = e.plotTop,\n        l = e.plotWidth,\n        d = e.plotHeight,\n        c = o4(o) ? o.enabled : o,\n        p = r && t[`${r}Key`],\n        u = t.chartX,\n        g = t.chartY,\n        f,\n        m = this.selectionMarker;\n      if ((!m || !m.touch) && (u < a ? u = a : u > a + l && (u = a + l), g < h ? g = h : g > h + d && (g = h + d), this.hasDragged = Math.sqrt(Math.pow(i - u, 2) + Math.pow(s - g, 2)), this.hasDragged > 10)) {\n        f = e.isInsidePlot(i - a, s - h, {\n          visiblePlotOnly: !0\n        });\n        let {\n          shapeType: r,\n          attrs: l\n        } = this.getSelectionMarkerAttrs(u, g);\n        (e.hasCartesianSeries || e.mapView) && this.hasZoom && f && !p && !m && (this.selectionMarker = m = e.renderer[r](), m.attr({\n          class: \"highcharts-selection-marker\",\n          zIndex: 7\n        }).add(), e.styledMode || m.attr({\n          fill: n || oZ(\"#334eff\").setOpacity(.25).get()\n        })), m && m.attr(l), f && !m && c && e.pan(t, o);\n      }\n    }\n    dragStart(t) {\n      let e = this.chart;\n      e.mouseIsDown = t.type, e.cancelClick = !1, e.mouseDownX = t.chartX, e.mouseDownY = t.chartY;\n    }\n    getSelectionBox(t) {\n      let e = {\n        args: {\n          marker: t\n        },\n        result: t.getBBox()\n      };\n      return o6(this, \"getSelectionBox\", e), e.result;\n    }\n    drop(t) {\n      let e;\n      let {\n        chart: i,\n        selectionMarker: s\n      } = this;\n      for (let t of i.axes) t.isPanning && (t.isPanning = !1, (t.options.startOnTick || t.options.endOnTick || t.series.some(t => t.boosted)) && (t.forceRedraw = !0, t.setExtremes(t.userMin, t.userMax, !1), e = !0));\n      if (e && i.redraw(), s && t) {\n        if (this.hasDragged) {\n          let e = this.getSelectionBox(s);\n          i.transform({\n            axes: i.axes.filter(t => t.zoomEnabled && (\"xAxis\" === t.coll && this.zoomX || \"yAxis\" === t.coll && this.zoomY)),\n            selection: {\n              originalEvent: t,\n              xAxis: [],\n              yAxis: [],\n              ...e\n            },\n            from: e\n          });\n        }\n        o9(i.index) && (this.selectionMarker = s.destroy());\n      }\n      i && o9(i.index) && (o2(i.container, {\n        cursor: i._cursor\n      }), i.cancelClick = this.hasDragged > 10, i.mouseIsDown = !1, this.hasDragged = 0, this.pinchDown = []);\n    }\n    findNearestKDPoint(t, e, i) {\n      let s;\n      return t.forEach(function (t) {\n        let o = !(t.noSharedTooltip && e) && 0 > t.options.findNearestPointBy.indexOf(\"y\"),\n          r = t.searchPoint(i, o);\n        o4(r, !0) && r.series && (!o4(s, !0) || function (t, i) {\n          let s = t.distX - i.distX,\n            o = t.dist - i.dist,\n            r = i.series.group?.zIndex - t.series.group?.zIndex;\n          return 0 !== s && e ? s : 0 !== o ? o : 0 !== r ? r : t.series.index > i.series.index ? -1 : 1;\n        }(s, r) > 0) && (s = r);\n      }), s;\n    }\n    getChartCoordinatesFromPoint(t, e) {\n      let {\n          xAxis: i,\n          yAxis: s\n        } = t.series,\n        o = t.shapeArgs;\n      if (i && s) {\n        let r = t.clientX ?? t.plotX ?? 0,\n          n = t.plotY || 0;\n        return t.isNode && o && o9(o.x) && o9(o.y) && (r = o.x, n = o.y), e ? {\n          chartX: s.len + s.pos - n,\n          chartY: i.len + i.pos - r\n        } : {\n          chartX: r + i.pos,\n          chartY: n + s.pos\n        };\n      }\n      if (o && o.x && o.y) return {\n        chartX: o.x,\n        chartY: o.y\n      };\n    }\n    getChartPosition() {\n      if (this.chartPosition) return this.chartPosition;\n      let {\n          container: t\n        } = this.chart,\n        e = o7(t);\n      this.chartPosition = {\n        left: e.left,\n        top: e.top,\n        scaleX: 1,\n        scaleY: 1\n      };\n      let {\n        offsetHeight: i,\n        offsetWidth: s\n      } = t;\n      return s > 2 && i > 2 && (this.chartPosition.scaleX = e.width / s, this.chartPosition.scaleY = e.height / i), this.chartPosition;\n    }\n    getCoordinates(t) {\n      let e = {\n        xAxis: [],\n        yAxis: []\n      };\n      for (let i of this.chart.axes) e[i.isXAxis ? \"xAxis\" : \"yAxis\"].push({\n        axis: i,\n        value: i.toValue(t[i.horiz ? \"chartX\" : \"chartY\"])\n      });\n      return e;\n    }\n    getHoverData(t, e, i, s, o, r) {\n      let n = [],\n        a = function (t) {\n          return t.visible && !(!o && t.directTouch) && rt(t.options.enableMouseTracking, !0);\n        },\n        h = e,\n        l,\n        d = {\n          chartX: r ? r.chartX : void 0,\n          chartY: r ? r.chartY : void 0,\n          shared: o\n        };\n      o6(this, \"beforeGetHoverData\", d), l = h && !h.stickyTracking ? [h] : i.filter(t => t.stickyTracking && (d.filter || a)(t));\n      let c = s && t || !r ? t : this.findNearestKDPoint(l, o, r);\n      return h = c && c.series, c && (o && !h.noSharedTooltip ? (l = i.filter(function (t) {\n        return d.filter ? d.filter(t) : a(t) && !t.noSharedTooltip;\n      })).forEach(function (t) {\n        let e = o5(t.points, function (t) {\n          return t.x === c.x && !t.isNull;\n        });\n        o4(e) && (t.boosted && t.boost && (e = t.boost.getPoint(e)), n.push(e));\n      }) : n.push(c)), o6(this, \"afterGetHoverData\", d = {\n        hoverPoint: c\n      }), {\n        hoverPoint: d.hoverPoint,\n        hoverSeries: h,\n        hoverPoints: n\n      };\n    }\n    getPointFromEvent(t) {\n      let e = t.target,\n        i;\n      for (; e && !i;) i = e.point, e = e.parentNode;\n      return i;\n    }\n    onTrackerMouseOut(t) {\n      let e = this.chart,\n        i = t.relatedTarget,\n        s = e.hoverSeries;\n      this.isDirectTouch = !1, !s || !i || s.stickyTracking || this.inClass(i, \"highcharts-tooltip\") || this.inClass(i, \"highcharts-series-\" + s.index) && this.inClass(i, \"highcharts-tracker\") || s.onMouseOut();\n    }\n    inClass(t, e) {\n      let i = t,\n        s;\n      for (; i;) {\n        if (s = o1(i, \"class\")) {\n          if (-1 !== s.indexOf(e)) return !0;\n          if (-1 !== s.indexOf(\"highcharts-container\")) return !1;\n        }\n        i = i.parentElement;\n      }\n    }\n    constructor(t, e) {\n      this.hasDragged = 0, this.pointerCaptureEventsToUnbind = [], this.eventsToUnbind = [], this.options = e, this.chart = t, this.runChartClick = !!e.chart.events?.click, this.pinchDown = [], this.setDOMEvents(), o6(this, \"afterInit\");\n    }\n    normalize(t, e) {\n      let i = t.touches,\n        s = i ? i.length ? i.item(0) : rt(i.changedTouches, t.changedTouches)[0] : t;\n      e || (e = this.getChartPosition());\n      let o = s.pageX - e.left,\n        r = s.pageY - e.top;\n      return o3(t, {\n        chartX: Math.round(o /= e.scaleX),\n        chartY: Math.round(r /= e.scaleY)\n      });\n    }\n    onContainerClick(t) {\n      let e = this.chart,\n        i = e.hoverPoint,\n        s = this.normalize(t),\n        o = e.plotLeft,\n        r = e.plotTop;\n      !e.cancelClick && (i && this.inClass(s.target, \"highcharts-tracker\") ? (o6(i.series, \"click\", o3(s, {\n        point: i\n      })), e.hoverPoint && i.firePointEvent(\"click\", s)) : (o3(s, this.getCoordinates(s)), e.isInsidePlot(s.chartX - o, s.chartY - r, {\n        visiblePlotOnly: !0\n      }) && o6(e, \"click\", s)));\n    }\n    onContainerMouseDown(t) {\n      let e = (1 & (t.buttons || t.button)) == 1;\n      t = this.normalize(t), O.isFirefox && 0 !== t.button && this.onContainerMouseMove(t), (void 0 === t.button || e) && (this.zoomOption(t), e && t.preventDefault?.(), this.dragStart(t));\n    }\n    onContainerMouseLeave(t) {\n      let {\n        pointer: e\n      } = oK[rt(rs.hoverChartIndex, -1)] || {};\n      t = this.normalize(t), this.onContainerMouseMove(t), e && !this.inClass(t.relatedTarget, \"highcharts-tooltip\") && (e.reset(), e.chartPosition = void 0);\n    }\n    onContainerMouseEnter() {\n      delete this.chartPosition;\n    }\n    onContainerMouseMove(t) {\n      let e = this.chart,\n        i = e.tooltip,\n        s = this.normalize(t);\n      this.setHoverChartIndex(t), (\"mousedown\" === e.mouseIsDown || this.touchSelect(s)) && this.drag(s), !e.openMenu && (this.inClass(s.target, \"highcharts-tracker\") || e.isInsidePlot(s.chartX - e.plotLeft, s.chartY - e.plotTop, {\n        visiblePlotOnly: !0\n      })) && !(i && i.shouldStickOnContact(s)) && (this.inClass(s.target, \"highcharts-no-tooltip\") ? this.reset(!1, 0) : this.runPointActions(s));\n    }\n    onDocumentTouchEnd(t) {\n      this.onDocumentMouseUp(t);\n    }\n    onContainerTouchMove(t) {\n      this.touchSelect(t) ? this.onContainerMouseMove(t) : this.touch(t);\n    }\n    onContainerTouchStart(t) {\n      this.touchSelect(t) ? this.onContainerMouseDown(t) : (this.zoomOption(t), this.touch(t, !0));\n    }\n    onDocumentMouseMove(t) {\n      let e = this.chart,\n        i = e.tooltip,\n        s = this.chartPosition,\n        o = this.normalize(t, s);\n      !s || e.isInsidePlot(o.chartX - e.plotLeft, o.chartY - e.plotTop, {\n        visiblePlotOnly: !0\n      }) || i && i.shouldStickOnContact(o) || o.target !== e.container.ownerDocument && this.inClass(o.target, \"highcharts-tracker\") || this.reset();\n    }\n    onDocumentMouseUp(t) {\n      oK[rt(rs.hoverChartIndex, -1)]?.pointer?.drop(t);\n    }\n    pinch(t) {\n      let e = this,\n        {\n          chart: i,\n          hasZoom: s,\n          lastTouches: o\n        } = e,\n        r = [].map.call(t.touches || [], t => e.normalize(t)),\n        n = r.length,\n        a = 1 === n && (e.inClass(t.target, \"highcharts-tracker\") && i.runTrackerClick || e.runChartClick),\n        h = i.tooltip,\n        l = 1 === n && rt(h?.options.followTouchMove, !0);\n      n > 1 ? e.initiated = !0 : l && (e.initiated = !1), s && e.initiated && !a && !1 !== t.cancelable && t.preventDefault(), \"touchstart\" === t.type ? (e.pinchDown = r, e.res = !0, i.mouseDownX = t.chartX) : l ? this.runPointActions(e.normalize(t)) : o && (o6(i, \"touchpan\", {\n        originalEvent: t,\n        touches: r\n      }, () => {\n        let e = t => {\n          let e = t[0],\n            i = t[1] || e;\n          return {\n            x: e.chartX,\n            y: e.chartY,\n            width: i.chartX - e.chartX,\n            height: i.chartY - e.chartY\n          };\n        };\n        i.transform({\n          axes: i.axes.filter(t => t.zoomEnabled && (this.zoomHor && t.horiz || this.zoomVert && !t.horiz)),\n          to: e(r),\n          from: e(o),\n          trigger: t.type\n        });\n      }), e.res && (e.res = !1, this.reset(!1, 0))), e.lastTouches = r;\n    }\n    reset(t, e) {\n      let i = this.chart,\n        s = i.hoverSeries,\n        o = i.hoverPoint,\n        r = i.hoverPoints,\n        n = i.tooltip,\n        a = n && n.shared ? r : o;\n      t && a && ri(a).forEach(function (e) {\n        e.series.isCartesian && void 0 === e.plotX && (t = !1);\n      }), t ? n && a && ri(a).length && (n.refresh(a), n.shared && r ? r.forEach(function (t) {\n        t.setState(t.state, !0), t.series.isCartesian && (t.series.xAxis.crosshair && t.series.xAxis.drawCrosshair(null, t), t.series.yAxis.crosshair && t.series.yAxis.drawCrosshair(null, t));\n      }) : o && (o.setState(o.state, !0), i.axes.forEach(function (t) {\n        t.crosshair && o.series[t.coll] === t && t.drawCrosshair(null, o);\n      }))) : (o && o.onMouseOut(), r && r.forEach(function (t) {\n        t.setState();\n      }), s && s.onMouseOut(), n && n.hide(e), this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove()), i.axes.forEach(function (t) {\n        t.hideCrosshair();\n      }), i.hoverPoints = i.hoverPoint = void 0);\n    }\n    runPointActions(t, e, i) {\n      let s = this.chart,\n        o = s.series,\n        r = s.tooltip && s.tooltip.options.enabled ? s.tooltip : void 0,\n        n = !!r && r.shared,\n        a = e || s.hoverPoint,\n        h = a && a.series || s.hoverSeries,\n        l = (!t || \"touchmove\" !== t.type) && (!!e || h && h.directTouch && this.isDirectTouch),\n        d = this.getHoverData(a, h, o, l, n, t);\n      a = d.hoverPoint, h = d.hoverSeries;\n      let c = d.hoverPoints,\n        p = h && h.tooltipOptions.followPointer && !h.tooltipOptions.split,\n        u = n && h && !h.noSharedTooltip;\n      if (a && (i || a !== s.hoverPoint || r && r.isHidden)) {\n        if ((s.hoverPoints || []).forEach(function (t) {\n          -1 === c.indexOf(t) && t.setState();\n        }), s.hoverSeries !== h && h.onMouseOver(), this.applyInactiveState(c), (c || []).forEach(function (t) {\n          t.setState(\"hover\");\n        }), s.hoverPoint && s.hoverPoint.firePointEvent(\"mouseOut\"), !a.series) return;\n        s.hoverPoints = c, s.hoverPoint = a, a.firePointEvent(\"mouseOver\", void 0, () => {\n          r && a && r.refresh(u ? c : a, t);\n        });\n      } else if (p && r && !r.isHidden) {\n        let e = r.getAnchor([{}], t);\n        s.isInsidePlot(e[0], e[1], {\n          visiblePlotOnly: !0\n        }) && r.updatePosition({\n          plotX: e[0],\n          plotY: e[1]\n        });\n      }\n      this.unDocMouseMove || (this.unDocMouseMove = o0(s.container.ownerDocument, \"mousemove\", t => oK[rs.hoverChartIndex ?? -1]?.pointer?.onDocumentMouseMove(t)), this.eventsToUnbind.push(this.unDocMouseMove)), s.axes.forEach(function (e) {\n        let i;\n        let o = rt((e.crosshair || {}).snap, !0);\n        !o || (i = s.hoverPoint) && i.series[e.coll] === e || (i = o5(c, t => t.series && t.series[e.coll] === e)), i || !o ? e.drawCrosshair(t, i) : e.hideCrosshair();\n      });\n    }\n    setDOMEvents() {\n      let t = this.chart.container,\n        e = t.ownerDocument;\n      t.onmousedown = this.onContainerMouseDown.bind(this), t.onmousemove = this.onContainerMouseMove.bind(this), t.onclick = this.onContainerClick.bind(this), this.eventsToUnbind.push(o0(t, \"mouseenter\", this.onContainerMouseEnter.bind(this)), o0(t, \"mouseleave\", this.onContainerMouseLeave.bind(this))), rs.unbindDocumentMouseUp.some(t => t.doc === e) || rs.unbindDocumentMouseUp.push({\n        doc: e,\n        unbind: o0(e, \"mouseup\", this.onDocumentMouseUp.bind(this))\n      });\n      let i = this.chart.renderTo.parentElement;\n      for (; i && \"BODY\" !== i.tagName;) this.eventsToUnbind.push(o0(i, \"scroll\", () => {\n        delete this.chartPosition;\n      })), i = i.parentElement;\n      this.eventsToUnbind.push(o0(t, \"touchstart\", this.onContainerTouchStart.bind(this), {\n        passive: !1\n      }), o0(t, \"touchmove\", this.onContainerTouchMove.bind(this), {\n        passive: !1\n      })), rs.unbindDocumentTouchEnd || (rs.unbindDocumentTouchEnd = o0(e, \"touchend\", this.onDocumentTouchEnd.bind(this), {\n        passive: !1\n      })), this.setPointerCapture(), o0(this.chart, \"redraw\", this.setPointerCapture.bind(this));\n    }\n    setPointerCapture() {\n      if (!oQ) return;\n      let t = this.pointerCaptureEventsToUnbind,\n        e = this.chart,\n        i = e.container,\n        s = rt(e.options.tooltip?.followTouchMove, !0) && e.series.some(t => t.options.findNearestPointBy.indexOf(\"y\") > -1);\n      !this.hasPointerCapture && s ? (t.push(o0(i, \"pointerdown\", t => {\n        t.target?.hasPointerCapture(t.pointerId) && t.target?.releasePointerCapture(t.pointerId);\n      }), o0(i, \"pointermove\", t => {\n        e.pointer?.getPointFromEvent(t)?.onMouseOver(t);\n      })), e.styledMode || o2(i, {\n        \"touch-action\": \"none\"\n      }), i.className += \" highcharts-no-touch-action\", this.hasPointerCapture = !0) : this.hasPointerCapture && !s && (t.forEach(t => t()), t.length = 0, e.styledMode || o2(i, {\n        \"touch-action\": rt(e.options.chart.style?.[\"touch-action\"], \"manipulation\")\n      }), i.className = i.className.replace(\" highcharts-no-touch-action\", \"\"), this.hasPointerCapture = !1);\n    }\n    setHoverChartIndex(t) {\n      let e = this.chart,\n        i = O.charts[rt(rs.hoverChartIndex, -1)];\n      if (i && i !== e) {\n        let s = {\n          relatedTarget: e.container\n        };\n        t && !t?.relatedTarget && Object.assign({}, t, s), i.pointer?.onContainerMouseLeave(t || s);\n      }\n      i && i.mouseIsDown || (rs.hoverChartIndex = e.index);\n    }\n    touch(t, e) {\n      let i;\n      let {\n        chart: s,\n        pinchDown: o = []\n      } = this;\n      this.setHoverChartIndex(), 1 === (t = this.normalize(t)).touches.length ? s.isInsidePlot(t.chartX - s.plotLeft, t.chartY - s.plotTop, {\n        visiblePlotOnly: !0\n      }) && !s.openMenu ? (e && this.runPointActions(t), \"touchmove\" === t.type && (i = !!o[0] && Math.pow(o[0].chartX - t.chartX, 2) + Math.pow(o[0].chartY - t.chartY, 2) >= 16), rt(i, !0) && this.pinch(t)) : e && this.reset() : 2 === t.touches.length && this.pinch(t);\n    }\n    touchSelect(t) {\n      return !!(this.chart.zooming.singleTouch && t.touches && 1 === t.touches.length);\n    }\n    zoomOption(t) {\n      let e = this.chart,\n        i = e.inverted,\n        s = e.zooming.type || \"\",\n        o,\n        r;\n      /touch/.test(t.type) && (s = rt(e.zooming.pinchType, s)), this.zoomX = o = /x/.test(s), this.zoomY = r = /y/.test(s), this.zoomHor = o && !i || r && i, this.zoomVert = r && !i || o && i, this.hasZoom = o || r;\n    }\n  }\n  rs.unbindDocumentMouseUp = [], function (t) {\n    t.compose = function (e) {\n      re(oJ, \"Core.Pointer\") && o0(e, \"beforeRender\", function () {\n        this.pointer = new t(this, this.options);\n      });\n    };\n  }(rs || (rs = {}));\n  let ro = rs,\n    {\n      fireEvent: rr,\n      isArray: rn,\n      objectEach: ra,\n      uniqueKey: rh\n    } = tt,\n    rl = class {\n      constructor(t = {}) {\n        this.autoId = !t.id, this.columns = {}, this.id = t.id || rh(), this.modified = this, this.rowCount = 0, this.versionTag = rh();\n        let e = 0;\n        ra(t.columns || {}, (t, i) => {\n          this.columns[i] = t.slice(), e = Math.max(e, t.length);\n        }), this.applyRowCount(e);\n      }\n      applyRowCount(t) {\n        this.rowCount = t, ra(this.columns, e => {\n          rn(e) && (e.length = t);\n        });\n      }\n      getColumn(t, e) {\n        return this.columns[t];\n      }\n      getColumns(t, e) {\n        return (t || Object.keys(this.columns)).reduce((t, e) => (t[e] = this.columns[e], t), {});\n      }\n      getRow(t, e) {\n        return (e || Object.keys(this.columns)).map(e => this.columns[e]?.[t]);\n      }\n      setColumn(t, e = [], i = 0, s) {\n        this.setColumns({\n          [t]: e\n        }, i, s);\n      }\n      setColumns(t, e, i) {\n        let s = this.rowCount;\n        ra(t, (t, e) => {\n          this.columns[e] = t.slice(), s = t.length;\n        }), this.applyRowCount(s), i?.silent || (rr(this, \"afterSetColumns\"), this.versionTag = rh());\n      }\n      setRow(t, e = this.rowCount, i, s) {\n        let {\n            columns: o\n          } = this,\n          r = i ? this.rowCount + 1 : e + 1;\n        ra(t, (t, n) => {\n          let a = o[n] || s?.addColumns !== !1 && Array(r);\n          a && (i ? a.splice(e, 0, t) : a[e] = t, o[n] = a);\n        }), r > this.rowCount && this.applyRowCount(r), s?.silent || (rr(this, \"afterSetRows\"), this.versionTag = rh());\n      }\n    },\n    {\n      extend: rd,\n      merge: rc,\n      pick: rp\n    } = tt;\n  !function (t) {\n    function e(t, e, i) {\n      let s = this.legendItem = this.legendItem || {},\n        {\n          chart: o,\n          options: r\n        } = this,\n        {\n          baseline: n = 0,\n          symbolWidth: a,\n          symbolHeight: h\n        } = t,\n        l = this.symbol || \"circle\",\n        d = h / 2,\n        c = o.renderer,\n        p = s.group,\n        u = n - Math.round((t.fontMetrics?.b || h) * (i ? .4 : .3)),\n        g = {},\n        f,\n        m = r.marker,\n        x = 0;\n      if (o.styledMode || (g[\"stroke-width\"] = Math.min(r.lineWidth || 0, 24), r.dashStyle ? g.dashstyle = r.dashStyle : \"square\" === r.linecap || (g[\"stroke-linecap\"] = \"round\")), s.line = c.path().addClass(\"highcharts-graph\").attr(g).add(p), i && (s.area = c.path().addClass(\"highcharts-area\").add(p)), g[\"stroke-linecap\"] && (x = Math.min(s.line.strokeWidth(), a) / 2), a) {\n        let t = [[\"M\", x, u], [\"L\", a - x, u]];\n        s.line.attr({\n          d: t\n        }), s.area?.attr({\n          d: [...t, [\"L\", a - x, n], [\"L\", x, n]]\n        });\n      }\n      if (m && !1 !== m.enabled && a) {\n        let t = Math.min(rp(m.radius, d), d);\n        0 === l.indexOf(\"url\") && (m = rc(m, {\n          width: h,\n          height: h\n        }), t = 0), s.symbol = f = c.symbol(l, a / 2 - t, u - t, 2 * t, 2 * t, rd({\n          context: \"legend\"\n        }, m)).addClass(\"highcharts-point\").add(p), f.isMarker = !0;\n      }\n    }\n    t.areaMarker = function (t, i) {\n      e.call(this, t, i, !0);\n    }, t.lineMarker = e, t.rectangle = function (t, e) {\n      let i = e.legendItem || {},\n        s = t.options,\n        o = t.symbolHeight,\n        r = s.squareSymbol,\n        n = r ? o : t.symbolWidth;\n      i.symbol = this.chart.renderer.rect(r ? (t.symbolWidth - o) / 2 : 0, t.baseline - o + 1, n, o, rp(t.options.symbolRadius, o / 2)).addClass(\"highcharts-point\").attr({\n        zIndex: 3\n      }).add(i.group);\n    };\n  }(u || (u = {}));\n  let ru = u,\n    {\n      defaultOptions: rg\n    } = tS,\n    {\n      extend: rf,\n      extendClass: rm,\n      merge: rx\n    } = tt;\n  !function (t) {\n    function e(e, i) {\n      let s = rg.plotOptions || {},\n        o = i.defaultOptions,\n        r = i.prototype;\n      return r.type = e, r.pointClass || (r.pointClass = oq), !t.seriesTypes[e] && (o && (s[e] = o), t.seriesTypes[e] = i, !0);\n    }\n    t.seriesTypes = O.seriesTypes, t.registerSeriesType = e, t.seriesType = function (i, s, o, r, n) {\n      let a = rg.plotOptions || {};\n      if (s = s || \"\", a[i] = rx(a[s], o), delete t.seriesTypes[i], e(i, rm(t.seriesTypes[s] || function () {}, r)), t.seriesTypes[i].prototype.type = i, n) {\n        class e extends oq {}\n        rf(e.prototype, n), t.seriesTypes[i].prototype.pointClass = e;\n      }\n      return t.seriesTypes[i];\n    };\n  }(g || (g = {}));\n  let ry = g,\n    {\n      animObject: rb,\n      setAnimation: rv\n    } = tU,\n    {\n      defaultOptions: rM\n    } = tS,\n    {\n      registerEventOptions: rk\n    } = se,\n    {\n      svg: rw,\n      win: rS\n    } = O,\n    {\n      seriesTypes: rA\n    } = ry,\n    {\n      arrayMax: rT,\n      arrayMin: rP,\n      clamp: rC,\n      correctFloat: rO,\n      crisp: rE,\n      defined: rL,\n      destroyObjectProperties: rB,\n      diffObjects: rI,\n      erase: rD,\n      error: rR,\n      extend: rN,\n      find: rz,\n      fireEvent: rW,\n      getClosestDistance: rG,\n      getNestedProperty: rH,\n      insertItem: rF,\n      isArray: rX,\n      isNumber: rY,\n      isString: rj,\n      merge: rU,\n      objectEach: rV,\n      pick: r$,\n      removeEvent: r_,\n      syncTimeout: rq\n    } = tt;\n  class rZ {\n    constructor() {\n      this.zoneAxis = \"y\";\n    }\n    init(t, e) {\n      let i;\n      rW(this, \"init\", {\n        options: e\n      }), this.dataTable ?? (this.dataTable = new rl());\n      let s = t.series;\n      this.eventsToUnbind = [], this.chart = t, this.options = this.setOptions(e);\n      let o = this.options,\n        r = !1 !== o.visible;\n      this.linkedSeries = [], this.bindAxes(), rN(this, {\n        name: o.name,\n        state: \"\",\n        visible: r,\n        selected: !0 === o.selected\n      }), rk(this, o);\n      let n = o.events;\n      (n && n.click || o.point && o.point.events && o.point.events.click || o.allowPointSelect) && (t.runTrackerClick = !0), this.getColor(), this.getSymbol(), this.isCartesian && (t.hasCartesianSeries = !0), s.length && (i = s[s.length - 1]), this._i = r$(i && i._i, -1) + 1, this.opacity = this.options.opacity, t.orderItems(\"series\", rF(this, s)), o.dataSorting && o.dataSorting.enabled ? this.setDataSortingOptions() : this.points || this.data || this.setData(o.data, !1), rW(this, \"afterInit\");\n    }\n    is(t) {\n      return rA[t] && this instanceof rA[t];\n    }\n    bindAxes() {\n      let t;\n      let e = this,\n        i = e.options,\n        s = e.chart;\n      rW(this, \"bindAxes\", null, function () {\n        (e.axisTypes || []).forEach(function (o) {\n          (s[o] || []).forEach(function (s) {\n            t = s.options, (r$(i[o], 0) === s.index || void 0 !== i[o] && i[o] === t.id) && (rF(e, s.series), e[o] = s, s.isDirty = !0);\n          }), e[o] || e.optionalAxis === o || rR(18, !0, s);\n        });\n      }), rW(this, \"afterBindAxes\");\n    }\n    hasData() {\n      return this.visible && void 0 !== this.dataMax && void 0 !== this.dataMin || this.visible && this.dataTable.rowCount > 0;\n    }\n    hasMarkerChanged(t, e) {\n      let i = t.marker,\n        s = e.marker || {};\n      return i && (s.enabled && !i.enabled || s.symbol !== i.symbol || s.height !== i.height || s.width !== i.width);\n    }\n    autoIncrement(t) {\n      let e;\n      let i = this.options,\n        {\n          pointIntervalUnit: s,\n          relativeXValue: o\n        } = this.options,\n        r = this.chart.time,\n        n = this.xIncrement ?? r.parse(i.pointStart) ?? 0;\n      if (this.pointInterval = e = r$(this.pointInterval, i.pointInterval, 1), o && rY(t) && (e *= t), s) {\n        let t = r.toParts(n);\n        \"day\" === s ? t[2] += e : \"month\" === s ? t[1] += e : \"year\" === s && (t[0] += e), e = r.makeTime.apply(r, t) - n;\n      }\n      return o && rY(t) ? n + e : (this.xIncrement = n + e, n);\n    }\n    setDataSortingOptions() {\n      let t = this.options;\n      rN(this, {\n        requireSorting: !1,\n        sorted: !1,\n        enabledDataSorting: !0,\n        allowDG: !1\n      }), rL(t.pointRange) || (t.pointRange = 1);\n    }\n    setOptions(t) {\n      let e;\n      let i = this.chart,\n        s = i.options.plotOptions,\n        o = i.userOptions || {},\n        r = rU(t),\n        n = i.styledMode,\n        a = {\n          plotOptions: s,\n          userOptions: r\n        };\n      rW(this, \"setOptions\", a);\n      let h = a.plotOptions[this.type],\n        l = o.plotOptions || {},\n        d = l.series || {},\n        c = rM.plotOptions[this.type] || {},\n        p = l[this.type] || {};\n      this.userOptions = a.userOptions;\n      let u = rU(h, s.series, p, r);\n      this.tooltipOptions = rU(rM.tooltip, rM.plotOptions.series?.tooltip, c?.tooltip, i.userOptions.tooltip, l.series?.tooltip, p.tooltip, r.tooltip), this.stickyTracking = r$(r.stickyTracking, p.stickyTracking, d.stickyTracking, !!this.tooltipOptions.shared && !this.noSharedTooltip || u.stickyTracking), null === h.marker && delete u.marker, this.zoneAxis = u.zoneAxis || \"y\";\n      let g = this.zones = (u.zones || []).map(t => ({\n        ...t\n      }));\n      return (u.negativeColor || u.negativeFillColor) && !u.zones && (e = {\n        value: u[this.zoneAxis + \"Threshold\"] || u.threshold || 0,\n        className: \"highcharts-negative\"\n      }, n || (e.color = u.negativeColor, e.fillColor = u.negativeFillColor), g.push(e)), g.length && rL(g[g.length - 1].value) && g.push(n ? {} : {\n        color: this.color,\n        fillColor: this.fillColor\n      }), rW(this, \"afterSetOptions\", {\n        options: u\n      }), u;\n    }\n    getName() {\n      return r$(this.options.name, \"Series \" + (this.index + 1));\n    }\n    getCyclic(t, e, i) {\n      let s, o;\n      let r = this.chart,\n        n = `${t}Index`,\n        a = `${t}Counter`,\n        h = i?.length || r.options.chart.colorCount;\n      !e && (rL(o = r$(\"color\" === t ? this.options.colorIndex : void 0, this[n])) ? s = o : (r.series.length || (r[a] = 0), s = r[a] % h, r[a] += 1), i && (e = i[s])), void 0 !== s && (this[n] = s), this[t] = e;\n    }\n    getColor() {\n      this.chart.styledMode ? this.getCyclic(\"color\") : this.options.colorByPoint ? this.color = \"#cccccc\" : this.getCyclic(\"color\", this.options.color || rM.plotOptions[this.type].color, this.chart.options.colors);\n    }\n    getPointsCollection() {\n      return (this.hasGroupedData ? this.points : this.data) || [];\n    }\n    getSymbol() {\n      let t = this.options.marker;\n      this.getCyclic(\"symbol\", t.symbol, this.chart.options.symbols);\n    }\n    getColumn(t, e) {\n      return (e ? this.dataTable.modified : this.dataTable).getColumn(t, !0) || [];\n    }\n    findPointIndex(t, e) {\n      let i, s, o;\n      let r = t.id,\n        n = t.x,\n        a = this.points,\n        h = this.options.dataSorting;\n      if (r) {\n        let t = this.chart.get(r);\n        t instanceof oq && (i = t);\n      } else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) {\n        let e = e => !e.touched && e.index === t.index;\n        if (h && h.matchByName ? e = e => !e.touched && e.name === t.name : this.options.relativeXValue && (e = e => !e.touched && e.options.x === t.x), !(i = rz(a, e))) return;\n      }\n      return i && void 0 !== (o = i && i.index) && (s = !0), void 0 === o && rY(n) && (o = this.getColumn(\"x\").indexOf(n, e)), -1 !== o && void 0 !== o && this.cropped && (o = o >= this.cropStart ? o - this.cropStart : o), !s && rY(o) && a[o] && a[o].touched && (o = void 0), o;\n    }\n    updateData(t, e) {\n      let i = this.options,\n        s = i.dataSorting,\n        o = this.points,\n        r = [],\n        n = this.requireSorting,\n        a = t.length === o.length,\n        h,\n        l,\n        d,\n        c,\n        p = !0;\n      if (this.xIncrement = null, t.forEach(function (t, e) {\n        let l;\n        let d = rL(t) && this.pointClass.prototype.optionsToObject.call({\n            series: this\n          }, t) || {},\n          p = d.x;\n        d.id || rY(p) ? (-1 === (l = this.findPointIndex(d, c)) || void 0 === l ? r.push(t) : o[l] && t !== i.data[l] ? (o[l].update(t, !1, null, !1), o[l].touched = !0, n && (c = l + 1)) : o[l] && (o[l].touched = !0), (!a || e !== l || s && s.enabled || this.hasDerivedData) && (h = !0)) : r.push(t);\n      }, this), h) for (l = o.length; l--;) (d = o[l]) && !d.touched && d.remove && d.remove(!1, e);else !a || s && s.enabled ? p = !1 : (t.forEach(function (t, e) {\n        t === o[e].y || o[e].destroyed || o[e].update(t, !1, null, !1);\n      }), r.length = 0);\n      if (o.forEach(function (t) {\n        t && (t.touched = !1);\n      }), !p) return !1;\n      r.forEach(function (t) {\n        this.addPoint(t, !1, null, null, !1);\n      }, this);\n      let u = this.getColumn(\"x\");\n      return null === this.xIncrement && u.length && (this.xIncrement = rT(u), this.autoIncrement()), !0;\n    }\n    dataColumnKeys() {\n      return [\"x\", ...(this.pointArrayMap || [\"y\"])];\n    }\n    setData(t, e = !0, i, s) {\n      let o = this.points,\n        r = o && o.length || 0,\n        n = this.options,\n        a = this.chart,\n        h = n.dataSorting,\n        l = this.xAxis,\n        d = n.turboThreshold,\n        c = this.dataTable,\n        p = this.dataColumnKeys(),\n        u = this.pointValKey || \"y\",\n        g = (this.pointArrayMap || []).length,\n        f = n.keys,\n        m,\n        x,\n        y = 0,\n        b = 1,\n        v;\n      a.options.chart.allowMutatingData || (n.data && delete this.options.data, this.userOptions.data && delete this.userOptions.data, v = rU(!0, t));\n      let M = (t = v || t || []).length;\n      if (h && h.enabled && (t = this.sortData(t)), a.options.chart.allowMutatingData && !1 !== s && M && r && !this.cropped && !this.hasGroupedData && this.visible && !this.boosted && (x = this.updateData(t, i)), !x) {\n        this.xIncrement = null, this.colorCounter = 0;\n        let e = d && M > d;\n        if (e) {\n          let i = this.getFirstValidPoint(t),\n            s = this.getFirstValidPoint(t, M - 1, -1),\n            o = t => !!(rX(t) && (f || rY(t[0])));\n          if (rY(i) && rY(s)) {\n            let e = [],\n              i = [];\n            for (let s of t) e.push(this.autoIncrement()), i.push(s);\n            c.setColumns({\n              x: e,\n              [u]: i\n            });\n          } else if (o(i) && o(s)) {\n            if (g) {\n              let e = i.length === g ? 1 : 0,\n                s = Array(p.length).fill(0).map(() => []);\n              for (let i of t) {\n                e && s[0].push(this.autoIncrement());\n                for (let t = e; t <= g; t++) s[t]?.push(i[t - e]);\n              }\n              c.setColumns(p.reduce((t, e, i) => (t[e] = s[i], t), {}));\n            } else {\n              f && (y = f.indexOf(\"x\"), b = f.indexOf(\"y\"), y = y >= 0 ? y : 0, b = b >= 0 ? b : 1), 1 === i.length && (b = 0);\n              let e = [],\n                s = [];\n              if (y === b) for (let i of t) e.push(this.autoIncrement()), s.push(i[b]);else for (let i of t) e.push(i[y]), s.push(i[b]);\n              c.setColumns({\n                x: e,\n                [u]: s\n              });\n            }\n          } else e = !1;\n        }\n        if (!e) {\n          let e = p.reduce((t, e) => (t[e] = [], t), {});\n          for (m = 0; m < M; m++) {\n            let i = this.pointClass.prototype.applyOptions.apply({\n              series: this\n            }, [t[m]]);\n            for (let t of p) e[t][m] = i[t];\n          }\n          c.setColumns(e);\n        }\n        for (rj(this.getColumn(\"y\")[0]) && rR(14, !0, a), this.data = [], this.options.data = this.userOptions.data = t, m = r; m--;) o[m]?.destroy();\n        l && (l.minRange = l.userMinRange), this.isDirty = a.isDirtyBox = !0, this.isDirtyData = !!o, i = !1;\n      }\n      \"point\" === n.legendType && (this.processData(), this.generatePoints()), e && a.redraw(i);\n    }\n    sortData(t) {\n      let e = this,\n        i = e.options.dataSorting.sortKey || \"y\",\n        s = function (t, e) {\n          return rL(e) && t.pointClass.prototype.optionsToObject.call({\n            series: t\n          }, e) || {};\n        };\n      return t.forEach(function (i, o) {\n        t[o] = s(e, i), t[o].index = o;\n      }, this), t.concat().sort((t, e) => {\n        let s = rH(i, t),\n          o = rH(i, e);\n        return o < s ? -1 : o > s ? 1 : 0;\n      }).forEach(function (t, e) {\n        t.x = e;\n      }, this), e.linkedSeries && e.linkedSeries.forEach(function (e) {\n        let i = e.options,\n          o = i.data;\n        i.dataSorting && i.dataSorting.enabled || !o || (o.forEach(function (i, r) {\n          o[r] = s(e, i), t[r] && (o[r].x = t[r].x, o[r].index = r);\n        }), e.setData(o, !1));\n      }), t;\n    }\n    getProcessedData(t) {\n      let e = this,\n        {\n          dataTable: i,\n          isCartesian: s,\n          options: o,\n          xAxis: r\n        } = e,\n        n = o.cropThreshold,\n        a = t || e.getExtremesFromAll,\n        h = r?.logarithmic,\n        l = i.rowCount,\n        d,\n        c,\n        p = 0,\n        u,\n        g,\n        f,\n        m = e.getColumn(\"x\"),\n        x = i,\n        y = !1;\n      return r && (g = (u = r.getExtremes()).min, f = u.max, y = !!(r.categories && !r.names.length), s && e.sorted && !a && (!n || l > n || e.forceCrop) && (m[l - 1] < g || m[0] > f ? x = new rl() : e.getColumn(e.pointValKey || \"y\").length && (m[0] < g || m[l - 1] > f) && (x = (d = this.cropData(i, g, f)).modified, p = d.start, c = !0))), m = x.getColumn(\"x\") || [], {\n        modified: x,\n        cropped: c,\n        cropStart: p,\n        closestPointRange: rG([h ? m.map(h.log2lin) : m], () => e.requireSorting && !y && rR(15, !1, e.chart))\n      };\n    }\n    processData(t) {\n      let e = this.xAxis,\n        i = this.dataTable;\n      if (this.isCartesian && !this.isDirty && !e.isDirty && !this.yAxis.isDirty && !t) return !1;\n      let s = this.getProcessedData();\n      i.modified = s.modified, this.cropped = s.cropped, this.cropStart = s.cropStart, this.closestPointRange = this.basePointRange = s.closestPointRange, rW(this, \"afterProcessData\");\n    }\n    cropData(t, e, i) {\n      let s = t.getColumn(\"x\", !0) || [],\n        o = s.length,\n        r = {},\n        n,\n        a,\n        h = 0,\n        l = o;\n      for (n = 0; n < o; n++) if (s[n] >= e) {\n        h = Math.max(0, n - 1);\n        break;\n      }\n      for (a = n; a < o; a++) if (s[a] > i) {\n        l = a + 1;\n        break;\n      }\n      for (let e of this.dataColumnKeys()) {\n        let i = t.getColumn(e, !0);\n        i && (r[e] = i.slice(h, l));\n      }\n      return {\n        modified: new rl({\n          columns: r\n        }),\n        start: h,\n        end: l\n      };\n    }\n    generatePoints() {\n      let t = this.options,\n        e = this.processedData || t.data,\n        i = this.dataTable.modified,\n        s = this.getColumn(\"x\", !0),\n        o = this.pointClass,\n        r = i.rowCount,\n        n = this.cropStart || 0,\n        a = this.hasGroupedData,\n        h = t.keys,\n        l = [],\n        d = t.dataGrouping && t.dataGrouping.groupAll ? n : 0,\n        c = this.xAxis?.categories,\n        p = this.pointArrayMap || [\"y\"],\n        u = this.dataColumnKeys(),\n        g,\n        f,\n        m,\n        x,\n        y = this.data,\n        b;\n      if (!y && !a) {\n        let t = [];\n        t.length = e?.length || 0, y = this.data = t;\n      }\n      for (h && a && (this.options.keys = !1), x = 0; x < r; x++) f = n + x, a ? ((m = new o(this, i.getRow(x, u) || [])).dataGroup = this.groupMap[d + x], m.dataGroup?.options && (m.options = m.dataGroup.options, rN(m, m.dataGroup.options), delete m.dataLabels)) : (m = y[f], b = e ? e[f] : i.getRow(x, p), m || void 0 === b || (y[f] = m = new o(this, b, s[x]))), m && (m.index = a ? d + x : f, l[x] = m, m.category = c?.[m.x] ?? m.x, m.key = m.name ?? m.category);\n      if (this.options.keys = h, y && (r !== (g = y.length) || a)) for (x = 0; x < g; x++) x !== n || a || (x += r), y[x] && (y[x].destroyElements(), y[x].plotX = void 0);\n      this.data = y, this.points = l, rW(this, \"afterGeneratePoints\");\n    }\n    getXExtremes(t) {\n      return {\n        min: rP(t),\n        max: rT(t)\n      };\n    }\n    getExtremes(t, e) {\n      let {\n          xAxis: i,\n          yAxis: s\n        } = this,\n        o = e || this.getExtremesFromAll || this.options.getExtremesFromAll,\n        r = o && this.cropped ? this.dataTable : this.dataTable.modified,\n        n = r.rowCount,\n        a = t || this.stackedYData,\n        h = a ? [a] : (this.keysAffectYAxis || this.pointArrayMap || [\"y\"])?.map(t => r.getColumn(t, !0) || []) || [],\n        l = this.getColumn(\"x\", !0),\n        d = [],\n        c = this.requireSorting && !this.is(\"column\") ? 1 : 0,\n        p = !!s && s.positiveValuesOnly,\n        u = o || this.cropped || !i,\n        g,\n        f,\n        m,\n        x = 0,\n        y = 0;\n      for (i && (x = (g = i.getExtremes()).min, y = g.max), m = 0; m < n; m++) if (f = l[m], u || (l[m + c] || f) >= x && (l[m - c] || f) <= y) for (let t of h) {\n        let e = t[m];\n        rY(e) && (e > 0 || !p) && d.push(e);\n      }\n      let b = {\n        activeYData: d,\n        dataMin: rP(d),\n        dataMax: rT(d)\n      };\n      return rW(this, \"afterGetExtremes\", {\n        dataExtremes: b\n      }), b;\n    }\n    applyExtremes() {\n      let t = this.getExtremes();\n      return this.dataMin = t.dataMin, this.dataMax = t.dataMax, t;\n    }\n    getFirstValidPoint(t, e = 0, i = 1) {\n      let s = t.length,\n        o = e;\n      for (; o >= 0 && o < s;) {\n        if (rL(t[o])) return t[o];\n        o += i;\n      }\n    }\n    translate() {\n      this.generatePoints();\n      let t = this.options,\n        e = t.stacking,\n        i = this.xAxis,\n        s = this.enabledDataSorting,\n        o = this.yAxis,\n        r = this.points,\n        n = r.length,\n        a = this.pointPlacementToXValue(),\n        h = !!a,\n        l = t.threshold,\n        d = t.startFromThreshold ? l : 0,\n        c,\n        p,\n        u,\n        g,\n        f = Number.MAX_VALUE;\n      function m(t) {\n        return rC(t, -1e9, 1e9);\n      }\n      for (c = 0; c < n; c++) {\n        let t;\n        let n = r[c],\n          x = n.x,\n          y,\n          b,\n          v = n.y,\n          M = n.low,\n          k = e && o.stacking?.stacks[(this.negStacks && v < (d ? 0 : l) ? \"-\" : \"\") + this.stackKey];\n        p = i.translate(x, !1, !1, !1, !0, a), n.plotX = rY(p) ? rO(m(p)) : void 0, e && this.visible && k && k[x] && (g = this.getStackIndicator(g, x, this.index), !n.isNull && g.key && (b = (y = k[x]).points[g.key]), y && rX(b) && (M = b[0], v = b[1], M === d && g.key === k[x].base && (M = r$(rY(l) ? l : o.min)), o.positiveValuesOnly && rL(M) && M <= 0 && (M = void 0), n.total = n.stackTotal = r$(y.total), n.percentage = rL(n.y) && y.total ? n.y / y.total * 100 : void 0, n.stackY = v, this.irregularWidths || y.setOffset(this.pointXOffset || 0, this.barW || 0, void 0, void 0, void 0, this.xAxis))), n.yBottom = rL(M) ? m(o.translate(M, !1, !0, !1, !0)) : void 0, this.dataModify && (v = this.dataModify.modifyValue(v, c)), rY(v) && void 0 !== n.plotX && (t = rY(t = o.translate(v, !1, !0, !1, !0)) ? m(t) : void 0), n.plotY = t, n.isInside = this.isPointInside(n), n.clientX = h ? rO(i.translate(x, !1, !1, !1, !0, a)) : p, n.negative = (n.y || 0) < (l || 0), n.isNull || !1 === n.visible || (void 0 !== u && (f = Math.min(f, Math.abs(p - u))), u = p), n.zone = this.zones.length ? n.getZone() : void 0, !n.graphic && this.group && s && (n.isNew = !0);\n      }\n      this.closestPointRangePx = f, rW(this, \"afterTranslate\");\n    }\n    getValidPoints(t, e, i) {\n      let s = this.chart;\n      return (t || this.points || []).filter(function (t) {\n        let {\n          plotX: o,\n          plotY: r\n        } = t;\n        return !!((i || !t.isNull && rY(r)) && (!e || s.isInsidePlot(o, r, {\n          inverted: s.inverted\n        }))) && !1 !== t.visible;\n      });\n    }\n    getClipBox() {\n      let {\n          chart: t,\n          xAxis: e,\n          yAxis: i\n        } = this,\n        {\n          x: s,\n          y: o,\n          width: r,\n          height: n\n        } = rU(t.clipBox);\n      return e && e.len !== t.plotSizeX && (r = e.len), i && i.len !== t.plotSizeY && (n = i.len), t.inverted && !this.invertible && ([r, n] = [n, r]), {\n        x: s,\n        y: o,\n        width: r,\n        height: n\n      };\n    }\n    getSharedClipKey() {\n      return this.sharedClipKey = (this.options.xAxis || 0) + \",\" + (this.options.yAxis || 0), this.sharedClipKey;\n    }\n    setClip() {\n      let {\n          chart: t,\n          group: e,\n          markerGroup: i\n        } = this,\n        s = t.sharedClips,\n        o = t.renderer,\n        r = this.getClipBox(),\n        n = this.getSharedClipKey(),\n        a = s[n];\n      a ? a.animate(r) : s[n] = a = o.clipRect(r), e && e.clip(!1 === this.options.clip ? void 0 : a), i && i.clip();\n    }\n    animate(t) {\n      let {\n          chart: e,\n          group: i,\n          markerGroup: s\n        } = this,\n        o = e.inverted,\n        r = rb(this.options.animation),\n        n = [this.getSharedClipKey(), r.duration, r.easing, r.defer].join(\",\"),\n        a = e.sharedClips[n],\n        h = e.sharedClips[n + \"m\"];\n      if (t && i) {\n        let t = this.getClipBox();\n        if (a) a.attr(\"height\", t.height);else {\n          t.width = 0, o && (t.x = e.plotHeight), a = e.renderer.clipRect(t), e.sharedClips[n] = a;\n          let i = {\n            x: -99,\n            y: -99,\n            width: o ? e.plotWidth + 199 : 99,\n            height: o ? 99 : e.plotHeight + 199\n          };\n          h = e.renderer.clipRect(i), e.sharedClips[n + \"m\"] = h;\n        }\n        i.clip(a), s?.clip(h);\n      } else if (a && !a.hasClass(\"highcharts-animating\")) {\n        let t = this.getClipBox(),\n          i = r.step;\n        (s?.element.childNodes.length || e.series.length > 1) && (r.step = function (t, e) {\n          i && i.apply(e, arguments), \"width\" === e.prop && h?.element && h.attr(o ? \"height\" : \"width\", t + 99);\n        }), a.addClass(\"highcharts-animating\").animate(t, r);\n      }\n    }\n    afterAnimate() {\n      this.setClip(), rV(this.chart.sharedClips, (t, e, i) => {\n        t && !this.chart.container.querySelector(`[clip-path=\"url(#${t.id})\"]`) && (t.destroy(), delete i[e]);\n      }), this.finishedAnimating = !0, rW(this, \"afterAnimate\");\n    }\n    drawPoints(t = this.points) {\n      let e, i, s, o, r, n, a;\n      let h = this.chart,\n        l = h.styledMode,\n        {\n          colorAxis: d,\n          options: c\n        } = this,\n        p = c.marker,\n        u = this[this.specialGroup || \"markerGroup\"],\n        g = this.xAxis,\n        f = r$(p.enabled, !g || !!g.isRadial || null, this.closestPointRangePx >= p.enabledThreshold * p.radius);\n      if (!1 !== p.enabled || this._hasPointMarkers) for (e = 0; e < t.length; e++) if (o = (s = (i = t[e]).graphic) ? \"animate\" : \"attr\", r = i.marker || {}, n = !!i.marker, (f && void 0 === r.enabled || r.enabled) && !i.isNull && !1 !== i.visible) {\n        let t = r$(r.symbol, this.symbol, \"rect\");\n        a = this.markerAttribs(i, i.selected && \"select\"), this.enabledDataSorting && (i.startXPos = g.reversed ? -(a.width || 0) : g.width);\n        let e = !1 !== i.isInside;\n        if (!s && e && ((a.width || 0) > 0 || i.hasImage) && (i.graphic = s = h.renderer.symbol(t, a.x, a.y, a.width, a.height, n ? r : p).add(u), this.enabledDataSorting && h.hasRendered && (s.attr({\n          x: i.startXPos\n        }), o = \"animate\")), s && \"animate\" === o && s[e ? \"show\" : \"hide\"](e).animate(a), s) {\n          let t = this.pointAttribs(i, l || !i.selected ? void 0 : \"select\");\n          l ? d && s.css({\n            fill: t.fill\n          }) : s[o](t);\n        }\n        s && s.addClass(i.getClassName(), !0);\n      } else s && (i.graphic = s.destroy());\n    }\n    markerAttribs(t, e) {\n      let i = this.options,\n        s = i.marker,\n        o = t.marker || {},\n        r = o.symbol || s.symbol,\n        n = {},\n        a,\n        h,\n        l = r$(o.radius, s && s.radius);\n      e && (a = s.states[e], l = r$((h = o.states && o.states[e]) && h.radius, a && a.radius, l && l + (a && a.radiusPlus || 0))), t.hasImage = r && 0 === r.indexOf(\"url\"), t.hasImage && (l = 0);\n      let d = t.pos();\n      return rY(l) && d && (i.crisp && (d[0] = rE(d[0], t.hasImage ? 0 : \"rect\" === r ? s?.lineWidth || 0 : 1)), n.x = d[0] - l, n.y = d[1] - l), l && (n.width = n.height = 2 * l), n;\n    }\n    pointAttribs(t, e) {\n      let i = this.options.marker,\n        s = t && t.options,\n        o = s && s.marker || {},\n        r = s && s.color,\n        n = t && t.color,\n        a = t && t.zone && t.zone.color,\n        h,\n        l,\n        d = this.color,\n        c,\n        p,\n        u = r$(o.lineWidth, i.lineWidth),\n        g = 1;\n      return d = r || a || n || d, c = o.fillColor || i.fillColor || d, p = o.lineColor || i.lineColor || d, e = e || \"normal\", h = i.states[e] || {}, u = r$((l = o.states && o.states[e] || {}).lineWidth, h.lineWidth, u + r$(l.lineWidthPlus, h.lineWidthPlus, 0)), c = l.fillColor || h.fillColor || c, {\n        stroke: p = l.lineColor || h.lineColor || p,\n        \"stroke-width\": u,\n        fill: c,\n        opacity: g = r$(l.opacity, h.opacity, g)\n      };\n    }\n    destroy(t) {\n      let e, i, s;\n      let o = this,\n        r = o.chart,\n        n = /AppleWebKit\\/533/.test(rS.navigator.userAgent),\n        a = o.data || [];\n      for (rW(o, \"destroy\", {\n        keepEventsForUpdate: t\n      }), this.removeEvents(t), (o.axisTypes || []).forEach(function (t) {\n        (s = o[t]) && s.series && (rD(s.series, o), s.isDirty = s.forceRedraw = !0);\n      }), o.legendItem && o.chart.legend.destroyItem(o), e = a.length; e--;) (i = a[e]) && i.destroy && i.destroy();\n      for (let t of o.zones) rB(t, void 0, !0);\n      tt.clearTimeout(o.animationTimeout), rV(o, function (t, e) {\n        t instanceof eJ && !t.survive && t[n && \"group\" === e ? \"hide\" : \"destroy\"]();\n      }), r.hoverSeries === o && (r.hoverSeries = void 0), rD(r.series, o), r.orderItems(\"series\"), rV(o, function (e, i) {\n        t && \"hcEvents\" === i || delete o[i];\n      });\n    }\n    applyZones() {\n      let {\n          area: t,\n          chart: e,\n          graph: i,\n          zones: s,\n          points: o,\n          xAxis: r,\n          yAxis: n,\n          zoneAxis: a\n        } = this,\n        {\n          inverted: h,\n          renderer: l\n        } = e,\n        d = this[`${a}Axis`],\n        {\n          isXAxis: c,\n          len: p = 0,\n          minPointOffset: u = 0\n        } = d || {},\n        g = (i?.strokeWidth() || 0) / 2 + 1,\n        f = (t, e = 0, i = 0) => {\n          h && (i = p - i);\n          let {\n              translated: s = 0,\n              lineClip: o\n            } = t,\n            r = i - s;\n          o?.push([\"L\", e, Math.abs(r) < g ? i - g * (r <= 0 ? -1 : 1) : s]);\n        };\n      if (s.length && (i || t) && d && rY(d.min)) {\n        let e = d.getExtremes().max + u,\n          g = t => {\n            t.forEach((e, i) => {\n              (\"M\" === e[0] || \"L\" === e[0]) && (t[i] = [e[0], c ? p - e[1] : e[1], c ? e[2] : p - e[2]]);\n            });\n          };\n        if (s.forEach(t => {\n          t.lineClip = [], t.translated = rC(d.toPixels(r$(t.value, e), !0) || 0, 0, p);\n        }), i && !this.showLine && i.hide(), t && t.hide(), \"y\" === a && o.length < r.len) for (let t of o) {\n          let {\n              plotX: e,\n              plotY: i,\n              zone: o\n            } = t,\n            r = o && s[s.indexOf(o) - 1];\n          o && f(o, e, i), r && f(r, e, i);\n        }\n        let m = [],\n          x = d.toPixels(d.getExtremes().min - u, !0);\n        s.forEach(e => {\n          let s = e.lineClip || [],\n            o = Math.round(e.translated || 0);\n          r.reversed && s.reverse();\n          let {\n              clip: a,\n              simpleClip: d\n            } = e,\n            p = 0,\n            u = 0,\n            f = r.len,\n            y = n.len;\n          c ? (p = o, f = x) : (u = o, y = x);\n          let b = [[\"M\", p, u], [\"L\", f, u], [\"L\", f, y], [\"L\", p, y], [\"Z\"]],\n            v = [b[0], ...s, b[1], b[2], ...m, b[3], b[4]];\n          m = s.reverse(), x = o, h && (g(v), t && g(b)), a ? (a.animate({\n            d: v\n          }), d?.animate({\n            d: b\n          })) : (a = e.clip = l.path(v), t && (d = e.simpleClip = l.path(b))), i && e.graph?.clip(a), t && e.area?.clip(d);\n        });\n      } else this.visible && (i && i.show(), t && t.show());\n    }\n    plotGroup(t, e, i, s, o) {\n      let r = this[t],\n        n = !r,\n        a = {\n          visibility: i,\n          zIndex: s || .1\n        };\n      return rL(this.opacity) && !this.chart.styledMode && \"inactive\" !== this.state && (a.opacity = this.opacity), r || (this[t] = r = this.chart.renderer.g().add(o)), r.addClass(\"highcharts-\" + e + \" highcharts-series-\" + this.index + \" highcharts-\" + this.type + \"-series \" + (rL(this.colorIndex) ? \"highcharts-color-\" + this.colorIndex + \" \" : \"\") + (this.options.className || \"\") + (r.hasClass(\"highcharts-tracker\") ? \" highcharts-tracker\" : \"\"), !0), r.attr(a)[n ? \"attr\" : \"animate\"](this.getPlotBox(e)), r;\n    }\n    getPlotBox(t) {\n      let e = this.xAxis,\n        i = this.yAxis,\n        s = this.chart,\n        o = s.inverted && !s.polar && e && this.invertible && \"series\" === t;\n      return s.inverted && (e = i, i = this.xAxis), {\n        translateX: e ? e.left : s.plotLeft,\n        translateY: i ? i.top : s.plotTop,\n        rotation: o ? 90 : 0,\n        rotationOriginX: o ? (e.len - i.len) / 2 : 0,\n        rotationOriginY: o ? (e.len + i.len) / 2 : 0,\n        scaleX: o ? -1 : 1,\n        scaleY: 1\n      };\n    }\n    removeEvents(t) {\n      let {\n        eventsToUnbind: e\n      } = this;\n      t || r_(this), e.length && (e.forEach(t => {\n        t();\n      }), e.length = 0);\n    }\n    render() {\n      let t = this,\n        {\n          chart: e,\n          options: i,\n          hasRendered: s\n        } = t,\n        o = rb(i.animation),\n        r = t.visible ? \"inherit\" : \"hidden\",\n        n = i.zIndex,\n        a = e.seriesGroup,\n        h = t.finishedAnimating ? 0 : o.duration;\n      rW(this, \"render\"), t.plotGroup(\"group\", \"series\", r, n, a), t.markerGroup = t.plotGroup(\"markerGroup\", \"markers\", r, n, a), !1 !== i.clip && t.setClip(), h && t.animate?.(!0), t.drawGraph && (t.drawGraph(), t.applyZones()), t.visible && t.drawPoints(), t.drawDataLabels?.(), t.redrawPoints?.(), i.enableMouseTracking && t.drawTracker?.(), h && t.animate?.(), s || (h && o.defer && (h += o.defer), t.animationTimeout = rq(() => {\n        t.afterAnimate();\n      }, h || 0)), t.isDirty = !1, t.hasRendered = !0, rW(t, \"afterRender\");\n    }\n    redraw() {\n      let t = this.isDirty || this.isDirtyData;\n      this.translate(), this.render(), t && delete this.kdTree;\n    }\n    reserveSpace() {\n      return this.visible || !this.chart.options.chart.ignoreHiddenSeries;\n    }\n    searchPoint(t, e) {\n      let {\n          xAxis: i,\n          yAxis: s\n        } = this,\n        o = this.chart.inverted;\n      return this.searchKDTree({\n        clientX: o ? i.len - t.chartY + i.pos : t.chartX - i.pos,\n        plotY: o ? s.len - t.chartX + s.pos : t.chartY - s.pos\n      }, e, t);\n    }\n    buildKDTree(t) {\n      this.buildingKdTree = !0;\n      let e = this,\n        i = e.options.findNearestPointBy.indexOf(\"y\") > -1 ? 2 : 1;\n      delete e.kdTree, rq(function () {\n        e.kdTree = function t(i, s, o) {\n          let r, n;\n          let a = i?.length;\n          if (a) return r = e.kdAxisArray[s % o], i.sort((t, e) => (t[r] || 0) - (e[r] || 0)), {\n            point: i[n = Math.floor(a / 2)],\n            left: t(i.slice(0, n), s + 1, o),\n            right: t(i.slice(n + 1), s + 1, o)\n          };\n        }(e.getValidPoints(void 0, !e.directTouch), i, i), e.buildingKdTree = !1;\n      }, e.options.kdNow || t?.type === \"touchstart\" ? 0 : 1);\n    }\n    searchKDTree(t, e, i, s, o) {\n      let r = this,\n        [n, a] = this.kdAxisArray,\n        h = e ? \"distX\" : \"dist\",\n        l = (r.options.findNearestPointBy || \"\").indexOf(\"y\") > -1 ? 2 : 1,\n        d = !!r.isBubble,\n        c = s || ((t, e, i) => [(t[i] || 0) < (e[i] || 0) ? t : e, !1]),\n        p = o || ((t, e) => t < e);\n      if (this.kdTree || this.buildingKdTree || this.buildKDTree(i), this.kdTree) return function t(e, i, s, o) {\n        let l = i.point,\n          u = r.kdAxisArray[s % o],\n          g = l,\n          f = !1;\n        !function (t, e) {\n          let i = t[n],\n            s = e[n],\n            o = rL(i) && rL(s) ? i - s : null,\n            r = t[a],\n            h = e[a],\n            l = rL(r) && rL(h) ? r - h : 0,\n            c = d && e.marker?.radius || 0;\n          e.dist = Math.sqrt((o && o * o || 0) + l * l) - c, e.distX = rL(o) ? Math.abs(o) - c : Number.MAX_VALUE;\n        }(e, l);\n        let m = (e[u] || 0) - (l[u] || 0) + (d && l.marker?.radius || 0),\n          x = m < 0 ? \"left\" : \"right\",\n          y = m < 0 ? \"right\" : \"left\";\n        return i[x] && ([g, f] = c(l, t(e, i[x], s + 1, o), h)), i[y] && p(Math.sqrt(m * m), g[h], f) && (g = c(g, t(e, i[y], s + 1, o), h)[0]), g;\n      }(t, this.kdTree, l, l);\n    }\n    pointPlacementToXValue() {\n      let {\n          options: t,\n          xAxis: e\n        } = this,\n        i = t.pointPlacement;\n      return \"between\" === i && (i = e.reversed ? -.5 : .5), rY(i) ? i * (t.pointRange || e.pointRange) : 0;\n    }\n    isPointInside(t) {\n      let {\n          chart: e,\n          xAxis: i,\n          yAxis: s\n        } = this,\n        {\n          plotX: o = -1,\n          plotY: r = -1\n        } = t;\n      return r >= 0 && r <= (s ? s.len : e.plotHeight) && o >= 0 && o <= (i ? i.len : e.plotWidth);\n    }\n    drawTracker() {\n      let t = this,\n        e = t.options,\n        i = e.trackByArea,\n        s = [].concat((i ? t.areaPath : t.graphPath) || []),\n        o = t.chart,\n        r = o.pointer,\n        n = o.renderer,\n        a = o.options.tooltip?.snap || 0,\n        h = () => {\n          e.enableMouseTracking && o.hoverSeries !== t && t.onMouseOver();\n        },\n        l = \"rgba(192,192,192,\" + (rw ? 1e-4 : .002) + \")\",\n        d = t.tracker;\n      d ? d.attr({\n        d: s\n      }) : t.graph && (t.tracker = d = n.path(s).attr({\n        visibility: t.visible ? \"inherit\" : \"hidden\",\n        zIndex: 2\n      }).addClass(i ? \"highcharts-tracker-area\" : \"highcharts-tracker-line\").add(t.group), o.styledMode || d.attr({\n        \"stroke-linecap\": \"round\",\n        \"stroke-linejoin\": \"round\",\n        stroke: l,\n        fill: i ? l : \"none\",\n        \"stroke-width\": t.graph.strokeWidth() + (i ? 0 : 2 * a)\n      }), [t.tracker, t.markerGroup, t.dataLabelsGroup].forEach(t => {\n        t && (t.addClass(\"highcharts-tracker\").on(\"mouseover\", h).on(\"mouseout\", t => {\n          r?.onTrackerMouseOut(t);\n        }), e.cursor && !o.styledMode && t.css({\n          cursor: e.cursor\n        }), t.on(\"touchstart\", h));\n      })), rW(this, \"afterDrawTracker\");\n    }\n    addPoint(t, e, i, s, o) {\n      let r, n;\n      let a = this.options,\n        {\n          chart: h,\n          data: l,\n          dataTable: d,\n          xAxis: c\n        } = this,\n        p = c && c.hasNames && c.names,\n        u = a.data,\n        g = this.getColumn(\"x\");\n      e = r$(e, !0);\n      let f = {\n        series: this\n      };\n      this.pointClass.prototype.applyOptions.apply(f, [t]);\n      let m = f.x;\n      if (n = g.length, this.requireSorting && m < g[n - 1]) for (r = !0; n && g[n - 1] > m;) n--;\n      d.setRow(f, n, !0, {\n        addColumns: !1\n      }), p && f.name && (p[m] = f.name), u?.splice(n, 0, t), (r || this.processedData) && (this.data.splice(n, 0, null), this.processData()), \"point\" === a.legendType && this.generatePoints(), i && (l[0] && l[0].remove ? l[0].remove(!1) : ([l, u, ...Object.values(d.getColumns())].filter(rL).forEach(t => {\n        t.shift();\n      }), d.rowCount -= 1, rW(d, \"afterDeleteRows\"))), !1 !== o && rW(this, \"addPoint\", {\n        point: f\n      }), this.isDirty = !0, this.isDirtyData = !0, e && h.redraw(s);\n    }\n    removePoint(t, e, i) {\n      let s = this,\n        {\n          chart: o,\n          data: r,\n          points: n,\n          dataTable: a\n        } = s,\n        h = r[t],\n        l = function () {\n          [n?.length === r.length ? n : void 0, r, s.options.data, ...Object.values(a.getColumns())].filter(rL).forEach(e => {\n            e.splice(t, 1);\n          }), a.rowCount -= 1, rW(a, \"afterDeleteRows\"), h?.destroy(), s.isDirty = !0, s.isDirtyData = !0, e && o.redraw();\n        };\n      rv(i, o), e = r$(e, !0), h ? h.firePointEvent(\"remove\", null, l) : l();\n    }\n    remove(t, e, i, s) {\n      let o = this,\n        r = o.chart;\n      function n() {\n        o.destroy(s), r.isDirtyLegend = r.isDirtyBox = !0, r.linkSeries(s), r$(t, !0) && r.redraw(e);\n      }\n      !1 !== i ? rW(o, \"remove\", null, n) : n();\n    }\n    update(t, e) {\n      rW(this, \"update\", {\n        options: t = rI(t, this.userOptions)\n      });\n      let i = this,\n        s = i.chart,\n        o = i.userOptions,\n        r = i.initialType || i.type,\n        n = s.options.plotOptions,\n        a = rA[r].prototype,\n        h = i.finishedAnimating && {\n          animation: !1\n        },\n        l = {},\n        d,\n        c,\n        p = [\"colorIndex\", \"eventOptions\", \"navigatorSeries\", \"symbolIndex\", \"baseSeries\"],\n        u = t.type || o.type || s.options.chart.type,\n        g = !(this.hasDerivedData || u && u !== this.type || void 0 !== t.keys || void 0 !== t.pointStart || void 0 !== t.pointInterval || void 0 !== t.relativeXValue || t.joinBy || t.mapData || [\"dataGrouping\", \"pointStart\", \"pointInterval\", \"pointIntervalUnit\", \"keys\"].some(t => i.hasOptionChanged(t)));\n      u = u || r, g ? (p.push(\"data\", \"isDirtyData\", \"isDirtyCanvas\", \"points\", \"dataTable\", \"processedData\", \"xIncrement\", \"cropped\", \"_hasPointMarkers\", \"hasDataLabels\", \"nodes\", \"layout\", \"level\", \"mapMap\", \"mapData\", \"minY\", \"maxY\", \"minX\", \"maxX\", \"transformGroups\"), !1 !== t.visible && p.push(\"area\", \"graph\"), i.parallelArrays.forEach(function (t) {\n        p.push(t + \"Data\");\n      }), t.data && (t.dataSorting && rN(i.options.dataSorting, t.dataSorting), this.setData(t.data, !1))) : this.dataTable.modified = this.dataTable, t = rU(o, {\n        index: void 0 === o.index ? i.index : o.index,\n        pointStart: n?.series?.pointStart ?? o.pointStart ?? i.getColumn(\"x\")[0]\n      }, !g && {\n        data: i.options.data\n      }, t, h), g && t.data && (t.data = i.options.data), (p = [\"group\", \"markerGroup\", \"dataLabelsGroup\", \"transformGroup\"].concat(p)).forEach(function (t) {\n        p[t] = i[t], delete i[t];\n      });\n      let f = !1;\n      if (rA[u]) {\n        if (f = u !== i.type, i.remove(!1, !1, !1, !0), f) {\n          if (s.propFromSeries(), Object.setPrototypeOf) Object.setPrototypeOf(i, rA[u].prototype);else {\n            let t = Object.hasOwnProperty.call(i, \"hcEvents\") && i.hcEvents;\n            for (c in a) i[c] = void 0;\n            rN(i, rA[u].prototype), t ? i.hcEvents = t : delete i.hcEvents;\n          }\n        }\n      } else rR(17, !0, s, {\n        missingModuleFor: u\n      });\n      if (p.forEach(function (t) {\n        i[t] = p[t];\n      }), i.init(s, t), g && this.points) for (let t of (!1 === (d = i.options).visible ? (l.graphic = 1, l.dataLabel = 1) : (this.hasMarkerChanged(d, o) && (l.graphic = 1), i.hasDataLabels?.() || (l.dataLabel = 1)), this.points)) t && t.series && (t.resolveColor(), Object.keys(l).length && t.destroyElements(l), !1 === d.showInLegend && t.legendItem && s.legend.destroyItem(t));\n      i.initialType = r, s.linkSeries(), s.setSortedData(), f && i.linkedSeries.length && (i.isDirtyData = !0), rW(this, \"afterUpdate\"), r$(e, !0) && s.redraw(!!g && void 0);\n    }\n    setName(t) {\n      this.name = this.options.name = this.userOptions.name = t, this.chart.isDirtyLegend = !0;\n    }\n    hasOptionChanged(t) {\n      let e = this.chart,\n        i = this.options[t],\n        s = e.options.plotOptions,\n        o = this.userOptions[t],\n        r = r$(s?.[this.type]?.[t], s?.series?.[t]);\n      return o && !rL(r) ? i !== o : i !== r$(r, i);\n    }\n    onMouseOver() {\n      let t = this.chart,\n        e = t.hoverSeries,\n        i = t.pointer;\n      i?.setHoverChartIndex(), e && e !== this && e.onMouseOut(), this.options.events.mouseOver && rW(this, \"mouseOver\"), this.setState(\"hover\"), t.hoverSeries = this;\n    }\n    onMouseOut() {\n      let t = this.options,\n        e = this.chart,\n        i = e.tooltip,\n        s = e.hoverPoint;\n      e.hoverSeries = null, s && s.onMouseOut(), this && t.events.mouseOut && rW(this, \"mouseOut\"), i && !this.stickyTracking && (!i.shared || this.noSharedTooltip) && i.hide(), e.series.forEach(function (t) {\n        t.setState(\"\", !0);\n      });\n    }\n    setState(t, e) {\n      let i = this,\n        s = i.options,\n        o = i.graph,\n        r = s.inactiveOtherPoints,\n        n = s.states,\n        a = r$(n[t || \"normal\"] && n[t || \"normal\"].animation, i.chart.options.chart.animation),\n        h = s.lineWidth,\n        l = s.opacity;\n      if (t = t || \"\", i.state !== t && ([i.group, i.markerGroup, i.dataLabelsGroup].forEach(function (e) {\n        e && (i.state && e.removeClass(\"highcharts-series-\" + i.state), t && e.addClass(\"highcharts-series-\" + t));\n      }), i.state = t, !i.chart.styledMode)) {\n        if (n[t] && !1 === n[t].enabled) return;\n        if (t && (h = n[t].lineWidth || h + (n[t].lineWidthPlus || 0), l = r$(n[t].opacity, l)), o && !o.dashstyle && rY(h)) for (let t of [o, ...this.zones.map(t => t.graph)]) t?.animate({\n          \"stroke-width\": h\n        }, a);\n        r || [i.group, i.markerGroup, i.dataLabelsGroup, i.labelBySeries].forEach(function (t) {\n          t && t.animate({\n            opacity: l\n          }, a);\n        });\n      }\n      e && r && i.points && i.setAllPointsToState(t || void 0);\n    }\n    setAllPointsToState(t) {\n      this.points.forEach(function (e) {\n        e.setState && e.setState(t);\n      });\n    }\n    setVisible(t, e) {\n      let i = this,\n        s = i.chart,\n        o = s.options.chart.ignoreHiddenSeries,\n        r = i.visible;\n      i.visible = t = i.options.visible = i.userOptions.visible = void 0 === t ? !r : t;\n      let n = t ? \"show\" : \"hide\";\n      [\"group\", \"dataLabelsGroup\", \"markerGroup\", \"tracker\", \"tt\"].forEach(t => {\n        i[t]?.[n]();\n      }), (s.hoverSeries === i || s.hoverPoint?.series === i) && i.onMouseOut(), i.legendItem && s.legend.colorizeItem(i, t), i.isDirty = !0, i.options.stacking && s.series.forEach(t => {\n        t.options.stacking && t.visible && (t.isDirty = !0);\n      }), i.linkedSeries.forEach(e => {\n        e.setVisible(t, !1);\n      }), o && (s.isDirtyBox = !0), rW(i, n), !1 !== e && s.redraw();\n    }\n    show() {\n      this.setVisible(!0);\n    }\n    hide() {\n      this.setVisible(!1);\n    }\n    select(t) {\n      this.selected = t = this.options.selected = void 0 === t ? !this.selected : t, this.checkbox && (this.checkbox.checked = t), rW(this, t ? \"select\" : \"unselect\");\n    }\n    shouldShowTooltip(t, e, i = {}) {\n      return i.series = this, i.visiblePlotOnly = !0, this.chart.isInsidePlot(t, e, i);\n    }\n    drawLegendSymbol(t, e) {\n      ru[this.options.legendSymbol || \"rectangle\"]?.call(this, t, e);\n    }\n  }\n  rZ.defaultOptions = {\n    lineWidth: 2,\n    allowPointSelect: !1,\n    crisp: !0,\n    showCheckbox: !1,\n    animation: {\n      duration: 1e3\n    },\n    enableMouseTracking: !0,\n    events: {},\n    marker: {\n      enabledThreshold: 2,\n      lineColor: \"#ffffff\",\n      lineWidth: 0,\n      radius: 4,\n      states: {\n        normal: {\n          animation: !0\n        },\n        hover: {\n          animation: {\n            duration: 150\n          },\n          enabled: !0,\n          radiusPlus: 2,\n          lineWidthPlus: 1\n        },\n        select: {\n          fillColor: \"#cccccc\",\n          lineColor: \"#000000\",\n          lineWidth: 2\n        }\n      }\n    },\n    point: {\n      events: {}\n    },\n    dataLabels: {\n      animation: {},\n      align: \"center\",\n      borderWidth: 0,\n      defer: !0,\n      formatter: function () {\n        let {\n          numberFormatter: t\n        } = this.series.chart;\n        return \"number\" != typeof this.y ? \"\" : t(this.y, -1);\n      },\n      padding: 5,\n      style: {\n        fontSize: \"0.7em\",\n        fontWeight: \"bold\",\n        color: \"contrast\",\n        textOutline: \"1px contrast\"\n      },\n      verticalAlign: \"bottom\",\n      x: 0,\n      y: 0\n    },\n    cropThreshold: 300,\n    opacity: 1,\n    pointRange: 0,\n    softThreshold: !0,\n    states: {\n      normal: {\n        animation: !0\n      },\n      hover: {\n        animation: {\n          duration: 150\n        },\n        lineWidthPlus: 1,\n        marker: {},\n        halo: {\n          size: 10,\n          opacity: .25\n        }\n      },\n      select: {\n        animation: {\n          duration: 0\n        }\n      },\n      inactive: {\n        animation: {\n          duration: 150\n        },\n        opacity: .2\n      }\n    },\n    stickyTracking: !0,\n    turboThreshold: 1e3,\n    findNearestPointBy: \"x\"\n  }, rZ.types = ry.seriesTypes, rZ.registerType = ry.registerSeriesType, rN(rZ.prototype, {\n    axisTypes: [\"xAxis\", \"yAxis\"],\n    coll: \"series\",\n    colorCounter: 0,\n    directTouch: !1,\n    invertible: !0,\n    isCartesian: !0,\n    kdAxisArray: [\"clientX\", \"plotY\"],\n    parallelArrays: [\"x\", \"y\"],\n    pointClass: oq,\n    requireSorting: !0,\n    sorted: !0\n  }), ry.series = rZ;\n  let rK = rZ,\n    {\n      animObject: rJ,\n      setAnimation: rQ\n    } = tU,\n    {\n      registerEventOptions: r0\n    } = se,\n    {\n      composed: r1,\n      marginNames: r2\n    } = O,\n    {\n      distribute: r3\n    } = ey,\n    {\n      format: r5\n    } = ep,\n    {\n      addEvent: r6,\n      createElement: r9,\n      css: r4,\n      defined: r8,\n      discardElement: r7,\n      find: nt,\n      fireEvent: ne,\n      isNumber: ni,\n      merge: ns,\n      pick: no,\n      pushUnique: nr,\n      relativeLength: nn,\n      stableSort: na,\n      syncTimeout: nh\n    } = tt;\n  class nl {\n    constructor(t, e) {\n      this.allItems = [], this.initialItemY = 0, this.itemHeight = 0, this.itemMarginBottom = 0, this.itemMarginTop = 0, this.itemX = 0, this.itemY = 0, this.lastItemY = 0, this.lastLineHeight = 0, this.legendHeight = 0, this.legendWidth = 0, this.maxItemWidth = 0, this.maxLegendWidth = 0, this.offsetWidth = 0, this.padding = 0, this.pages = [], this.symbolHeight = 0, this.symbolWidth = 0, this.titleHeight = 0, this.totalItemWidth = 0, this.widthOption = 0, this.chart = t, this.setOptions(e), e.enabled && (this.render(), r0(this, e), r6(this.chart, \"endResize\", function () {\n        this.legend.positionCheckboxes();\n      })), r6(this.chart, \"render\", () => {\n        this.options.enabled && this.proximate && (this.proximatePositions(), this.positionItems());\n      });\n    }\n    setOptions(t) {\n      let e = no(t.padding, 8);\n      this.options = t, this.chart.styledMode || (this.itemStyle = t.itemStyle, this.itemHiddenStyle = ns(this.itemStyle, t.itemHiddenStyle)), this.itemMarginTop = t.itemMarginTop, this.itemMarginBottom = t.itemMarginBottom, this.padding = e, this.initialItemY = e - 5, this.symbolWidth = no(t.symbolWidth, 16), this.pages = [], this.proximate = \"proximate\" === t.layout && !this.chart.inverted, this.baseline = void 0;\n    }\n    update(t, e) {\n      let i = this.chart;\n      this.setOptions(ns(!0, this.options, t)), \"events\" in this.options && r0(this, this.options), this.destroy(), i.isDirtyLegend = i.isDirtyBox = !0, no(e, !0) && i.redraw(), ne(this, \"afterUpdate\", {\n        redraw: e\n      });\n    }\n    colorizeItem(t, e) {\n      let i = t.color,\n        {\n          area: s,\n          group: o,\n          label: r,\n          line: n,\n          symbol: a\n        } = t.legendItem || {};\n      if ((t instanceof rK || t instanceof oq) && (t.color = t.options?.legendSymbolColor || i), o?.[e ? \"removeClass\" : \"addClass\"](\"highcharts-legend-item-hidden\"), !this.chart.styledMode) {\n        let {\n            itemHiddenStyle: i = {}\n          } = this,\n          o = i.color,\n          {\n            fillColor: h,\n            fillOpacity: l,\n            lineColor: d,\n            marker: c\n          } = t.options,\n          p = t => (!e && (t.fill && (t.fill = o), t.stroke && (t.stroke = o)), t);\n        r?.css(ns(e ? this.itemStyle : i)), n?.attr(p({\n          stroke: d || t.color\n        })), a && a.attr(p(c && a.isMarker ? t.pointAttribs() : {\n          fill: t.color\n        })), s?.attr(p({\n          fill: h || t.color,\n          \"fill-opacity\": h ? 1 : l ?? .75\n        }));\n      }\n      t.color = i, ne(this, \"afterColorizeItem\", {\n        item: t,\n        visible: e\n      });\n    }\n    positionItems() {\n      this.allItems.forEach(this.positionItem, this), this.chart.isResizing || this.positionCheckboxes();\n    }\n    positionItem(t) {\n      let {\n          group: e,\n          x: i = 0,\n          y: s = 0\n        } = t.legendItem || {},\n        o = this.options,\n        r = o.symbolPadding,\n        n = !o.rtl,\n        a = t.checkbox;\n      if (e && e.element) {\n        let o = {\n          translateX: n ? i : this.legendWidth - i - 2 * r - 4,\n          translateY: s\n        };\n        e[r8(e.translateY) ? \"animate\" : \"attr\"](o, void 0, () => {\n          ne(this, \"afterPositionItem\", {\n            item: t\n          });\n        });\n      }\n      a && (a.x = i, a.y = s);\n    }\n    destroyItem(t) {\n      let e = t.checkbox,\n        i = t.legendItem || {};\n      for (let t of [\"group\", \"label\", \"line\", \"symbol\"]) i[t] && (i[t] = i[t].destroy());\n      e && r7(e), t.legendItem = void 0;\n    }\n    destroy() {\n      for (let t of this.getAllItems()) this.destroyItem(t);\n      for (let t of [\"clipRect\", \"up\", \"down\", \"pager\", \"nav\", \"box\", \"title\", \"group\"]) this[t] && (this[t] = this[t].destroy());\n      this.display = null;\n    }\n    positionCheckboxes() {\n      let t;\n      let e = this.group && this.group.alignAttr,\n        i = this.clipHeight || this.legendHeight,\n        s = this.titleHeight;\n      e && (t = e.translateY, this.allItems.forEach(function (o) {\n        let r;\n        let n = o.checkbox;\n        n && (r = t + s + n.y + (this.scrollOffset || 0) + 3, r4(n, {\n          left: e.translateX + o.checkboxOffset + n.x - 20 + \"px\",\n          top: r + \"px\",\n          display: this.proximate || r > t - 6 && r < t + i - 6 ? \"\" : \"none\"\n        }));\n      }, this));\n    }\n    renderTitle() {\n      let t = this.options,\n        e = this.padding,\n        i = t.title,\n        s,\n        o = 0;\n      i.text && (this.title || (this.title = this.chart.renderer.label(i.text, e - 3, e - 4, void 0, void 0, void 0, t.useHTML, void 0, \"legend-title\").attr({\n        zIndex: 1\n      }), this.chart.styledMode || this.title.css(i.style), this.title.add(this.group)), i.width || this.title.css({\n        width: this.maxLegendWidth + \"px\"\n      }), o = (s = this.title.getBBox()).height, this.offsetWidth = s.width, this.contentGroup.attr({\n        translateY: o\n      })), this.titleHeight = o;\n    }\n    setText(t) {\n      let e = this.options;\n      t.legendItem.label.attr({\n        text: e.labelFormat ? r5(e.labelFormat, t, this.chart) : e.labelFormatter.call(t)\n      });\n    }\n    renderItem(t) {\n      let e = t.legendItem = t.legendItem || {},\n        i = this.chart,\n        s = i.renderer,\n        o = this.options,\n        r = \"horizontal\" === o.layout,\n        n = this.symbolWidth,\n        a = o.symbolPadding || 0,\n        h = this.itemStyle,\n        l = this.itemHiddenStyle,\n        d = r ? no(o.itemDistance, 20) : 0,\n        c = !o.rtl,\n        p = !t.series,\n        u = !p && t.series.drawLegendSymbol ? t.series : t,\n        g = u.options,\n        f = !!this.createCheckboxForItem && g && g.showCheckbox,\n        m = o.useHTML,\n        x = t.options.className,\n        y = e.label,\n        b = n + a + d + (f ? 20 : 0);\n      !y && (e.group = s.g(\"legend-item\").addClass(\"highcharts-\" + u.type + \"-series highcharts-color-\" + t.colorIndex + (x ? \" \" + x : \"\") + (p ? \" highcharts-series-\" + t.index : \"\")).attr({\n        zIndex: 1\n      }).add(this.scrollGroup), e.label = y = s.text(\"\", c ? n + a : -a, this.baseline || 0, m), i.styledMode || y.css(ns(t.visible ? h : l)), y.attr({\n        align: c ? \"left\" : \"right\",\n        zIndex: 2\n      }).add(e.group), !this.baseline && (this.fontMetrics = s.fontMetrics(y), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, y.attr(\"y\", this.baseline), this.symbolHeight = no(o.symbolHeight, this.fontMetrics.f), o.squareSymbol && (this.symbolWidth = no(o.symbolWidth, Math.max(this.symbolHeight, 16)), b = this.symbolWidth + a + d + (f ? 20 : 0), c && y.attr(\"x\", this.symbolWidth + a))), u.drawLegendSymbol(this, t), this.setItemEvents && this.setItemEvents(t, y, m)), f && !t.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(t), this.colorizeItem(t, t.visible), (i.styledMode || !h.width) && y.css({\n        width: (o.itemWidth || this.widthOption || i.spacingBox.width) - b + \"px\"\n      }), this.setText(t);\n      let v = y.getBBox(),\n        M = this.fontMetrics && this.fontMetrics.h || 0;\n      t.itemWidth = t.checkboxOffset = o.itemWidth || e.labelWidth || v.width + b, this.maxItemWidth = Math.max(this.maxItemWidth, t.itemWidth), this.totalItemWidth += t.itemWidth, this.itemHeight = t.itemHeight = Math.round(e.labelHeight || (v.height > 1.5 * M ? v.height : M));\n    }\n    layoutItem(t) {\n      let e = this.options,\n        i = this.padding,\n        s = \"horizontal\" === e.layout,\n        o = t.itemHeight,\n        r = this.itemMarginBottom,\n        n = this.itemMarginTop,\n        a = s ? no(e.itemDistance, 20) : 0,\n        h = this.maxLegendWidth,\n        l = e.alignColumns && this.totalItemWidth > h ? this.maxItemWidth : t.itemWidth,\n        d = t.legendItem || {};\n      s && this.itemX - i + l > h && (this.itemX = i, this.lastLineHeight && (this.itemY += n + this.lastLineHeight + r), this.lastLineHeight = 0), this.lastItemY = n + this.itemY + r, this.lastLineHeight = Math.max(o, this.lastLineHeight), d.x = this.itemX, d.y = this.itemY, s ? this.itemX += l : (this.itemY += n + o + r, this.lastLineHeight = o), this.offsetWidth = this.widthOption || Math.max((s ? this.itemX - i - (t.checkbox ? 0 : a) : l) + i, this.offsetWidth);\n    }\n    getAllItems() {\n      let t = [];\n      return this.chart.series.forEach(function (e) {\n        let i = e && e.options;\n        e && no(i.showInLegend, !r8(i.linkedTo) && void 0, !0) && (t = t.concat((e.legendItem || {}).labels || (\"point\" === i.legendType ? e.data : e)));\n      }), ne(this, \"afterGetAllItems\", {\n        allItems: t\n      }), t;\n    }\n    getAlignment() {\n      let t = this.options;\n      return this.proximate ? t.align.charAt(0) + \"tv\" : t.floating ? \"\" : t.align.charAt(0) + t.verticalAlign.charAt(0) + t.layout.charAt(0);\n    }\n    adjustMargins(t, e) {\n      let i = this.chart,\n        s = this.options,\n        o = this.getAlignment();\n      o && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (r, n) {\n        r.test(o) && !r8(t[n]) && (i[r2[n]] = Math.max(i[r2[n]], i.legend[(n + 1) % 2 ? \"legendHeight\" : \"legendWidth\"] + [1, -1, -1, 1][n] * s[n % 2 ? \"x\" : \"y\"] + no(s.margin, 12) + e[n] + (i.titleOffset[n] || 0)));\n      });\n    }\n    proximatePositions() {\n      let t;\n      let e = this.chart,\n        i = [],\n        s = \"left\" === this.options.align;\n      for (let o of (this.allItems.forEach(function (t) {\n        let o,\n          r,\n          n = s,\n          a,\n          h;\n        t.yAxis && (t.xAxis.options.reversed && (n = !n), t.points && (o = nt(n ? t.points : t.points.slice(0).reverse(), function (t) {\n          return ni(t.plotY);\n        })), r = this.itemMarginTop + t.legendItem.label.getBBox().height + this.itemMarginBottom, h = t.yAxis.top - e.plotTop, a = t.visible ? (o ? o.plotY : t.yAxis.height) + (h - .3 * r) : h + t.yAxis.height, i.push({\n          target: a,\n          size: r,\n          item: t\n        }));\n      }, this), r3(i, e.plotHeight))) t = o.item.legendItem || {}, ni(o.pos) && (t.y = e.plotTop - e.spacing[0] + o.pos);\n    }\n    render() {\n      let t = this.chart,\n        e = t.renderer,\n        i = this.options,\n        s = this.padding,\n        o = this.getAllItems(),\n        r,\n        n,\n        a,\n        h = this.group,\n        l,\n        d = this.box;\n      this.itemX = s, this.itemY = this.initialItemY, this.offsetWidth = 0, this.lastItemY = 0, this.widthOption = nn(i.width, t.spacingBox.width - s), l = t.spacingBox.width - 2 * s - i.x, [\"rm\", \"lm\"].indexOf(this.getAlignment().substring(0, 2)) > -1 && (l /= 2), this.maxLegendWidth = this.widthOption || l, h || (this.group = h = e.g(\"legend\").addClass(i.className || \"\").attr({\n        zIndex: 7\n      }).add(), this.contentGroup = e.g().attr({\n        zIndex: 1\n      }).add(h), this.scrollGroup = e.g().add(this.contentGroup)), this.renderTitle(), na(o, (t, e) => (t.options && t.options.legendIndex || 0) - (e.options && e.options.legendIndex || 0)), i.reversed && o.reverse(), this.allItems = o, this.display = r = !!o.length, this.lastLineHeight = 0, this.maxItemWidth = 0, this.totalItemWidth = 0, this.itemHeight = 0, o.forEach(this.renderItem, this), o.forEach(this.layoutItem, this), n = (this.widthOption || this.offsetWidth) + s, a = this.lastItemY + this.lastLineHeight + this.titleHeight, a = this.handleOverflow(a) + s, d || (this.box = d = e.rect().addClass(\"highcharts-legend-box\").attr({\n        r: i.borderRadius\n      }).add(h)), t.styledMode || d.attr({\n        stroke: i.borderColor,\n        \"stroke-width\": i.borderWidth || 0,\n        fill: i.backgroundColor || \"none\"\n      }).shadow(i.shadow), n > 0 && a > 0 && d[d.placed ? \"animate\" : \"attr\"](d.crisp.call({}, {\n        x: 0,\n        y: 0,\n        width: n,\n        height: a\n      }, d.strokeWidth())), h[r ? \"show\" : \"hide\"](), t.styledMode && \"none\" === h.getStyle(\"display\") && (n = a = 0), this.legendWidth = n, this.legendHeight = a, r && this.align(), this.proximate || this.positionItems(), ne(this, \"afterRender\");\n    }\n    align(t = this.chart.spacingBox) {\n      let e = this.chart,\n        i = this.options,\n        s = t.y;\n      /(lth|ct|rth)/.test(this.getAlignment()) && e.titleOffset[0] > 0 ? s += e.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && e.titleOffset[2] > 0 && (s -= e.titleOffset[2]), s !== t.y && (t = ns(t, {\n        y: s\n      })), e.hasRendered || (this.group.placed = !1), this.group.align(ns(i, {\n        width: this.legendWidth,\n        height: this.legendHeight,\n        verticalAlign: this.proximate ? \"top\" : i.verticalAlign\n      }), !0, t);\n    }\n    handleOverflow(t) {\n      let e = this,\n        i = this.chart,\n        s = i.renderer,\n        o = this.options,\n        r = o.y,\n        n = \"top\" === o.verticalAlign,\n        a = this.padding,\n        h = o.maxHeight,\n        l = o.navigation,\n        d = no(l.animation, !0),\n        c = l.arrowSize || 12,\n        p = this.pages,\n        u = this.allItems,\n        g = function (t) {\n          \"number\" == typeof t ? M.attr({\n            height: t\n          }) : M && (e.clipRect = M.destroy(), e.contentGroup.clip()), e.contentGroup.div && (e.contentGroup.div.style.clip = t ? \"rect(\" + a + \"px,9999px,\" + (a + t) + \"px,0)\" : \"auto\");\n        },\n        f = function (t) {\n          return e[t] = s.circle(0, 0, 1.3 * c).translate(c / 2, c / 2).add(v), i.styledMode || e[t].attr(\"fill\", \"rgba(0,0,0,0.0001)\"), e[t];\n        },\n        m,\n        x,\n        y,\n        b = i.spacingBox.height + (n ? -r : r) - a,\n        v = this.nav,\n        M = this.clipRect;\n      return \"horizontal\" !== o.layout || \"middle\" === o.verticalAlign || o.floating || (b /= 2), h && (b = Math.min(b, h)), p.length = 0, t && b > 0 && t > b && !1 !== l.enabled ? (this.clipHeight = m = Math.max(b - 20 - this.titleHeight - a, 0), this.currentPage = no(this.currentPage, 1), this.fullHeight = t, u.forEach((t, e) => {\n        let i = (y = t.legendItem || {}).y || 0,\n          s = Math.round(y.label.getBBox().height),\n          o = p.length;\n        (!o || i - p[o - 1] > m && (x || i) !== p[o - 1]) && (p.push(x || i), o++), y.pageIx = o - 1, x && ((u[e - 1].legendItem || {}).pageIx = o - 1), e === u.length - 1 && i + s - p[o - 1] > m && i > p[o - 1] && (p.push(i), y.pageIx = o), i !== x && (x = i);\n      }), M || (M = e.clipRect = s.clipRect(0, a - 2, 9999, 0), e.contentGroup.clip(M)), g(m), v || (this.nav = v = s.g().attr({\n        zIndex: 1\n      }).add(this.group), this.up = s.symbol(\"triangle\", 0, 0, c, c).add(v), f(\"upTracker\").on(\"click\", function () {\n        e.scroll(-1, d);\n      }), this.pager = s.text(\"\", 15, 10).addClass(\"highcharts-legend-navigation\"), !i.styledMode && l.style && this.pager.css(l.style), this.pager.add(v), this.down = s.symbol(\"triangle-down\", 0, 0, c, c).add(v), f(\"downTracker\").on(\"click\", function () {\n        e.scroll(1, d);\n      })), e.scroll(0), t = b) : v && (g(), this.nav = v.destroy(), this.scrollGroup.attr({\n        translateY: 1\n      }), this.clipHeight = 0), t;\n    }\n    scroll(t, e) {\n      let i = this.chart,\n        s = this.pages,\n        o = s.length,\n        r = this.clipHeight,\n        n = this.options.navigation,\n        a = this.pager,\n        h = this.padding,\n        l = this.currentPage + t;\n      l > o && (l = o), l > 0 && (void 0 !== e && rQ(e, i), this.nav.attr({\n        translateX: h,\n        translateY: r + this.padding + 7 + this.titleHeight,\n        visibility: \"inherit\"\n      }), [this.up, this.upTracker].forEach(function (t) {\n        t.attr({\n          class: 1 === l ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n        });\n      }), a.attr({\n        text: l + \"/\" + o\n      }), [this.down, this.downTracker].forEach(function (t) {\n        t.attr({\n          x: 18 + this.pager.getBBox().width,\n          class: l === o ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n        });\n      }, this), i.styledMode || (this.up.attr({\n        fill: 1 === l ? n.inactiveColor : n.activeColor\n      }), this.upTracker.css({\n        cursor: 1 === l ? \"default\" : \"pointer\"\n      }), this.down.attr({\n        fill: l === o ? n.inactiveColor : n.activeColor\n      }), this.downTracker.css({\n        cursor: l === o ? \"default\" : \"pointer\"\n      })), this.scrollOffset = -s[l - 1] + this.initialItemY, this.scrollGroup.animate({\n        translateY: this.scrollOffset\n      }), this.currentPage = l, this.positionCheckboxes(), nh(() => {\n        ne(this, \"afterScroll\", {\n          currentPage: l\n        });\n      }, rJ(no(e, i.renderer.globalAnimation, !0)).duration));\n    }\n    setItemEvents(t, e, i) {\n      let s = this,\n        o = t.legendItem || {},\n        r = s.chart.renderer.boxWrapper,\n        n = t instanceof oq,\n        a = t instanceof rK,\n        h = \"highcharts-legend-\" + (n ? \"point\" : \"series\") + \"-active\",\n        l = s.chart.styledMode,\n        d = i ? [e, o.symbol] : [o.group],\n        c = e => {\n          s.allItems.forEach(i => {\n            t !== i && [i].concat(i.linkedSeries || []).forEach(t => {\n              t.setState(e, !n);\n            });\n          });\n        };\n      for (let i of d) i && i.on(\"mouseover\", function () {\n        t.visible && c(\"inactive\"), t.setState(\"hover\"), t.visible && r.addClass(h), l || e.css(s.options.itemHoverStyle);\n      }).on(\"mouseout\", function () {\n        s.chart.styledMode || e.css(ns(t.visible ? s.itemStyle : s.itemHiddenStyle)), c(\"\"), r.removeClass(h), t.setState();\n      }).on(\"click\", function (e) {\n        let i = function () {\n          t.setVisible && t.setVisible(), c(t.visible ? \"inactive\" : \"\");\n        };\n        r.removeClass(h), ne(s, \"itemClick\", {\n          browserEvent: e,\n          legendItem: t\n        }, i), n ? t.firePointEvent(\"legendItemClick\", {\n          browserEvent: e\n        }) : a && ne(t, \"legendItemClick\", {\n          browserEvent: e\n        });\n      });\n    }\n    createCheckboxForItem(t) {\n      t.checkbox = r9(\"input\", {\n        type: \"checkbox\",\n        className: \"highcharts-legend-checkbox\",\n        checked: t.selected,\n        defaultChecked: t.selected\n      }, this.options.itemCheckboxStyle, this.chart.container), r6(t.checkbox, \"click\", function (e) {\n        let i = e.target;\n        ne(t.series || t, \"checkboxClick\", {\n          checked: i.checked,\n          item: t\n        }, function () {\n          t.select();\n        });\n      });\n    }\n  }\n  !function (t) {\n    t.compose = function (e) {\n      nr(r1, \"Core.Legend\") && r6(e, \"beforeMargins\", function () {\n        this.legend = new t(this, this.options.legend);\n      });\n    };\n  }(nl || (nl = {}));\n  let nd = nl,\n    {\n      animate: nc,\n      animObject: np,\n      setAnimation: nu\n    } = tU,\n    {\n      defaultOptions: ng\n    } = tS,\n    {\n      numberFormat: nf\n    } = ep,\n    {\n      registerEventOptions: nm\n    } = se,\n    {\n      charts: nx,\n      doc: ny,\n      marginNames: nb,\n      svg: nv,\n      win: nM\n    } = O,\n    {\n      seriesTypes: nk\n    } = ry,\n    {\n      addEvent: nw,\n      attr: nS,\n      createElement: nA,\n      css: nT,\n      defined: nP,\n      diffObjects: nC,\n      discardElement: nO,\n      erase: nE,\n      error: nL,\n      extend: nB,\n      find: nI,\n      fireEvent: nD,\n      getAlignFactor: nR,\n      getStyle: nN,\n      isArray: nz,\n      isNumber: nW,\n      isObject: nG,\n      isString: nH,\n      merge: nF,\n      objectEach: nX,\n      pick: nY,\n      pInt: nj,\n      relativeLength: nU,\n      removeEvent: nV,\n      splat: n$,\n      syncTimeout: n_,\n      uniqueKey: nq\n    } = tt;\n  class nZ {\n    static chart(t, e, i) {\n      return new nZ(t, e, i);\n    }\n    constructor(t, e, i) {\n      this.sharedClips = {};\n      let s = [...arguments];\n      (nH(t) || t.nodeName) && (this.renderTo = s.shift()), this.init(s[0], s[1]);\n    }\n    setZoomOptions() {\n      let t = this.options.chart,\n        e = t.zooming;\n      this.zooming = {\n        ...e,\n        type: nY(t.zoomType, e.type),\n        key: nY(t.zoomKey, e.key),\n        pinchType: nY(t.pinchType, e.pinchType),\n        singleTouch: nY(t.zoomBySingleTouch, e.singleTouch, !1),\n        resetButton: nF(e.resetButton, t.resetZoomButton)\n      };\n    }\n    init(t, e) {\n      nD(this, \"init\", {\n        args: arguments\n      }, function () {\n        let i = nF(ng, t),\n          s = i.chart,\n          o = this.renderTo || s.renderTo;\n        this.userOptions = nB({}, t), (this.renderTo = nH(o) ? ny.getElementById(o) : o) || nL(13, !0, this), this.margin = [], this.spacing = [], this.labelCollectors = [], this.callback = e, this.isResizing = 0, this.options = i, this.axes = [], this.series = [], this.locale = i.lang.locale ?? this.renderTo.closest(\"[lang]\")?.lang, this.time = new ty(nB(i.time || {}, {\n          locale: this.locale\n        })), i.time = this.time.options, this.numberFormatter = (s.numberFormatter || nf).bind(this), this.styledMode = s.styledMode, this.hasCartesianSeries = s.showAxes, this.index = nx.length, nx.push(this), O.chartCount++, nm(this, s), this.xAxis = [], this.yAxis = [], this.pointCount = this.colorCounter = this.symbolCounter = 0, this.setZoomOptions(), nD(this, \"afterInit\"), this.firstRender();\n      });\n    }\n    initSeries(t) {\n      let e = this.options.chart,\n        i = t.type || e.type,\n        s = nk[i];\n      s || nL(17, !0, this, {\n        missingModuleFor: i\n      });\n      let o = new s();\n      return \"function\" == typeof o.init && o.init(this, t), o;\n    }\n    setSortedData() {\n      this.getSeriesOrderByLinks().forEach(function (t) {\n        t.points || t.data || !t.enabledDataSorting || t.setData(t.options.data, !1);\n      });\n    }\n    getSeriesOrderByLinks() {\n      return this.series.concat().sort(function (t, e) {\n        return t.linkedSeries.length || e.linkedSeries.length ? e.linkedSeries.length - t.linkedSeries.length : 0;\n      });\n    }\n    orderItems(t, e = 0) {\n      let i = this[t],\n        s = this.options[t] = n$(this.options[t]).slice(),\n        o = this.userOptions[t] = this.userOptions[t] ? n$(this.userOptions[t]).slice() : [];\n      if (this.hasRendered && (s.splice(e), o.splice(e)), i) for (let t = e, r = i.length; t < r; ++t) {\n        let e = i[t];\n        e && (e.index = t, e instanceof rK && (e.name = e.getName()), e.options.isInternal || (s[t] = e.options, o[t] = e.userOptions));\n      }\n    }\n    isInsidePlot(t, e, i = {}) {\n      let {\n          inverted: s,\n          plotBox: o,\n          plotLeft: r,\n          plotTop: n,\n          scrollablePlotBox: a\n        } = this,\n        {\n          scrollLeft: h = 0,\n          scrollTop: l = 0\n        } = i.visiblePlotOnly && this.scrollablePlotArea?.scrollingContainer || {},\n        d = i.series,\n        c = i.visiblePlotOnly && a || o,\n        p = i.inverted ? e : t,\n        u = i.inverted ? t : e,\n        g = {\n          x: p,\n          y: u,\n          isInsidePlot: !0,\n          options: i\n        };\n      if (!i.ignoreX) {\n        let t = d && (s && !this.polar ? d.yAxis : d.xAxis) || {\n            pos: r,\n            len: 1 / 0\n          },\n          e = i.paneCoordinates ? t.pos + p : r + p;\n        e >= Math.max(h + r, t.pos) && e <= Math.min(h + r + c.width, t.pos + t.len) || (g.isInsidePlot = !1);\n      }\n      if (!i.ignoreY && g.isInsidePlot) {\n        let t = !s && i.axis && !i.axis.isXAxis && i.axis || d && (s ? d.xAxis : d.yAxis) || {\n            pos: n,\n            len: 1 / 0\n          },\n          e = i.paneCoordinates ? t.pos + u : n + u;\n        e >= Math.max(l + n, t.pos) && e <= Math.min(l + n + c.height, t.pos + t.len) || (g.isInsidePlot = !1);\n      }\n      return nD(this, \"afterIsInsidePlot\", g), g.isInsidePlot;\n    }\n    redraw(t) {\n      nD(this, \"beforeRedraw\");\n      let e = this.hasCartesianSeries ? this.axes : this.colorAxis || [],\n        i = this.series,\n        s = this.pointer,\n        o = this.legend,\n        r = this.userOptions.legend,\n        n = this.renderer,\n        a = n.isHidden(),\n        h = [],\n        l,\n        d,\n        c,\n        p = this.isDirtyBox,\n        u = this.isDirtyLegend,\n        g;\n      for (n.rootFontSize = n.boxWrapper.getStyle(\"font-size\"), this.setResponsive && this.setResponsive(!1), nu(!!this.hasRendered && t, this), a && this.temporaryDisplay(), this.layOutTitles(!1), c = i.length; c--;) if (((g = i[c]).options.stacking || g.options.centerInCategory) && (d = !0, g.isDirty)) {\n        l = !0;\n        break;\n      }\n      if (l) for (c = i.length; c--;) (g = i[c]).options.stacking && (g.isDirty = !0);\n      i.forEach(function (t) {\n        t.isDirty && (\"point\" === t.options.legendType ? (\"function\" == typeof t.updateTotals && t.updateTotals(), u = !0) : r && (r.labelFormatter || r.labelFormat) && (u = !0)), t.isDirtyData && nD(t, \"updatedData\");\n      }), u && o && o.options.enabled && (o.render(), this.isDirtyLegend = !1), d && this.getStacks(), e.forEach(function (t) {\n        t.updateNames(), t.setScale();\n      }), this.getMargins(), e.forEach(function (t) {\n        t.isDirty && (p = !0);\n      }), e.forEach(function (t) {\n        let e = t.min + \",\" + t.max;\n        t.extKey !== e && (t.extKey = e, h.push(function () {\n          nD(t, \"afterSetExtremes\", nB(t.eventArgs, t.getExtremes())), delete t.eventArgs;\n        })), (p || d) && t.redraw();\n      }), p && this.drawChartBox(), nD(this, \"predraw\"), i.forEach(function (t) {\n        (p || t.isDirty) && t.visible && t.redraw(), t.isDirtyData = !1;\n      }), s && s.reset(!0), n.draw(), nD(this, \"redraw\"), nD(this, \"render\"), a && this.temporaryDisplay(!0), h.forEach(function (t) {\n        t.call();\n      });\n    }\n    get(t) {\n      let e = this.series;\n      function i(e) {\n        return e.id === t || e.options && e.options.id === t;\n      }\n      let s = nI(this.axes, i) || nI(this.series, i);\n      for (let t = 0; !s && t < e.length; t++) s = nI(e[t].points || [], i);\n      return s;\n    }\n    createAxes() {\n      let t = this.userOptions;\n      for (let e of (nD(this, \"createAxes\"), [\"xAxis\", \"yAxis\"])) for (let i of t[e] = n$(t[e] || {})) new sU(this, i, e);\n      nD(this, \"afterCreateAxes\");\n    }\n    getSelectedPoints() {\n      return this.series.reduce((t, e) => (e.getPointsCollection().forEach(e => {\n        nY(e.selectedStaging, e.selected) && t.push(e);\n      }), t), []);\n    }\n    getSelectedSeries() {\n      return this.series.filter(t => t.selected);\n    }\n    setTitle(t, e, i) {\n      this.applyDescription(\"title\", t), this.applyDescription(\"subtitle\", e), this.applyDescription(\"caption\", void 0), this.layOutTitles(i);\n    }\n    applyDescription(t, e) {\n      let i = this,\n        s = this.options[t] = nF(this.options[t], e),\n        o = this[t];\n      o && e && (this[t] = o = o.destroy()), s && !o && ((o = this.renderer.text(s.text, 0, 0, s.useHTML).attr({\n        align: s.align,\n        class: \"highcharts-\" + t,\n        zIndex: s.zIndex || 4\n      }).css({\n        textOverflow: \"ellipsis\",\n        whiteSpace: \"nowrap\"\n      }).add()).update = function (e, s) {\n        i.applyDescription(t, e), i.layOutTitles(s);\n      }, this.styledMode || o.css(nB(\"title\" === t ? {\n        fontSize: this.options.isStock ? \"1em\" : \"1.2em\"\n      } : {}, s.style)), o.textPxLength = o.getBBox().width, o.css({\n        whiteSpace: s.style?.whiteSpace\n      }), this[t] = o);\n    }\n    layOutTitles(t = !0) {\n      let e = [0, 0, 0],\n        {\n          options: i,\n          renderer: s,\n          spacingBox: o\n        } = this;\n      [\"title\", \"subtitle\", \"caption\"].forEach(t => {\n        let i = this[t],\n          r = this.options[t],\n          n = nF(o),\n          a = i?.textPxLength || 0;\n        if (i && r) {\n          nD(this, \"layOutTitle\", {\n            alignTo: n,\n            key: t,\n            textPxLength: a\n          });\n          let o = s.fontMetrics(i),\n            h = o.b,\n            l = o.h,\n            d = r.verticalAlign || \"top\",\n            c = \"top\" === d,\n            p = c && r.minScale || 1,\n            u = \"title\" === t ? c ? -3 : 0 : c ? e[0] + 2 : 0,\n            g = Math.min(n.width / a, 1),\n            f = Math.max(p, g),\n            m = nF({\n              y: \"bottom\" === d ? h : u + h\n            }, {\n              align: \"title\" === t ? g < p ? \"left\" : \"center\" : this.title?.alignValue\n            }, r),\n            x = r.width || (g > p ? this.chartWidth : n.width) / f;\n          i.alignValue !== m.align && (i.placed = !1);\n          let y = Math.round(i.css({\n            width: `${x}px`\n          }).getBBox(r.useHTML).height);\n          if (m.height = y, i.align(m, !1, n).attr({\n            align: m.align,\n            scaleX: f,\n            scaleY: f,\n            \"transform-origin\": `${n.x + a * f * nR(m.align)} ${l}`\n          }), !r.floating) {\n            let t = y * (y < 1.2 * l ? 1 : f);\n            \"top\" === d ? e[0] = Math.ceil(e[0] + t) : \"bottom\" === d && (e[2] = Math.ceil(e[2] + t));\n          }\n        }\n      }, this), e[0] && \"top\" === (i.title?.verticalAlign || \"top\") && (e[0] += i.title?.margin || 0), e[2] && i.caption?.verticalAlign === \"bottom\" && (e[2] += i.caption?.margin || 0);\n      let r = !this.titleOffset || this.titleOffset.join(\",\") !== e.join(\",\");\n      this.titleOffset = e, nD(this, \"afterLayOutTitles\"), !this.isDirtyBox && r && (this.isDirtyBox = this.isDirtyLegend = r, this.hasRendered && t && this.isDirtyBox && this.redraw());\n    }\n    getContainerBox() {\n      let t = [].map.call(this.renderTo.children, t => {\n          if (t !== this.container) {\n            let e = t.style.display;\n            return t.style.display = \"none\", [t, e];\n          }\n        }),\n        e = {\n          width: nN(this.renderTo, \"width\", !0) || 0,\n          height: nN(this.renderTo, \"height\", !0) || 0\n        };\n      return t.filter(Boolean).forEach(([t, e]) => {\n        t.style.display = e;\n      }), e;\n    }\n    getChartSize() {\n      let t = this.options.chart,\n        e = t.width,\n        i = t.height,\n        s = this.getContainerBox(),\n        o = s.height <= 1 || !this.renderTo.parentElement?.style.height && \"100%\" === this.renderTo.style.height;\n      this.chartWidth = Math.max(0, e || s.width || 600), this.chartHeight = Math.max(0, nU(i, this.chartWidth) || (o ? 400 : s.height)), this.containerBox = s;\n    }\n    temporaryDisplay(t) {\n      let e = this.renderTo,\n        i;\n      if (t) for (; e && e.style;) e.hcOrigStyle && (nT(e, e.hcOrigStyle), delete e.hcOrigStyle), e.hcOrigDetached && (ny.body.removeChild(e), e.hcOrigDetached = !1), e = e.parentNode;else for (; e && e.style && (ny.body.contains(e) || e.parentNode || (e.hcOrigDetached = !0, ny.body.appendChild(e)), (\"none\" === nN(e, \"display\", !1) || e.hcOricDetached) && (e.hcOrigStyle = {\n        display: e.style.display,\n        height: e.style.height,\n        overflow: e.style.overflow\n      }, i = {\n        display: \"block\",\n        overflow: \"hidden\"\n      }, e !== this.renderTo && (i.height = 0), nT(e, i), e.offsetWidth || e.style.setProperty(\"display\", \"block\", \"important\")), (e = e.parentNode) !== ny.body););\n    }\n    setClassName(t) {\n      this.container.className = \"highcharts-container \" + (t || \"\");\n    }\n    getContainer() {\n      let t;\n      let e = this.options,\n        i = e.chart,\n        s = \"data-highcharts-chart\",\n        o = nq(),\n        r = this.renderTo,\n        n = nj(nS(r, s));\n      nW(n) && nx[n] && nx[n].hasRendered && nx[n].destroy(), nS(r, s, this.index), r.innerHTML = t6.emptyHTML, i.skipClone || r.offsetWidth || this.temporaryDisplay(), this.getChartSize();\n      let a = this.chartHeight,\n        h = this.chartWidth;\n      nT(r, {\n        overflow: \"hidden\"\n      }), this.styledMode || (t = nB({\n        position: \"relative\",\n        overflow: \"hidden\",\n        width: h + \"px\",\n        height: a + \"px\",\n        textAlign: \"left\",\n        lineHeight: \"normal\",\n        zIndex: 0,\n        \"-webkit-tap-highlight-color\": \"rgba(0,0,0,0)\",\n        userSelect: \"none\",\n        \"touch-action\": \"manipulation\",\n        outline: \"none\",\n        padding: \"0px\"\n      }, i.style || {}));\n      let l = nA(\"div\", {\n        id: o\n      }, t, r);\n      this.container = l, this.getChartSize(), h === this.chartWidth || (h = this.chartWidth, this.styledMode || nT(l, {\n        width: nY(i.style?.width, h + \"px\")\n      })), this.containerBox = this.getContainerBox(), this._cursor = l.style.cursor;\n      let d = i.renderer || !nv ? eu.getRendererType(i.renderer) : iU;\n      if (this.renderer = new d(l, h, a, void 0, i.forExport, e.exporting && e.exporting.allowHTML, this.styledMode), nu(void 0, this), this.setClassName(i.className), this.styledMode) for (let t in e.defs) this.renderer.definition(e.defs[t]);else this.renderer.setStyle(i.style);\n      this.renderer.chartIndex = this.index, nD(this, \"afterGetContainer\");\n    }\n    getMargins(t) {\n      let {\n        spacing: e,\n        margin: i,\n        titleOffset: s\n      } = this;\n      this.resetMargins(), s[0] && !nP(i[0]) && (this.plotTop = Math.max(this.plotTop, s[0] + e[0])), s[2] && !nP(i[2]) && (this.marginBottom = Math.max(this.marginBottom, s[2] + e[2])), this.legend && this.legend.display && this.legend.adjustMargins(i, e), nD(this, \"getMargins\"), t || this.getAxisMargins();\n    }\n    getAxisMargins() {\n      let t = this,\n        e = t.axisOffset = [0, 0, 0, 0],\n        i = t.colorAxis,\n        s = t.margin,\n        o = function (t) {\n          t.forEach(function (t) {\n            t.visible && t.getOffset();\n          });\n        };\n      t.hasCartesianSeries ? o(t.axes) : i && i.length && o(i), nb.forEach(function (i, o) {\n        nP(s[o]) || (t[i] += e[o]);\n      }), t.setChartSize();\n    }\n    getOptions() {\n      return nC(this.userOptions, ng);\n    }\n    reflow(t) {\n      let e = this,\n        i = e.containerBox,\n        s = e.getContainerBox();\n      delete e.pointer?.chartPosition, !e.isPrinting && !e.isResizing && i && s.width && ((s.width !== i.width || s.height !== i.height) && (tt.clearTimeout(e.reflowTimeout), e.reflowTimeout = n_(function () {\n        e.container && e.setSize(void 0, void 0, !1);\n      }, t ? 100 : 0)), e.containerBox = s);\n    }\n    setReflow() {\n      let t = this,\n        e = e => {\n          t.options?.chart.reflow && t.hasLoaded && t.reflow(e);\n        };\n      if (\"function\" == typeof ResizeObserver) new ResizeObserver(e).observe(t.renderTo);else {\n        let t = nw(nM, \"resize\", e);\n        nw(this, \"destroy\", t);\n      }\n    }\n    setSize(t, e, i) {\n      let s = this,\n        o = s.renderer;\n      s.isResizing += 1, nu(i, s);\n      let r = o.globalAnimation;\n      s.oldChartHeight = s.chartHeight, s.oldChartWidth = s.chartWidth, void 0 !== t && (s.options.chart.width = t), void 0 !== e && (s.options.chart.height = e), s.getChartSize();\n      let {\n        chartWidth: n,\n        chartHeight: a,\n        scrollablePixelsX: h = 0,\n        scrollablePixelsY: l = 0\n      } = s;\n      (s.isDirtyBox || n !== s.oldChartWidth || a !== s.oldChartHeight) && (s.styledMode || (r ? nc : nT)(s.container, {\n        width: `${n + h}px`,\n        height: `${a + l}px`\n      }, r), s.setChartSize(!0), o.setSize(n, a, r), s.axes.forEach(function (t) {\n        t.isDirty = !0, t.setScale();\n      }), s.isDirtyLegend = !0, s.isDirtyBox = !0, s.layOutTitles(), s.getMargins(), s.redraw(r), s.oldChartHeight = void 0, nD(s, \"resize\"), setTimeout(() => {\n        s && nD(s, \"endResize\");\n      }, np(r).duration)), s.isResizing -= 1;\n    }\n    setChartSize(t) {\n      let e, i, s, o;\n      let {\n          chartHeight: r,\n          chartWidth: n,\n          inverted: a,\n          spacing: h,\n          renderer: l\n        } = this,\n        d = this.clipOffset,\n        c = Math[a ? \"floor\" : \"round\"];\n      this.plotLeft = e = Math.round(this.plotLeft), this.plotTop = i = Math.round(this.plotTop), this.plotWidth = s = Math.max(0, Math.round(n - e - this.marginRight)), this.plotHeight = o = Math.max(0, Math.round(r - i - this.marginBottom)), this.plotSizeX = a ? o : s, this.plotSizeY = a ? s : o, this.spacingBox = l.spacingBox = {\n        x: h[3],\n        y: h[0],\n        width: n - h[3] - h[1],\n        height: r - h[0] - h[2]\n      }, this.plotBox = l.plotBox = {\n        x: e,\n        y: i,\n        width: s,\n        height: o\n      }, d && (this.clipBox = {\n        x: c(d[3]),\n        y: c(d[0]),\n        width: c(this.plotSizeX - d[1] - d[3]),\n        height: c(this.plotSizeY - d[0] - d[2])\n      }), t || (this.axes.forEach(function (t) {\n        t.setAxisSize(), t.setAxisTranslation();\n      }), l.alignElements()), nD(this, \"afterSetChartSize\", {\n        skipAxes: t\n      });\n    }\n    resetMargins() {\n      nD(this, \"resetMargins\");\n      let t = this,\n        e = t.options.chart,\n        i = e.plotBorderWidth || 0,\n        s = i / 2;\n      [\"margin\", \"spacing\"].forEach(function (i) {\n        let s = e[i],\n          o = nG(s) ? s : [s, s, s, s];\n        [\"Top\", \"Right\", \"Bottom\", \"Left\"].forEach(function (s, r) {\n          t[i][r] = nY(e[i + s], o[r]);\n        });\n      }), nb.forEach(function (e, i) {\n        t[e] = nY(t.margin[i], t.spacing[i]);\n      }), t.axisOffset = [0, 0, 0, 0], t.clipOffset = [s, s, s, s], t.plotBorderWidth = i;\n    }\n    drawChartBox() {\n      let t = this.options.chart,\n        e = this.renderer,\n        i = this.chartWidth,\n        s = this.chartHeight,\n        o = this.styledMode,\n        r = this.plotBGImage,\n        n = t.backgroundColor,\n        a = t.plotBackgroundColor,\n        h = t.plotBackgroundImage,\n        l = this.plotLeft,\n        d = this.plotTop,\n        c = this.plotWidth,\n        p = this.plotHeight,\n        u = this.plotBox,\n        g = this.clipRect,\n        f = this.clipBox,\n        m = this.chartBackground,\n        x = this.plotBackground,\n        y = this.plotBorder,\n        b,\n        v,\n        M,\n        k = \"animate\";\n      m || (this.chartBackground = m = e.rect().addClass(\"highcharts-background\").add(), k = \"attr\"), o ? b = v = m.strokeWidth() : (v = (b = t.borderWidth || 0) + (t.shadow ? 8 : 0), M = {\n        fill: n || \"none\"\n      }, (b || m[\"stroke-width\"]) && (M.stroke = t.borderColor, M[\"stroke-width\"] = b), m.attr(M).shadow(t.shadow)), m[k]({\n        x: v / 2,\n        y: v / 2,\n        width: i - v - b % 2,\n        height: s - v - b % 2,\n        r: t.borderRadius\n      }), k = \"animate\", x || (k = \"attr\", this.plotBackground = x = e.rect().addClass(\"highcharts-plot-background\").add()), x[k](u), !o && (x.attr({\n        fill: a || \"none\"\n      }).shadow(t.plotShadow), h && (r ? (h !== r.attr(\"href\") && r.attr(\"href\", h), r.animate(u)) : this.plotBGImage = e.image(h, l, d, c, p).add())), g ? g.animate({\n        width: f.width,\n        height: f.height\n      }) : this.clipRect = e.clipRect(f), k = \"animate\", y || (k = \"attr\", this.plotBorder = y = e.rect().addClass(\"highcharts-plot-border\").attr({\n        zIndex: 1\n      }).add()), o || y.attr({\n        stroke: t.plotBorderColor,\n        \"stroke-width\": t.plotBorderWidth || 0,\n        fill: \"none\"\n      }), y[k](y.crisp({\n        x: l,\n        y: d,\n        width: c,\n        height: p\n      }, -y.strokeWidth())), this.isDirtyBox = !1, nD(this, \"afterDrawChartBox\");\n    }\n    propFromSeries() {\n      let t, e, i;\n      let s = this,\n        o = s.options.chart,\n        r = s.options.series;\n      [\"inverted\", \"angular\", \"polar\"].forEach(function (n) {\n        for (e = nk[o.type], i = o[n] || e && e.prototype[n], t = r && r.length; !i && t--;) (e = nk[r[t].type]) && e.prototype[n] && (i = !0);\n        s[n] = i;\n      });\n    }\n    linkSeries(t) {\n      let e = this,\n        i = e.series;\n      i.forEach(function (t) {\n        t.linkedSeries.length = 0;\n      }), i.forEach(function (t) {\n        let {\n          linkedTo: i\n        } = t.options;\n        if (nH(i)) {\n          let s;\n          (s = \":previous\" === i ? e.series[t.index - 1] : e.get(i)) && s.linkedParent !== t && (s.linkedSeries.push(t), t.linkedParent = s, s.enabledDataSorting && t.setDataSortingOptions(), t.visible = nY(t.options.visible, s.options.visible, t.visible));\n        }\n      }), nD(this, \"afterLinkSeries\", {\n        isUpdating: t\n      });\n    }\n    renderSeries() {\n      this.series.forEach(function (t) {\n        t.translate(), t.render();\n      });\n    }\n    render() {\n      let t = this.axes,\n        e = this.colorAxis,\n        i = this.renderer,\n        s = this.options.chart.axisLayoutRuns || 2,\n        o = t => {\n          t.forEach(t => {\n            t.visible && t.render();\n          });\n        },\n        r = 0,\n        n = !0,\n        a,\n        h = 0;\n      for (let e of (this.setTitle(), nD(this, \"beforeMargins\"), this.getStacks?.(), this.getMargins(!0), this.setChartSize(), t)) {\n        let {\n            options: t\n          } = e,\n          {\n            labels: i\n          } = t;\n        if (this.hasCartesianSeries && e.horiz && e.visible && i.enabled && e.series.length && \"colorAxis\" !== e.coll && !this.polar) {\n          r = t.tickLength, e.createGroups();\n          let s = new sg(e, 0, \"\", !0),\n            o = s.createLabel(\"x\", i);\n          if (s.destroy(), o && nY(i.reserveSpace, !nW(t.crossing)) && (r = o.getBBox().height + i.distance + Math.max(t.offset || 0, 0)), r) {\n            o?.destroy();\n            break;\n          }\n        }\n      }\n      for (this.plotHeight = Math.max(this.plotHeight - r, 0); (n || a || s > 1) && h < s;) {\n        let e = this.plotWidth,\n          i = this.plotHeight;\n        for (let e of t) 0 === h ? e.setScale() : (e.horiz && n || !e.horiz && a) && e.setTickInterval(!0);\n        0 === h ? this.getAxisMargins() : this.getMargins(), n = e / this.plotWidth > (h ? 1 : 1.1), a = i / this.plotHeight > (h ? 1 : 1.05), h++;\n      }\n      this.drawChartBox(), this.hasCartesianSeries ? o(t) : e && e.length && o(e), this.seriesGroup || (this.seriesGroup = i.g(\"series-group\").attr({\n        zIndex: 3\n      }).shadow(this.options.chart.seriesGroupShadow).add()), this.renderSeries(), this.addCredits(), this.setResponsive && this.setResponsive(), this.hasRendered = !0;\n    }\n    addCredits(t) {\n      let e = this,\n        i = nF(!0, this.options.credits, t);\n      i.enabled && !this.credits && (this.credits = this.renderer.text(i.text + (this.mapCredits || \"\"), 0, 0).addClass(\"highcharts-credits\").on(\"click\", function () {\n        i.href && (nM.location.href = i.href);\n      }).attr({\n        align: i.position.align,\n        zIndex: 8\n      }), e.styledMode || this.credits.css(i.style), this.credits.add().align(i.position), this.credits.update = function (t) {\n        e.credits = e.credits.destroy(), e.addCredits(t);\n      });\n    }\n    destroy() {\n      let t;\n      let e = this,\n        i = e.axes,\n        s = e.series,\n        o = e.container,\n        r = o && o.parentNode;\n      for (nD(e, \"destroy\"), e.renderer.forExport ? nE(nx, e) : nx[e.index] = void 0, O.chartCount--, e.renderTo.removeAttribute(\"data-highcharts-chart\"), nV(e), t = i.length; t--;) i[t] = i[t].destroy();\n      for (this.scroller && this.scroller.destroy && this.scroller.destroy(), t = s.length; t--;) s[t] = s[t].destroy();\n      [\"title\", \"subtitle\", \"chartBackground\", \"plotBackground\", \"plotBGImage\", \"plotBorder\", \"seriesGroup\", \"clipRect\", \"credits\", \"pointer\", \"rangeSelector\", \"legend\", \"resetZoomButton\", \"tooltip\", \"renderer\"].forEach(function (t) {\n        let i = e[t];\n        i && i.destroy && (e[t] = i.destroy());\n      }), o && (o.innerHTML = t6.emptyHTML, nV(o), r && nO(o)), nX(e, function (t, i) {\n        delete e[i];\n      });\n    }\n    firstRender() {\n      let t = this,\n        e = t.options;\n      t.getContainer(), t.resetMargins(), t.setChartSize(), t.propFromSeries(), t.createAxes();\n      let i = nz(e.series) ? e.series : [];\n      e.series = [], i.forEach(function (e) {\n        t.initSeries(e);\n      }), t.linkSeries(), t.setSortedData(), nD(t, \"beforeRender\"), t.render(), t.pointer?.getChartPosition(), t.renderer.imgCount || t.hasLoaded || t.onload(), t.temporaryDisplay(!0);\n    }\n    onload() {\n      this.callbacks.concat([this.callback]).forEach(function (t) {\n        t && void 0 !== this.index && t.apply(this, [this]);\n      }, this), nD(this, \"load\"), nD(this, \"render\"), nP(this.index) && this.setReflow(), this.warnIfA11yModuleNotLoaded(), this.hasLoaded = !0;\n    }\n    warnIfA11yModuleNotLoaded() {\n      let {\n        options: t,\n        title: e\n      } = this;\n      !t || this.accessibility || (this.renderer.boxWrapper.attr({\n        role: \"img\",\n        \"aria-label\": (e && e.element.textContent || \"\").replace(/</g, \"&lt;\")\n      }), t.accessibility && !1 === t.accessibility.enabled || nL('Highcharts warning: Consider including the \"accessibility.js\" module to make your chart more usable for people with disabilities. Set the \"accessibility.enabled\" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', !1, this));\n    }\n    addSeries(t, e, i) {\n      let s;\n      let o = this;\n      return t && (e = nY(e, !0), nD(o, \"addSeries\", {\n        options: t\n      }, function () {\n        s = o.initSeries(t), o.isDirtyLegend = !0, o.linkSeries(), s.enabledDataSorting && s.setData(t.data, !1), nD(o, \"afterAddSeries\", {\n          series: s\n        }), e && o.redraw(i);\n      })), s;\n    }\n    addAxis(t, e, i, s) {\n      return this.createAxis(e ? \"xAxis\" : \"yAxis\", {\n        axis: t,\n        redraw: i,\n        animation: s\n      });\n    }\n    addColorAxis(t, e, i) {\n      return this.createAxis(\"colorAxis\", {\n        axis: t,\n        redraw: e,\n        animation: i\n      });\n    }\n    createAxis(t, e) {\n      let i = new sU(this, e.axis, t);\n      return nY(e.redraw, !0) && this.redraw(e.animation), i;\n    }\n    showLoading(t) {\n      let e = this,\n        i = e.options,\n        s = i.loading,\n        o = function () {\n          r && nT(r, {\n            left: e.plotLeft + \"px\",\n            top: e.plotTop + \"px\",\n            width: e.plotWidth + \"px\",\n            height: e.plotHeight + \"px\"\n          });\n        },\n        r = e.loadingDiv,\n        n = e.loadingSpan;\n      r || (e.loadingDiv = r = nA(\"div\", {\n        className: \"highcharts-loading highcharts-loading-hidden\"\n      }, null, e.container)), n || (e.loadingSpan = n = nA(\"span\", {\n        className: \"highcharts-loading-inner\"\n      }, null, r), nw(e, \"redraw\", o)), r.className = \"highcharts-loading\", t6.setElementHTML(n, nY(t, i.lang.loading, \"\")), e.styledMode || (nT(r, nB(s.style, {\n        zIndex: 10\n      })), nT(n, s.labelStyle), e.loadingShown || (nT(r, {\n        opacity: 0,\n        display: \"\"\n      }), nc(r, {\n        opacity: s.style.opacity || .5\n      }, {\n        duration: s.showDuration || 0\n      }))), e.loadingShown = !0, o();\n    }\n    hideLoading() {\n      let t = this.options,\n        e = this.loadingDiv;\n      e && (e.className = \"highcharts-loading highcharts-loading-hidden\", this.styledMode || nc(e, {\n        opacity: 0\n      }, {\n        duration: t.loading.hideDuration || 100,\n        complete: function () {\n          nT(e, {\n            display: \"none\"\n          });\n        }\n      })), this.loadingShown = !1;\n    }\n    update(t, e, i, s) {\n      let o, r, n;\n      let a = this,\n        h = {\n          credits: \"addCredits\",\n          title: \"setTitle\",\n          subtitle: \"setSubtitle\",\n          caption: \"setCaption\"\n        },\n        l = t.isResponsiveOptions,\n        d = [];\n      nD(a, \"update\", {\n        options: t\n      }), l || a.setResponsive(!1, !0), t = nC(t, a.options), a.userOptions = nF(a.userOptions, t);\n      let c = t.chart;\n      c && (nF(!0, a.options.chart, c), this.setZoomOptions(), \"className\" in c && a.setClassName(c.className), (\"inverted\" in c || \"polar\" in c || \"type\" in c) && (a.propFromSeries(), o = !0), \"alignTicks\" in c && (o = !0), \"events\" in c && nm(this, c), nX(c, function (t, e) {\n        -1 !== a.propsRequireUpdateSeries.indexOf(\"chart.\" + e) && (r = !0), -1 !== a.propsRequireDirtyBox.indexOf(e) && (a.isDirtyBox = !0), -1 === a.propsRequireReflow.indexOf(e) || (a.isDirtyBox = !0, l || (n = !0));\n      }), !a.styledMode && c.style && a.renderer.setStyle(a.options.chart.style || {})), !a.styledMode && t.colors && (this.options.colors = t.colors), nX(t, function (e, i) {\n        a[i] && \"function\" == typeof a[i].update ? a[i].update(e, !1) : \"function\" == typeof a[h[i]] ? a[h[i]](e) : \"colors\" !== i && -1 === a.collectionsWithUpdate.indexOf(i) && nF(!0, a.options[i], t[i]), \"chart\" !== i && -1 !== a.propsRequireUpdateSeries.indexOf(i) && (r = !0);\n      }), this.collectionsWithUpdate.forEach(function (e) {\n        t[e] && (n$(t[e]).forEach(function (t, s) {\n          let o;\n          let r = nP(t.id);\n          r && (o = a.get(t.id)), !o && a[e] && (o = a[e][nY(t.index, s)]) && (r && nP(o.options.id) || o.options.isInternal) && (o = void 0), o && o.coll === e && (o.update(t, !1), i && (o.touched = !0)), !o && i && a.collectionsWithInit[e] && (a.collectionsWithInit[e][0].apply(a, [t].concat(a.collectionsWithInit[e][1] || []).concat([!1])).touched = !0);\n        }), i && a[e].forEach(function (t) {\n          t.touched || t.options.isInternal ? delete t.touched : d.push(t);\n        }));\n      }), d.forEach(function (t) {\n        t.chart && t.remove && t.remove(!1);\n      }), o && a.axes.forEach(function (t) {\n        t.update({}, !1);\n      }), r && a.getSeriesOrderByLinks().forEach(function (t) {\n        t.chart && t.update({}, !1);\n      }, this);\n      let p = c && c.width,\n        u = c && (nH(c.height) ? nU(c.height, p || a.chartWidth) : c.height);\n      n || nW(p) && p !== a.chartWidth || nW(u) && u !== a.chartHeight ? a.setSize(p, u, s) : nY(e, !0) && a.redraw(s), nD(a, \"afterUpdate\", {\n        options: t,\n        redraw: e,\n        animation: s\n      });\n    }\n    setSubtitle(t, e) {\n      this.applyDescription(\"subtitle\", t), this.layOutTitles(e);\n    }\n    setCaption(t, e) {\n      this.applyDescription(\"caption\", t), this.layOutTitles(e);\n    }\n    showResetZoom() {\n      let t = this,\n        e = ng.lang,\n        i = t.zooming.resetButton,\n        s = i.theme,\n        o = \"chart\" === i.relativeTo || \"spacingBox\" === i.relativeTo ? null : \"plotBox\";\n      function r() {\n        t.zoomOut();\n      }\n      nD(this, \"beforeShowResetZoom\", null, function () {\n        t.resetZoomButton = t.renderer.button(e.resetZoom, null, null, r, s).attr({\n          align: i.position.align,\n          title: e.resetZoomTitle\n        }).addClass(\"highcharts-reset-zoom\").add().align(i.position, !1, o);\n      }), nD(this, \"afterShowResetZoom\");\n    }\n    zoomOut() {\n      nD(this, \"selection\", {\n        resetSelection: !0\n      }, () => this.transform({\n        reset: !0,\n        trigger: \"zoom\"\n      }));\n    }\n    pan(t, e) {\n      let i = this,\n        s = \"object\" == typeof e ? e : {\n          enabled: e,\n          type: \"x\"\n        },\n        o = s.type,\n        r = o && i[{\n          x: \"xAxis\",\n          xy: \"axes\",\n          y: \"yAxis\"\n        }[o]].filter(t => t.options.panningEnabled && !t.options.isInternal),\n        n = i.options.chart;\n      n?.panning && (n.panning = s), nD(this, \"pan\", {\n        originalEvent: t\n      }, () => {\n        i.transform({\n          axes: r,\n          event: t,\n          to: {\n            x: t.chartX - (i.mouseDownX || 0),\n            y: t.chartY - (i.mouseDownY || 0)\n          },\n          trigger: \"pan\"\n        }), nT(i.container, {\n          cursor: \"move\"\n        });\n      });\n    }\n    transform(t) {\n      let {\n          axes: e = this.axes,\n          event: i,\n          from: s = {},\n          reset: o,\n          selection: r,\n          to: n = {},\n          trigger: a\n        } = t,\n        {\n          inverted: h,\n          time: l\n        } = this,\n        d = !1,\n        c,\n        p;\n      for (let t of (this.hoverPoints?.forEach(t => t.setState()), e)) {\n        let {\n            horiz: e,\n            len: u,\n            minPointOffset: g = 0,\n            options: f,\n            reversed: m\n          } = t,\n          x = e ? \"width\" : \"height\",\n          y = e ? \"x\" : \"y\",\n          b = nY(n[x], t.len),\n          v = nY(s[x], t.len),\n          M = 10 > Math.abs(b) ? 1 : b / v,\n          k = (s[y] || 0) + v / 2 - t.pos,\n          w = k - ((n[y] ?? t.pos) + b / 2 - t.pos) / M,\n          S = m && !h || !m && h ? -1 : 1;\n        if (!o && (k < 0 || k > t.len)) continue;\n        let A = t.toValue(w, !0) + (r || t.isOrdinal ? 0 : g * S),\n          T = t.toValue(w + u / M, !0) - (r || t.isOrdinal ? 0 : g * S || 0),\n          P = t.allExtremes;\n        if (A > T && ([A, T] = [T, A]), 1 === M && !o && \"yAxis\" === t.coll && !P) {\n          for (let e of t.series) {\n            let t = e.getExtremes(e.getProcessedData(!0).modified.getColumn(\"y\") || [], !0);\n            P ?? (P = {\n              dataMin: Number.MAX_VALUE,\n              dataMax: -Number.MAX_VALUE\n            }), nW(t.dataMin) && nW(t.dataMax) && (P.dataMin = Math.min(t.dataMin, P.dataMin), P.dataMax = Math.max(t.dataMax, P.dataMax));\n          }\n          t.allExtremes = P;\n        }\n        let {\n            dataMin: C,\n            dataMax: O,\n            min: E,\n            max: L\n          } = nB(t.getExtremes(), P || {}),\n          B = l.parse(f.min),\n          I = l.parse(f.max),\n          D = C ?? B,\n          R = O ?? I,\n          N = T - A,\n          z = t.categories ? 0 : Math.min(N, R - D),\n          W = D - z * (nP(B) ? 0 : f.minPadding),\n          G = R + z * (nP(I) ? 0 : f.maxPadding),\n          H = t.allowZoomOutside || 1 === M || \"zoom\" !== a && M > 1,\n          F = Math.min(B ?? W, W, H ? E : W),\n          X = Math.max(I ?? G, G, H ? L : G);\n        (!t.isOrdinal || t.options.overscroll || 1 !== M || o) && (A < F && (A = F, M >= 1 && (T = A + N)), T > X && (T = X, M >= 1 && (A = T - N)), (o || t.series.length && (A !== E || T !== L) && A >= F && T <= X) && (r ? r[t.coll].push({\n          axis: t,\n          min: A,\n          max: T\n        }) : (t.isPanning = \"zoom\" !== a, t.isPanning && (p = !0), t.setExtremes(o ? void 0 : A, o ? void 0 : T, !1, !1, {\n          move: w,\n          trigger: a,\n          scale: M\n        }), !o && (A > F || T < X) && \"mousewheel\" !== a && (c = !0)), d = !0), i && (this[e ? \"mouseDownX\" : \"mouseDownY\"] = i[e ? \"chartX\" : \"chartY\"]));\n      }\n      return d && (r ? nD(this, \"selection\", r, () => {\n        delete t.selection, t.trigger = \"zoom\", this.transform(t);\n      }) : (!c || p || this.resetZoomButton ? !c && this.resetZoomButton && (this.resetZoomButton = this.resetZoomButton.destroy()) : this.showResetZoom(), this.redraw(\"zoom\" === a && (this.options.chart.animation ?? this.pointCount < 100)))), d;\n    }\n  }\n  nB(nZ.prototype, {\n    callbacks: [],\n    collectionsWithInit: {\n      xAxis: [nZ.prototype.addAxis, [!0]],\n      yAxis: [nZ.prototype.addAxis, [!1]],\n      series: [nZ.prototype.addSeries]\n    },\n    collectionsWithUpdate: [\"xAxis\", \"yAxis\", \"series\"],\n    propsRequireDirtyBox: [\"backgroundColor\", \"borderColor\", \"borderWidth\", \"borderRadius\", \"plotBackgroundColor\", \"plotBackgroundImage\", \"plotBorderColor\", \"plotBorderWidth\", \"plotShadow\", \"shadow\"],\n    propsRequireReflow: [\"margin\", \"marginTop\", \"marginRight\", \"marginBottom\", \"marginLeft\", \"spacing\", \"spacingTop\", \"spacingRight\", \"spacingBottom\", \"spacingLeft\"],\n    propsRequireUpdateSeries: [\"chart.inverted\", \"chart.polar\", \"chart.ignoreHiddenSeries\", \"chart.type\", \"colors\", \"plotOptions\", \"time\", \"tooltip\"]\n  });\n  let nK = nZ,\n    {\n      stop: nJ\n    } = tU,\n    {\n      composed: nQ\n    } = O,\n    {\n      addEvent: n0,\n      createElement: n1,\n      css: n2,\n      defined: n3,\n      erase: n5,\n      merge: n6,\n      pushUnique: n9\n    } = tt;\n  function n4() {\n    let t = this.scrollablePlotArea;\n    (this.scrollablePixelsX || this.scrollablePixelsY) && !t && (this.scrollablePlotArea = t = new n7(this)), t?.applyFixed();\n  }\n  function n8() {\n    this.chart.scrollablePlotArea && (this.chart.scrollablePlotArea.isDirty = !0);\n  }\n  let n7 = /*#__PURE__*/(() => {\n    class n7 {\n      static compose(t, e, i) {\n        n9(nQ, this.compose) && (n0(t, \"afterInit\", n8), n0(e, \"afterSetChartSize\", t => this.afterSetSize(t.target, t)), n0(e, \"render\", n4), n0(i, \"show\", n8));\n      }\n      static afterSetSize(t, e) {\n        let i, s, o;\n        let {\n            minWidth: r,\n            minHeight: n\n          } = t.options.chart.scrollablePlotArea || {},\n          {\n            clipBox: a,\n            plotBox: h,\n            inverted: l,\n            renderer: d\n          } = t;\n        if (!d.forExport && (r ? (t.scrollablePixelsX = i = Math.max(0, r - t.chartWidth), i && (t.scrollablePlotBox = n6(t.plotBox), h.width = t.plotWidth += i, a[l ? \"height\" : \"width\"] += i, o = !0)) : n && (t.scrollablePixelsY = s = Math.max(0, n - t.chartHeight), n3(s) && (t.scrollablePlotBox = n6(t.plotBox), h.height = t.plotHeight += s, a[l ? \"width\" : \"height\"] += s, o = !1)), n3(o) && !e.skipAxes)) for (let e of t.axes) (e.horiz === o || t.hasParallelCoordinates && \"yAxis\" === e.coll) && (e.setAxisSize(), e.setAxisTranslation());\n      }\n      constructor(t) {\n        let e;\n        let i = t.options.chart,\n          s = eu.getRendererType(),\n          o = i.scrollablePlotArea || {},\n          r = this.moveFixedElements.bind(this),\n          n = {\n            WebkitOverflowScrolling: \"touch\",\n            overflowX: \"hidden\",\n            overflowY: \"hidden\"\n          };\n        t.scrollablePixelsX && (n.overflowX = \"auto\"), t.scrollablePixelsY && (n.overflowY = \"auto\"), this.chart = t;\n        let a = this.parentDiv = n1(\"div\", {\n            className: \"highcharts-scrolling-parent\"\n          }, {\n            position: \"relative\"\n          }, t.renderTo),\n          h = this.scrollingContainer = n1(\"div\", {\n            className: \"highcharts-scrolling\"\n          }, n, a),\n          l = this.innerContainer = n1(\"div\", {\n            className: \"highcharts-inner-container\"\n          }, void 0, h),\n          d = this.fixedDiv = n1(\"div\", {\n            className: \"highcharts-fixed\"\n          }, {\n            position: \"absolute\",\n            overflow: \"hidden\",\n            pointerEvents: \"none\",\n            zIndex: (i.style?.zIndex || 0) + 2,\n            top: 0\n          }, void 0, !0),\n          c = this.fixedRenderer = new s(d, t.chartWidth, t.chartHeight, i.style);\n        this.mask = c.path().attr({\n          fill: i.backgroundColor || \"#fff\",\n          \"fill-opacity\": o.opacity ?? .85,\n          zIndex: -1\n        }).addClass(\"highcharts-scrollable-mask\").add(), h.parentNode.insertBefore(d, h), n2(t.renderTo, {\n          overflow: \"visible\"\n        }), n0(t, \"afterShowResetZoom\", r), n0(t, \"afterApplyDrilldown\", r), n0(t, \"afterLayOutTitles\", r), n0(h, \"scroll\", () => {\n          let {\n            pointer: i,\n            hoverPoint: s\n          } = t;\n          i && (delete i.chartPosition, s && (e = s), i.runPointActions(void 0, e, !0));\n        }), l.appendChild(t.container);\n      }\n      applyFixed() {\n        let {\n            chart: t,\n            fixedRenderer: e,\n            isDirty: i,\n            scrollingContainer: s\n          } = this,\n          {\n            axisOffset: o,\n            chartWidth: r,\n            chartHeight: n,\n            container: a,\n            plotHeight: h,\n            plotLeft: l,\n            plotTop: d,\n            plotWidth: c,\n            scrollablePixelsX: p = 0,\n            scrollablePixelsY: u = 0\n          } = t,\n          {\n            scrollPositionX: g = 0,\n            scrollPositionY: f = 0\n          } = t.options.chart.scrollablePlotArea || {},\n          m = r + p,\n          x = n + u;\n        e.setSize(r, n), (i ?? !0) && (this.isDirty = !1, this.moveFixedElements()), nJ(t.container), n2(a, {\n          width: `${m}px`,\n          height: `${x}px`\n        }), t.renderer.boxWrapper.attr({\n          width: m,\n          height: x,\n          viewBox: [0, 0, m, x].join(\" \")\n        }), t.chartBackground?.attr({\n          width: m,\n          height: x\n        }), n2(s, {\n          width: `${r}px`,\n          height: `${n}px`\n        }), n3(i) || (s.scrollLeft = p * g, s.scrollTop = u * f);\n        let y = d - o[0] - 1,\n          b = l - o[3] - 1,\n          v = d + h + o[2] + 1,\n          M = l + c + o[1] + 1,\n          k = l + c - p,\n          w = d + h - u,\n          S = [[\"M\", 0, 0]];\n        p ? S = [[\"M\", 0, y], [\"L\", l - 1, y], [\"L\", l - 1, v], [\"L\", 0, v], [\"Z\"], [\"M\", k, y], [\"L\", r, y], [\"L\", r, v], [\"L\", k, v], [\"Z\"]] : u && (S = [[\"M\", b, 0], [\"L\", b, d - 1], [\"L\", M, d - 1], [\"L\", M, 0], [\"Z\"], [\"M\", b, w], [\"L\", b, n], [\"L\", M, n], [\"L\", M, w], [\"Z\"]]), \"adjustHeight\" !== t.redrawTrigger && this.mask.attr({\n          d: S\n        });\n      }\n      moveFixedElements() {\n        let t;\n        let {\n            container: e,\n            inverted: i,\n            scrollablePixelsX: s,\n            scrollablePixelsY: o\n          } = this.chart,\n          r = this.fixedRenderer,\n          n = n7.fixedSelectors;\n        if (s && !i ? t = \".highcharts-yaxis\" : s && i ? t = \".highcharts-xaxis\" : o && !i ? t = \".highcharts-xaxis\" : o && i && (t = \".highcharts-yaxis\"), t && !(this.chart.hasParallelCoordinates && \".highcharts-yaxis\" === t)) for (let e of [`${t}:not(.highcharts-radial-axis)`, `${t}-labels:not(.highcharts-radial-axis-labels)`]) n9(n, e);else for (let t of [\".highcharts-xaxis\", \".highcharts-yaxis\"]) for (let e of [`${t}:not(.highcharts-radial-axis)`, `${t}-labels:not(.highcharts-radial-axis-labels)`]) n5(n, e);\n        for (let t of n) [].forEach.call(e.querySelectorAll(t), t => {\n          (t.namespaceURI === r.SVG_NS ? r.box : r.box.parentNode).appendChild(t), t.style.pointerEvents = \"auto\";\n        });\n      }\n    }\n    n7.fixedSelectors = [\".highcharts-breadcrumbs-group\", \".highcharts-contextbutton\", \".highcharts-caption\", \".highcharts-credits\", \".highcharts-drillup-button\", \".highcharts-legend\", \".highcharts-legend-checkbox\", \".highcharts-navigator-series\", \".highcharts-navigator-xaxis\", \".highcharts-navigator-yaxis\", \".highcharts-navigator\", \".highcharts-range-selector-group\", \".highcharts-reset-zoom\", \".highcharts-scrollbar\", \".highcharts-subtitle\", \".highcharts-title\"];\n    return n7;\n  })();\n  let {\n      format: at\n    } = ep,\n    {\n      series: ae\n    } = ry,\n    {\n      destroyObjectProperties: ai,\n      fireEvent: as,\n      getAlignFactor: ao,\n      isNumber: ar,\n      pick: an\n    } = tt,\n    aa = class {\n      constructor(t, e, i, s, o) {\n        let r = t.chart.inverted,\n          n = t.reversed;\n        this.axis = t;\n        let a = this.isNegative = !!i != !!n;\n        this.options = e = e || {}, this.x = s, this.total = null, this.cumulative = null, this.points = {}, this.hasValidPoints = !1, this.stack = o, this.leftCliff = 0, this.rightCliff = 0, this.alignOptions = {\n          align: e.align || (r ? a ? \"left\" : \"right\" : \"center\"),\n          verticalAlign: e.verticalAlign || (r ? \"middle\" : a ? \"bottom\" : \"top\"),\n          y: e.y,\n          x: e.x\n        }, this.textAlign = e.textAlign || (r ? a ? \"right\" : \"left\" : \"center\");\n      }\n      destroy() {\n        ai(this, this.axis);\n      }\n      render(t) {\n        let e = this.axis.chart,\n          i = this.options,\n          s = i.format,\n          o = s ? at(s, this, e) : i.formatter.call(this);\n        if (this.label) this.label.attr({\n          text: o,\n          visibility: \"hidden\"\n        });else {\n          this.label = e.renderer.label(o, null, void 0, i.shape, void 0, void 0, i.useHTML, !1, \"stack-labels\");\n          let s = {\n            r: i.borderRadius || 0,\n            text: o,\n            padding: an(i.padding, 5),\n            visibility: \"hidden\"\n          };\n          e.styledMode || (s.fill = i.backgroundColor, s.stroke = i.borderColor, s[\"stroke-width\"] = i.borderWidth, this.label.css(i.style || {})), this.label.attr(s), this.label.added || this.label.add(t);\n        }\n        this.label.labelrank = e.plotSizeY, as(this, \"afterRender\");\n      }\n      setOffset(t, e, i, s, o, r) {\n        let {\n            alignOptions: n,\n            axis: a,\n            label: h,\n            options: l,\n            textAlign: d\n          } = this,\n          c = a.chart,\n          p = this.getStackBox({\n            xOffset: t,\n            width: e,\n            boxBottom: i,\n            boxTop: s,\n            defaultX: o,\n            xAxis: r\n          }),\n          {\n            verticalAlign: u\n          } = n;\n        if (h && p) {\n          let t = h.getBBox(void 0, 0),\n            e = h.padding,\n            i = \"justify\" === an(l.overflow, \"justify\"),\n            s;\n          n.x = l.x || 0, n.y = l.y || 0;\n          let {\n            x: o,\n            y: r\n          } = this.adjustStackPosition({\n            labelBox: t,\n            verticalAlign: u,\n            textAlign: d\n          });\n          p.x -= o, p.y -= r, h.align(n, !1, p), (s = c.isInsidePlot(h.alignAttr.x + n.x + o, h.alignAttr.y + n.y + r)) || (i = !1), i && ae.prototype.justifyDataLabel.call(a, h, n, h.alignAttr, t, p), h.attr({\n            x: h.alignAttr.x,\n            y: h.alignAttr.y,\n            rotation: l.rotation,\n            rotationOriginX: t.width * ao(l.textAlign || \"center\"),\n            rotationOriginY: t.height / 2\n          }), an(!i && l.crop, !0) && (s = ar(h.x) && ar(h.y) && c.isInsidePlot(h.x - e + (h.width || 0), h.y) && c.isInsidePlot(h.x + e, h.y)), h[s ? \"show\" : \"hide\"]();\n        }\n        as(this, \"afterSetOffset\", {\n          xOffset: t,\n          width: e\n        });\n      }\n      adjustStackPosition({\n        labelBox: t,\n        verticalAlign: e,\n        textAlign: i\n      }) {\n        return {\n          x: t.width / 2 + t.width / 2 * (2 * ao(i) - 1),\n          y: t.height / 2 * 2 * (1 - ao(e))\n        };\n      }\n      getStackBox(t) {\n        let e = this.axis,\n          i = e.chart,\n          {\n            boxTop: s,\n            defaultX: o,\n            xOffset: r,\n            width: n,\n            boxBottom: a\n          } = t,\n          h = e.stacking.usePercentage ? 100 : an(s, this.total, 0),\n          l = e.toPixels(h),\n          d = t.xAxis || i.xAxis[0],\n          c = an(o, d.translate(this.x)) + r,\n          p = Math.abs(l - e.toPixels(a || ar(e.min) && e.logarithmic && e.logarithmic.lin2log(e.min) || 0)),\n          u = i.inverted,\n          g = this.isNegative;\n        return u ? {\n          x: (g ? l : l - p) - i.plotLeft,\n          y: d.height - c - n + d.top - i.plotTop,\n          width: p,\n          height: n\n        } : {\n          x: c + d.transB - i.plotLeft,\n          y: (g ? l - p : l) - i.plotTop,\n          width: n,\n          height: p\n        };\n      }\n    },\n    {\n      getDeferredAnimation: ah\n    } = tU,\n    {\n      series: {\n        prototype: al\n      }\n    } = ry,\n    {\n      addEvent: ad,\n      correctFloat: ac,\n      defined: ap,\n      destroyObjectProperties: au,\n      fireEvent: ag,\n      isNumber: af,\n      objectEach: am,\n      pick: ax\n    } = tt;\n  function ay() {\n    let t = this.inverted;\n    this.axes.forEach(t => {\n      t.stacking && t.stacking.stacks && t.hasVisibleSeries && (t.stacking.oldStacks = t.stacking.stacks);\n    }), this.series.forEach(e => {\n      let i = e.xAxis && e.xAxis.options || {};\n      e.options.stacking && e.reserveSpace() && (e.stackKey = [e.type, ax(e.options.stack, \"\"), t ? i.top : i.left, t ? i.height : i.width].join(\",\"));\n    });\n  }\n  function ab() {\n    let t = this.stacking;\n    if (t) {\n      let e = t.stacks;\n      am(e, (t, i) => {\n        au(t), delete e[i];\n      }), t.stackTotalGroup?.destroy();\n    }\n  }\n  function av() {\n    this.stacking || (this.stacking = new aT(this));\n  }\n  function aM(t, e, i, s) {\n    return !ap(t) || t.x !== e || s && t.stackKey !== s ? t = {\n      x: e,\n      index: 0,\n      key: s,\n      stackKey: s\n    } : t.index++, t.key = [i, e, t.index].join(\",\"), t;\n  }\n  function ak() {\n    let t;\n    let e = this,\n      i = e.yAxis,\n      s = e.stackKey || \"\",\n      o = i.stacking.stacks,\n      r = e.getColumn(\"x\", !0),\n      n = e.options.stacking,\n      a = e[n + \"Stacker\"];\n    a && [s, \"-\" + s].forEach(i => {\n      let s = r.length,\n        n,\n        h,\n        l;\n      for (; s--;) n = r[s], t = e.getStackIndicator(t, n, e.index, i), h = o[i]?.[n], (l = h?.points[t.key || \"\"]) && a.call(e, l, h, s);\n    });\n  }\n  function aw(t, e, i) {\n    let s = e.total ? 100 / e.total : 0;\n    t[0] = ac(t[0] * s), t[1] = ac(t[1] * s), this.stackedYData[i] = t[1];\n  }\n  function aS(t) {\n    (this.is(\"column\") || this.is(\"columnrange\")) && (this.options.centerInCategory && this.chart.series.length > 1 ? al.setStackedPoints.call(this, t, \"group\") : t.stacking.resetStacks());\n  }\n  function aA(t, e) {\n    let i, s, o, r, n, a, h;\n    let l = e || this.options.stacking;\n    if (!l || !this.reserveSpace() || ({\n      group: \"xAxis\"\n    }[l] || \"yAxis\") !== t.coll) return;\n    let d = this.getColumn(\"x\", !0),\n      c = this.getColumn(this.pointValKey || \"y\", !0),\n      p = [],\n      u = c.length,\n      g = this.options,\n      f = g.threshold || 0,\n      m = g.startFromThreshold ? f : 0,\n      x = g.stack,\n      y = e ? `${this.type},${l}` : this.stackKey || \"\",\n      b = \"-\" + y,\n      v = this.negStacks,\n      M = t.stacking,\n      k = M.stacks,\n      w = M.oldStacks;\n    for (M.stacksTouched += 1, h = 0; h < u; h++) {\n      let e = d[h] || 0,\n        u = c[h],\n        g = af(u) && u || 0;\n      a = (i = this.getStackIndicator(i, e, this.index)).key || \"\", k[n = (s = v && g < (m ? 0 : f)) ? b : y] || (k[n] = {}), k[n][e] || (w[n]?.[e] ? (k[n][e] = w[n][e], k[n][e].total = null) : k[n][e] = new aa(t, t.options.stackLabels, !!s, e, x)), o = k[n][e], null !== u ? (o.points[a] = o.points[this.index] = [ax(o.cumulative, m)], ap(o.cumulative) || (o.base = a), o.touched = M.stacksTouched, i.index > 0 && !1 === this.singleStacks && (o.points[a][0] = o.points[this.index + \",\" + e + \",0\"][0])) : (delete o.points[a], delete o.points[this.index]);\n      let S = o.total || 0;\n      \"percent\" === l ? (r = s ? y : b, S = v && k[r]?.[e] ? (r = k[r][e]).total = Math.max(r.total || 0, S) + Math.abs(g) : ac(S + Math.abs(g))) : \"group\" === l ? af(u) && S++ : S = ac(S + g), \"group\" === l ? o.cumulative = (S || 1) - 1 : o.cumulative = ac(ax(o.cumulative, m) + g), o.total = S, null !== u && (o.points[a].push(o.cumulative), p[h] = o.cumulative, o.hasValidPoints = !0);\n    }\n    \"percent\" === l && (M.usePercentage = !0), \"group\" !== l && (this.stackedYData = p), M.oldStacks = {};\n  }\n  class aT {\n    constructor(t) {\n      this.oldStacks = {}, this.stacks = {}, this.stacksTouched = 0, this.axis = t;\n    }\n    buildStacks() {\n      let t, e;\n      let i = this.axis,\n        s = i.series,\n        o = \"xAxis\" === i.coll,\n        r = i.options.reversedStacks,\n        n = s.length;\n      for (this.resetStacks(), this.usePercentage = !1, e = n; e--;) t = s[r ? e : n - e - 1], o && t.setGroupedPoints(i), t.setStackedPoints(i);\n      if (!o) for (e = 0; e < n; e++) s[e].modifyStacks();\n      ag(i, \"afterBuildStacks\");\n    }\n    cleanStacks() {\n      this.oldStacks && (this.stacks = this.oldStacks, am(this.stacks, t => {\n        am(t, t => {\n          t.cumulative = t.total;\n        });\n      }));\n    }\n    resetStacks() {\n      am(this.stacks, t => {\n        am(t, (e, i) => {\n          af(e.touched) && e.touched < this.stacksTouched ? (e.destroy(), delete t[i]) : (e.total = null, e.cumulative = null);\n        });\n      });\n    }\n    renderStackTotals() {\n      let t = this.axis,\n        e = t.chart,\n        i = e.renderer,\n        s = this.stacks,\n        o = ah(e, t.options.stackLabels?.animation || !1),\n        r = this.stackTotalGroup = this.stackTotalGroup || i.g(\"stack-labels\").attr({\n          zIndex: 6,\n          opacity: 0\n        }).add();\n      r.translate(e.plotLeft, e.plotTop), am(s, t => {\n        am(t, t => {\n          t.render(r);\n        });\n      }), r.animate({\n        opacity: 1\n      }, o);\n    }\n  }\n  (f || (f = {})).compose = function (t, e, i) {\n    let s = e.prototype,\n      o = i.prototype;\n    s.getStacks || (ad(t, \"init\", av), ad(t, \"destroy\", ab), s.getStacks = ay, o.getStackIndicator = aM, o.modifyStacks = ak, o.percentStacker = aw, o.setGroupedPoints = aS, o.setStackedPoints = aA);\n  };\n  let aP = f,\n    {\n      defined: aC,\n      merge: aO,\n      isObject: aE\n    } = tt;\n  class aL extends rK {\n    drawGraph() {\n      let t = this.options,\n        e = (this.gappedPath || this.getGraphPath).call(this),\n        i = this.chart.styledMode;\n      [this, ...this.zones].forEach((s, o) => {\n        let r,\n          n = s.graph,\n          a = n ? \"animate\" : \"attr\",\n          h = s.dashStyle || t.dashStyle;\n        n ? (n.endX = this.preventGraphAnimation ? null : e.xMap, n.animate({\n          d: e\n        })) : e.length && (s.graph = n = this.chart.renderer.path(e).addClass(\"highcharts-graph\" + (o ? ` highcharts-zone-graph-${o - 1} ` : \" \") + (o && s.className || \"\")).attr({\n          zIndex: 1\n        }).add(this.group)), n && !i && (r = {\n          stroke: !o && t.lineColor || s.color || this.color || \"#cccccc\",\n          \"stroke-width\": t.lineWidth || 0,\n          fill: this.fillGraph && this.color || \"none\"\n        }, h ? r.dashstyle = h : \"square\" !== t.linecap && (r[\"stroke-linecap\"] = r[\"stroke-linejoin\"] = \"round\"), n[a](r).shadow(t.shadow && aO({\n          filterUnits: \"userSpaceOnUse\"\n        }, aE(t.shadow) ? t.shadow : {}))), n && (n.startX = e.xMap, n.isArea = e.isArea);\n      });\n    }\n    getGraphPath(t, e, i) {\n      let s = this,\n        o = s.options,\n        r = [],\n        n = [],\n        a,\n        h = o.step,\n        l = (t = t || s.points).reversed;\n      return l && t.reverse(), (h = {\n        right: 1,\n        center: 2\n      }[h] || h && 3) && l && (h = 4 - h), (t = this.getValidPoints(t, !1, !(o.connectNulls && !e && !i))).forEach(function (l, d) {\n        let c;\n        let p = l.plotX,\n          u = l.plotY,\n          g = t[d - 1],\n          f = l.isNull || \"number\" != typeof u;\n        (l.leftCliff || g && g.rightCliff) && !i && (a = !0), f && !aC(e) && d > 0 ? a = !o.connectNulls : f && !e ? a = !0 : (0 === d || a ? c = [[\"M\", l.plotX, l.plotY]] : s.getPointSpline ? c = [s.getPointSpline(t, l, d)] : h ? (c = 1 === h ? [[\"L\", g.plotX, u]] : 2 === h ? [[\"L\", (g.plotX + p) / 2, g.plotY], [\"L\", (g.plotX + p) / 2, u]] : [[\"L\", p, g.plotY]]).push([\"L\", p, u]) : c = [[\"L\", p, u]], n.push(l.x), h && (n.push(l.x), 2 === h && n.push(l.x)), r.push.apply(r, c), a = !1);\n      }), r.xMap = n, s.graphPath = r, r;\n    }\n  }\n  aL.defaultOptions = aO(rK.defaultOptions, {\n    legendSymbol: \"lineMarker\"\n  }), ry.registerSeriesType(\"line\", aL);\n  let {\n      seriesTypes: {\n        line: aB\n      }\n    } = ry,\n    {\n      extend: aI,\n      merge: aD,\n      objectEach: aR,\n      pick: aN\n    } = tt;\n  class az extends aB {\n    drawGraph() {\n      this.areaPath = [], super.drawGraph.apply(this);\n      let {\n        areaPath: t,\n        options: e\n      } = this;\n      [this, ...this.zones].forEach((i, s) => {\n        let o = {},\n          r = i.fillColor || e.fillColor,\n          n = i.area,\n          a = n ? \"animate\" : \"attr\";\n        n ? (n.endX = this.preventGraphAnimation ? null : t.xMap, n.animate({\n          d: t\n        })) : (o.zIndex = 0, (n = i.area = this.chart.renderer.path(t).addClass(\"highcharts-area\" + (s ? ` highcharts-zone-area-${s - 1} ` : \" \") + (s && i.className || \"\")).add(this.group)).isArea = !0), this.chart.styledMode || (o.fill = r || i.color || this.color, o[\"fill-opacity\"] = r ? 1 : e.fillOpacity ?? .75, n.css({\n          pointerEvents: this.stickyTracking ? \"none\" : \"auto\"\n        })), n[a](o), n.startX = t.xMap, n.shiftUnit = e.step ? 2 : 1;\n      });\n    }\n    getGraphPath(t) {\n      let e, i, s;\n      let o = aB.prototype.getGraphPath,\n        r = this.options,\n        n = r.stacking,\n        a = this.yAxis,\n        h = [],\n        l = [],\n        d = this.index,\n        c = a.stacking.stacks[this.stackKey],\n        p = r.threshold,\n        u = Math.round(a.getThreshold(r.threshold)),\n        g = aN(r.connectNulls, \"percent\" === n),\n        f = function (i, s, o) {\n          let r = t[i],\n            g = n && c[r.x].points[d],\n            f = r[o + \"Null\"] || 0,\n            m = r[o + \"Cliff\"] || 0,\n            x,\n            y,\n            b = !0;\n          m || f ? (x = (f ? g[0] : g[1]) + m, y = g[0] + m, b = !!f) : !n && t[s] && t[s].isNull && (x = y = p), void 0 !== x && (l.push({\n            plotX: e,\n            plotY: null === x ? u : a.getThreshold(x),\n            isNull: b,\n            isCliff: !0\n          }), h.push({\n            plotX: e,\n            plotY: null === y ? u : a.getThreshold(y),\n            doCurve: !1\n          }));\n        };\n      t = t || this.points, n && (t = this.getStackPoints(t));\n      for (let o = 0, r = t.length; o < r; ++o) n || (t[o].leftCliff = t[o].rightCliff = t[o].leftNull = t[o].rightNull = void 0), i = t[o].isNull, e = aN(t[o].rectPlotX, t[o].plotX), s = n ? aN(t[o].yBottom, u) : u, i && !g || (g || f(o, o - 1, \"left\"), i && !n && g || (l.push(t[o]), h.push({\n        x: o,\n        plotX: e,\n        plotY: s\n      })), g || f(o, o + 1, \"right\"));\n      let m = o.call(this, l, !0, !0);\n      h.reversed = !0;\n      let x = o.call(this, h, !0, !0),\n        y = x[0];\n      y && \"M\" === y[0] && (x[0] = [\"L\", y[1], y[2]]);\n      let b = m.concat(x);\n      b.length && b.push([\"Z\"]);\n      let v = o.call(this, l, !1, g);\n      return this.chart.series.length > 1 && n && l.some(t => t.isCliff) && (b.hasStackedCliffs = v.hasStackedCliffs = !0), b.xMap = m.xMap, this.areaPath = b, v;\n    }\n    getStackPoints(t) {\n      let e = this,\n        i = [],\n        s = [],\n        o = this.xAxis,\n        r = this.yAxis,\n        n = r.stacking.stacks[this.stackKey],\n        a = {},\n        h = r.series,\n        l = h.length,\n        d = r.options.reversedStacks ? 1 : -1,\n        c = h.indexOf(e);\n      if (t = t || this.points, this.options.stacking) {\n        for (let e = 0; e < t.length; e++) t[e].leftNull = t[e].rightNull = void 0, a[t[e].x] = t[e];\n        aR(n, function (t, e) {\n          null !== t.total && s.push(e);\n        }), s.sort(function (t, e) {\n          return t - e;\n        });\n        let p = h.map(t => t.visible);\n        s.forEach(function (t, u) {\n          let g = 0,\n            f,\n            m;\n          if (a[t] && !a[t].isNull) i.push(a[t]), [-1, 1].forEach(function (i) {\n            let o = 1 === i ? \"rightNull\" : \"leftNull\",\n              r = n[s[u + i]],\n              g = 0;\n            if (r) {\n              let i = c;\n              for (; i >= 0 && i < l;) {\n                let s = h[i].index;\n                !(f = r.points[s]) && (s === e.index ? a[t][o] = !0 : p[i] && (m = n[t].points[s]) && (g -= m[1] - m[0])), i += d;\n              }\n            }\n            a[t][1 === i ? \"rightCliff\" : \"leftCliff\"] = g;\n          });else {\n            let e = c;\n            for (; e >= 0 && e < l;) {\n              let i = h[e].index;\n              if (f = n[t].points[i]) {\n                g = f[1];\n                break;\n              }\n              e += d;\n            }\n            g = aN(g, 0), g = r.translate(g, 0, 1, 0, 1), i.push({\n              isNull: !0,\n              plotX: o.translate(t, 0, 0, 0, 1),\n              x: t,\n              plotY: g,\n              yBottom: g\n            });\n          }\n        });\n      }\n      return i;\n    }\n  }\n  az.defaultOptions = aD(aB.defaultOptions, {\n    threshold: 0,\n    legendSymbol: \"areaMarker\"\n  }), aI(az.prototype, {\n    singleStacks: !1\n  }), ry.registerSeriesType(\"area\", az);\n  let {\n      line: aW\n    } = ry.seriesTypes,\n    {\n      merge: aG,\n      pick: aH\n    } = tt;\n  class aF extends aW {\n    getPointSpline(t, e, i) {\n      let s, o, r, n;\n      let a = e.plotX || 0,\n        h = e.plotY || 0,\n        l = t[i - 1],\n        d = t[i + 1];\n      function c(t) {\n        return t && !t.isNull && !1 !== t.doCurve && !e.isCliff;\n      }\n      if (c(l) && c(d)) {\n        let t = l.plotX || 0,\n          i = l.plotY || 0,\n          c = d.plotX || 0,\n          p = d.plotY || 0,\n          u = 0;\n        s = (1.5 * a + t) / 2.5, o = (1.5 * h + i) / 2.5, r = (1.5 * a + c) / 2.5, n = (1.5 * h + p) / 2.5, r !== s && (u = (n - o) * (r - a) / (r - s) + h - n), o += u, n += u, o > i && o > h ? (o = Math.max(i, h), n = 2 * h - o) : o < i && o < h && (o = Math.min(i, h), n = 2 * h - o), n > p && n > h ? (n = Math.max(p, h), o = 2 * h - n) : n < p && n < h && (n = Math.min(p, h), o = 2 * h - n), e.rightContX = r, e.rightContY = n, e.controlPoints = {\n          low: [s, o],\n          high: [r, n]\n        };\n      }\n      let p = [\"C\", aH(l.rightContX, l.plotX, 0), aH(l.rightContY, l.plotY, 0), aH(s, a, 0), aH(o, h, 0), a, h];\n      return l.rightContX = l.rightContY = void 0, p;\n    }\n  }\n  aF.defaultOptions = aG(aW.defaultOptions), ry.registerSeriesType(\"spline\", aF);\n  let aX = aF,\n    {\n      area: aY,\n      area: {\n        prototype: aj\n      }\n    } = ry.seriesTypes,\n    {\n      extend: aU,\n      merge: aV\n    } = tt;\n  class a$ extends aX {}\n  a$.defaultOptions = aV(aX.defaultOptions, aY.defaultOptions), aU(a$.prototype, {\n    getGraphPath: aj.getGraphPath,\n    getStackPoints: aj.getStackPoints,\n    drawGraph: aj.drawGraph\n  }), ry.registerSeriesType(\"areaspline\", a$);\n  let {\n      animObject: a_\n    } = tU,\n    {\n      parse: aq\n    } = tO,\n    {\n      noop: aZ\n    } = O,\n    {\n      clamp: aK,\n      crisp: aJ,\n      defined: aQ,\n      extend: a0,\n      fireEvent: a1,\n      isArray: a2,\n      isNumber: a3,\n      merge: a5,\n      pick: a6,\n      objectEach: a9\n    } = tt;\n  class a4 extends rK {\n    animate(t) {\n      let e, i;\n      let s = this,\n        o = this.yAxis,\n        r = o.pos,\n        n = o.reversed,\n        a = s.options,\n        {\n          clipOffset: h,\n          inverted: l\n        } = this.chart,\n        d = {},\n        c = l ? \"translateX\" : \"translateY\";\n      t && h ? (d.scaleY = .001, i = aK(o.toPixels(a.threshold || 0), r, r + o.len), l ? (i += n ? -Math.floor(h[0]) : Math.ceil(h[2]), d.translateX = i - o.len) : (i += n ? Math.ceil(h[0]) : -Math.floor(h[2]), d.translateY = i), s.clipBox && s.setClip(), s.group.attr(d)) : (e = Number(s.group.attr(c)), s.group.animate({\n        scaleY: 1\n      }, a0(a_(s.options.animation), {\n        step: function (t, i) {\n          s.group && (d[c] = e + i.pos * (r - e), s.group.attr(d));\n        }\n      })));\n    }\n    init(t, e) {\n      super.init.apply(this, arguments);\n      let i = this;\n      (t = i.chart).hasRendered && t.series.forEach(function (t) {\n        t.type === i.type && (t.isDirty = !0);\n      });\n    }\n    getColumnMetrics() {\n      let t = this,\n        e = t.options,\n        i = t.xAxis,\n        s = t.yAxis,\n        o = i.options.reversedStacks,\n        r = i.reversed && !o || !i.reversed && o,\n        n = {},\n        a,\n        h = 0;\n      !1 === e.grouping ? h = 1 : t.chart.series.forEach(function (e) {\n        let i;\n        let o = e.yAxis,\n          r = e.options;\n        e.type === t.type && e.reserveSpace() && s.len === o.len && s.pos === o.pos && (r.stacking && \"group\" !== r.stacking ? (void 0 === n[a = e.stackKey] && (n[a] = h++), i = n[a]) : !1 !== r.grouping && (i = h++), e.columnIndex = i);\n      });\n      let l = Math.min(Math.abs(i.transA) * (!i.brokenAxis?.hasBreaks && i.ordinal?.slope || e.pointRange || i.closestPointRange || i.tickInterval || 1), i.len),\n        d = l * e.groupPadding,\n        c = (l - 2 * d) / (h || 1),\n        p = Math.min(e.maxPointWidth || i.len, a6(e.pointWidth, c * (1 - 2 * e.pointPadding))),\n        u = (t.columnIndex || 0) + (r ? 1 : 0);\n      return t.columnMetrics = {\n        width: p,\n        offset: (c - p) / 2 + (d + u * c - l / 2) * (r ? -1 : 1),\n        paddedWidth: c,\n        columnCount: h\n      }, t.columnMetrics;\n    }\n    crispCol(t, e, i, s) {\n      let o = this.borderWidth,\n        r = this.chart.inverted;\n      return s = aJ(e + s, o, r) - (e = aJ(e, o, r)), this.options.crisp && (i = aJ(t + i, o) - (t = aJ(t, o))), {\n        x: t,\n        y: e,\n        width: i,\n        height: s\n      };\n    }\n    adjustForMissingColumns(t, e, i, s) {\n      if (!i.isNull && s.columnCount > 1) {\n        let o = this.xAxis.series.filter(t => t.visible).map(t => t.index),\n          r = 0,\n          n = 0;\n        a9(this.xAxis.stacking?.stacks, t => {\n          let e = \"number\" == typeof i.x ? t[i.x.toString()]?.points : void 0,\n            s = e?.[this.index],\n            a = {};\n          if (e && a2(s)) {\n            let t = this.index,\n              i = Object.keys(e).filter(t => !t.match(\",\") && e[t] && e[t].length > 1).map(parseFloat).filter(t => -1 !== o.indexOf(t)).filter(e => {\n                let i = this.chart.series[e].options,\n                  s = i.stacking && i.stack;\n                if (aQ(s)) {\n                  if (a3(a[s])) return t === e && (t = a[s]), !1;\n                  a[s] = e;\n                }\n                return !0;\n              }).sort((t, e) => e - t);\n            r = i.indexOf(t), n = i.length;\n          }\n        }), r = this.xAxis.reversed ? n - 1 - r : r;\n        let a = (n - 1) * s.paddedWidth + e;\n        t = (i.plotX || 0) + a / 2 - e - r * s.paddedWidth;\n      }\n      return t;\n    }\n    translate() {\n      let t = this,\n        e = t.chart,\n        i = t.options,\n        s = t.dense = t.closestPointRange * t.xAxis.transA < 2,\n        o = t.borderWidth = a6(i.borderWidth, s ? 0 : 1),\n        r = t.xAxis,\n        n = t.yAxis,\n        a = i.threshold,\n        h = a6(i.minPointLength, 5),\n        l = t.getColumnMetrics(),\n        d = l.width,\n        c = t.pointXOffset = l.offset,\n        p = t.dataMin,\n        u = t.dataMax,\n        g = t.translatedThreshold = n.getThreshold(a),\n        f = t.barW = Math.max(d, 1 + 2 * o);\n      i.pointPadding && i.crisp && (f = Math.ceil(f)), rK.prototype.translate.apply(t), t.points.forEach(function (s) {\n        let o = a6(s.yBottom, g),\n          m = 999 + Math.abs(o),\n          x = s.plotX || 0,\n          y = aK(s.plotY, -m, n.len + m),\n          b,\n          v = Math.min(y, o),\n          M = Math.max(y, o) - v,\n          k = d,\n          w = x + c,\n          S = f;\n        h && Math.abs(M) < h && (M = h, b = !n.reversed && !s.negative || n.reversed && s.negative, a3(a) && a3(u) && s.y === a && u <= a && (n.min || 0) < a && (p !== u || (n.max || 0) <= a) && (b = !b, s.negative = !s.negative), v = Math.abs(v - g) > h ? o - h : g - (b ? h : 0)), aQ(s.options.pointWidth) && (w -= Math.round(((k = S = Math.ceil(s.options.pointWidth)) - d) / 2)), i.centerInCategory && (w = t.adjustForMissingColumns(w, k, s, l)), s.barX = w, s.pointWidth = k, s.tooltipPos = e.inverted ? [aK(n.len + n.pos - e.plotLeft - y, n.pos - e.plotLeft, n.len + n.pos - e.plotLeft), r.len + r.pos - e.plotTop - w - S / 2, M] : [r.left - e.plotLeft + w + S / 2, aK(y + n.pos - e.plotTop, n.pos - e.plotTop, n.len + n.pos - e.plotTop), M], s.shapeType = t.pointClass.prototype.shapeType || \"roundedRect\", s.shapeArgs = t.crispCol(w, s.isNull ? g : v, S, s.isNull ? 0 : M);\n      }), a1(this, \"afterColumnTranslate\");\n    }\n    drawGraph() {\n      this.group[this.dense ? \"addClass\" : \"removeClass\"](\"highcharts-dense-data\");\n    }\n    pointAttribs(t, e) {\n      let i = this.options,\n        s = this.pointAttrToOptions || {},\n        o = s.stroke || \"borderColor\",\n        r = s[\"stroke-width\"] || \"borderWidth\",\n        n,\n        a,\n        h,\n        l = t && t.color || this.color,\n        d = t && t[o] || i[o] || l,\n        c = t && t.options.dashStyle || i.dashStyle,\n        p = t && t[r] || i[r] || this[r] || 0,\n        u = a6(t && t.opacity, i.opacity, 1);\n      t && this.zones.length && (a = t.getZone(), l = t.options.color || a && (a.color || t.nonZonedColor) || this.color, a && (d = a.borderColor || d, c = a.dashStyle || c, p = a.borderWidth || p)), e && t && (h = (n = a5(i.states[e], t.options.states && t.options.states[e] || {})).brightness, l = n.color || void 0 !== h && aq(l).brighten(n.brightness).get() || l, d = n[o] || d, p = n[r] || p, c = n.dashStyle || c, u = a6(n.opacity, u));\n      let g = {\n        fill: l,\n        stroke: d,\n        \"stroke-width\": p,\n        opacity: u\n      };\n      return c && (g.dashstyle = c), g;\n    }\n    drawPoints(t = this.points) {\n      let e;\n      let i = this,\n        s = this.chart,\n        o = i.options,\n        r = s.renderer,\n        n = o.animationLimit || 250;\n      t.forEach(function (t) {\n        let a = t.plotY,\n          h = t.graphic,\n          l = !!h,\n          d = h && s.pointCount < n ? \"animate\" : \"attr\";\n        a3(a) && null !== t.y ? (e = t.shapeArgs, h && t.hasNewShapeType() && (h = h.destroy()), i.enabledDataSorting && (t.startXPos = i.xAxis.reversed ? -(e && e.width || 0) : i.xAxis.width), !h && (t.graphic = h = r[t.shapeType](e).add(t.group || i.group), h && i.enabledDataSorting && s.hasRendered && s.pointCount < n && (h.attr({\n          x: t.startXPos\n        }), l = !0, d = \"animate\")), h && l && h[d](a5(e)), s.styledMode || h[d](i.pointAttribs(t, t.selected && \"select\")).shadow(!1 !== t.allowShadow && o.shadow), h && (h.addClass(t.getClassName(), !0), h.attr({\n          visibility: t.visible ? \"inherit\" : \"hidden\"\n        }))) : h && (t.graphic = h.destroy());\n      });\n    }\n    drawTracker(t = this.points) {\n      let e;\n      let i = this,\n        s = i.chart,\n        o = s.pointer,\n        r = function (t) {\n          o?.normalize(t);\n          let e = o?.getPointFromEvent(t),\n            r = !s.scrollablePlotArea || s.isInsidePlot(t.chartX - s.plotLeft, t.chartY - s.plotTop, {\n              visiblePlotOnly: !0\n            });\n          o && e && i.options.enableMouseTracking && r && (o.isDirectTouch = !0, e.onMouseOver(t));\n        };\n      t.forEach(function (t) {\n        e = a2(t.dataLabels) ? t.dataLabels : t.dataLabel ? [t.dataLabel] : [], t.graphic && (t.graphic.element.point = t), e.forEach(function (e) {\n          (e.div || e.element).point = t;\n        });\n      }), i._hasTracking || (i.trackerGroups.forEach(function (t) {\n        i[t] && (i[t].addClass(\"highcharts-tracker\").on(\"mouseover\", r).on(\"mouseout\", function (t) {\n          o?.onTrackerMouseOut(t);\n        }).on(\"touchstart\", r), !s.styledMode && i.options.cursor && i[t].css({\n          cursor: i.options.cursor\n        }));\n      }), i._hasTracking = !0), a1(this, \"afterDrawTracker\");\n    }\n    remove() {\n      let t = this,\n        e = t.chart;\n      e.hasRendered && e.series.forEach(function (e) {\n        e.type === t.type && (e.isDirty = !0);\n      }), rK.prototype.remove.apply(t, arguments);\n    }\n  }\n  a4.defaultOptions = a5(rK.defaultOptions, {\n    borderRadius: 3,\n    centerInCategory: !1,\n    groupPadding: .2,\n    marker: null,\n    pointPadding: .1,\n    minPointLength: 0,\n    cropThreshold: 50,\n    pointRange: null,\n    states: {\n      hover: {\n        halo: !1,\n        brightness: .1\n      },\n      select: {\n        color: \"#cccccc\",\n        borderColor: \"#000000\"\n      }\n    },\n    dataLabels: {\n      align: void 0,\n      verticalAlign: void 0,\n      y: void 0\n    },\n    startFromThreshold: !0,\n    stickyTracking: !1,\n    tooltip: {\n      distance: 6\n    },\n    threshold: 0,\n    borderColor: \"#ffffff\"\n  }), a0(a4.prototype, {\n    directTouch: !0,\n    getSymbol: aZ,\n    negStacks: !0,\n    trackerGroups: [\"group\", \"dataLabelsGroup\"]\n  }), ry.registerSeriesType(\"column\", a4);\n  let a8 = a4,\n    {\n      getDeferredAnimation: a7\n    } = tU,\n    {\n      format: ht\n    } = ep,\n    {\n      defined: he,\n      extend: hi,\n      fireEvent: hs,\n      getAlignFactor: ho,\n      isArray: hr,\n      isString: hn,\n      merge: ha,\n      objectEach: hh,\n      pick: hl,\n      pInt: hd,\n      splat: hc\n    } = tt;\n  !function (t) {\n    function e() {\n      return h(this).some(t => t?.enabled);\n    }\n    function i(t, e, i, s, o) {\n      let {\n          chart: r,\n          enabledDataSorting: n\n        } = this,\n        a = this.isCartesian && r.inverted,\n        h = t.plotX,\n        l = t.plotY,\n        d = i.rotation || 0,\n        c = he(h) && he(l) && r.isInsidePlot(h, Math.round(l), {\n          inverted: a,\n          paneCoordinates: !0,\n          series: this\n        }),\n        p = 0 === d && \"justify\" === hl(i.overflow, n ? \"none\" : \"justify\"),\n        u = this.visible && !1 !== t.visible && he(h) && (t.series.forceDL || n && !p || c || hl(i.inside, !!this.options.stacking) && s && r.isInsidePlot(h, a ? s.x + 1 : s.y + s.height - 1, {\n          inverted: a,\n          paneCoordinates: !0,\n          series: this\n        })),\n        g = t.pos();\n      if (u && g) {\n        var f;\n        let h = e.getBBox(),\n          l = e.getBBox(void 0, 0);\n        if (s = hi({\n          x: g[0],\n          y: Math.round(g[1]),\n          width: 0,\n          height: 0\n        }, s || {}), \"plotEdges\" === i.alignTo && this.isCartesian && (s[a ? \"x\" : \"y\"] = 0, s[a ? \"width\" : \"height\"] = this.yAxis?.len || 0), hi(i, {\n          width: h.width,\n          height: h.height\n        }), f = s, n && this.xAxis && !p && this.setDataLabelStartPos(t, e, o, c, f), e.align(ha(i, {\n          width: l.width,\n          height: l.height\n        }), !1, s, !1), e.alignAttr.x += ho(i.align) * (l.width - h.width), e.alignAttr.y += ho(i.verticalAlign) * (l.height - h.height), e[e.placed ? \"animate\" : \"attr\"]({\n          \"text-align\": e.alignAttr[\"text-align\"] || \"center\",\n          x: e.alignAttr.x + (h.width - l.width) / 2,\n          y: e.alignAttr.y + (h.height - l.height) / 2,\n          rotationOriginX: (e.width || 0) / 2,\n          rotationOriginY: (e.height || 0) / 2\n        }), p && s.height >= 0) this.justifyDataLabel(e, i, e.alignAttr, h, s, o);else if (hl(i.crop, !0)) {\n          let {\n            x: t,\n            y: i\n          } = e.alignAttr;\n          u = r.isInsidePlot(t, i, {\n            paneCoordinates: !0,\n            series: this\n          }) && r.isInsidePlot(t + h.width - 1, i + h.height - 1, {\n            paneCoordinates: !0,\n            series: this\n          });\n        }\n        i.shape && !d && e[o ? \"attr\" : \"animate\"]({\n          anchorX: g[0],\n          anchorY: g[1]\n        });\n      }\n      o && n && (e.placed = !1), u || n && !p ? (e.show(), e.placed = !0) : (e.hide(), e.placed = !1);\n    }\n    function s() {\n      return this.plotGroup(\"dataLabelsGroup\", \"data-labels\", this.hasRendered ? \"inherit\" : \"hidden\", this.options.dataLabels.zIndex || 6);\n    }\n    function o(t) {\n      let e = this.hasRendered || 0,\n        i = this.initDataLabelsGroup().attr({\n          opacity: +e\n        });\n      return !e && i && (this.visible && i.show(), this.options.animation ? i.animate({\n        opacity: 1\n      }, t) : i.attr({\n        opacity: 1\n      })), i;\n    }\n    function r(t) {\n      let e;\n      t = t || this.points;\n      let i = this,\n        s = i.chart,\n        o = i.options,\n        r = s.renderer,\n        {\n          backgroundColor: n,\n          plotBackgroundColor: l\n        } = s.options.chart,\n        d = r.getContrast(hn(l) && l || hn(n) && n || \"#000000\"),\n        c = h(i),\n        {\n          animation: p,\n          defer: u\n        } = c[0],\n        g = u ? a7(s, p, i) : {\n          defer: 0,\n          duration: 0\n        };\n      hs(this, \"drawDataLabels\"), i.hasDataLabels?.() && (e = this.initDataLabels(g), t.forEach(t => {\n        let n = t.dataLabels || [];\n        hc(a(c, t.dlOptions || t.options?.dataLabels)).forEach((a, h) => {\n          let l = a.enabled && (t.visible || t.dataLabelOnHidden) && (!t.isNull || t.dataLabelOnNull) && function (t, e) {\n              let i = e.filter;\n              if (i) {\n                let e = i.operator,\n                  s = t[i.property],\n                  o = i.value;\n                return \">\" === e && s > o || \"<\" === e && s < o || \">=\" === e && s >= o || \"<=\" === e && s <= o || \"==\" === e && s == o || \"===\" === e && s === o || \"!=\" === e && s != o || \"!==\" === e && s !== o;\n              }\n              return !0;\n            }(t, a),\n            {\n              backgroundColor: c,\n              borderColor: p,\n              distance: u,\n              style: g = {}\n            } = a,\n            f,\n            m,\n            x,\n            y = {},\n            b = n[h],\n            v = !b,\n            M;\n          l && (m = he(f = hl(a[t.formatPrefix + \"Format\"], a.format)) ? ht(f, t, s) : (a[t.formatPrefix + \"Formatter\"] || a.formatter).call(t, a), x = a.rotation, !s.styledMode && (g.color = hl(a.color, g.color, hn(i.color) ? i.color : void 0, \"#000000\"), \"contrast\" === g.color ? (\"none\" !== c && (M = c), t.contrastColor = r.getContrast(\"auto\" !== M && M || t.color || i.color), g.color = M || !he(u) && a.inside || 0 > hd(u || 0) || o.stacking ? t.contrastColor : d) : delete t.contrastColor, o.cursor && (g.cursor = o.cursor)), y = {\n            r: a.borderRadius || 0,\n            rotation: x,\n            padding: a.padding,\n            zIndex: 1\n          }, s.styledMode || (y.fill = \"auto\" === c ? t.color : c, y.stroke = \"auto\" === p ? t.color : p, y[\"stroke-width\"] = a.borderWidth), hh(y, (t, e) => {\n            void 0 === t && delete y[e];\n          })), !b || l && he(m) && !!b.div == !!a.useHTML && (b.rotation && a.rotation || b.rotation === a.rotation) || (b = void 0, v = !0), l && he(m) && (b ? y.text = m : (b = r.label(m, 0, 0, a.shape, void 0, void 0, a.useHTML, void 0, \"data-label\")).addClass(\" highcharts-data-label-color-\" + t.colorIndex + \" \" + (a.className || \"\") + (a.useHTML ? \" highcharts-tracker\" : \"\")), b && (b.options = a, b.attr(y), s.styledMode ? g.width && b.css({\n            width: g.width,\n            textOverflow: g.textOverflow,\n            whiteSpace: g.whiteSpace\n          }) : b.css(g).shadow(a.shadow), hs(b, \"beforeAddingDataLabel\", {\n            labelOptions: a,\n            point: t\n          }), b.added || b.add(e), i.alignDataLabel(t, b, a, void 0, v), b.isActive = !0, n[h] && n[h] !== b && n[h].destroy(), n[h] = b));\n        });\n        let h = n.length;\n        for (; h--;) n[h] && n[h].isActive ? n[h].isActive = !1 : (n[h]?.destroy(), n.splice(h, 1));\n        t.dataLabel = n[0], t.dataLabels = n;\n      })), hs(this, \"afterDrawDataLabels\");\n    }\n    function n(t, e, i, s, o, r) {\n      let n = this.chart,\n        a = e.align,\n        h = e.verticalAlign,\n        l = t.box ? 0 : t.padding || 0,\n        d = n.inverted ? this.yAxis : this.xAxis,\n        c = d ? d.left - n.plotLeft : 0,\n        p = n.inverted ? this.xAxis : this.yAxis,\n        u = p ? p.top - n.plotTop : 0,\n        {\n          x: g = 0,\n          y: f = 0\n        } = e,\n        m,\n        x;\n      return (m = (i.x || 0) + l + c) < 0 && (\"right\" === a && g >= 0 ? (e.align = \"left\", e.inside = !0) : g -= m, x = !0), (m = (i.x || 0) + s.width - l + c) > n.plotWidth && (\"left\" === a && g <= 0 ? (e.align = \"right\", e.inside = !0) : g += n.plotWidth - m, x = !0), (m = i.y + l + u) < 0 && (\"bottom\" === h && f >= 0 ? (e.verticalAlign = \"top\", e.inside = !0) : f -= m, x = !0), (m = (i.y || 0) + s.height - l + u) > n.plotHeight && (\"top\" === h && f <= 0 ? (e.verticalAlign = \"bottom\", e.inside = !0) : f += n.plotHeight - m, x = !0), x && (e.x = g, e.y = f, t.placed = !r, t.align(e, void 0, o)), x;\n    }\n    function a(t, e) {\n      let i = [],\n        s;\n      if (hr(t) && !hr(e)) i = t.map(function (t) {\n        return ha(t, e);\n      });else if (hr(e) && !hr(t)) i = e.map(function (e) {\n        return ha(t, e);\n      });else if (hr(t) || hr(e)) {\n        if (hr(t) && hr(e)) for (s = Math.max(t.length, e.length); s--;) i[s] = ha(t[s], e[s]);\n      } else i = ha(t, e);\n      return i;\n    }\n    function h(t) {\n      let e = t.chart.options.plotOptions;\n      return hc(a(a(e?.series?.dataLabels, e?.[t.type]?.dataLabels), t.options.dataLabels));\n    }\n    function l(t, e, i, s, o) {\n      let r = this.chart,\n        n = r.inverted,\n        a = this.xAxis,\n        h = a.reversed,\n        l = ((n ? e.height : e.width) || 0) / 2,\n        d = t.pointWidth,\n        c = d ? d / 2 : 0;\n      e.startXPos = n ? o.x : h ? -l - c : a.width - l + c, e.startYPos = n ? h ? this.yAxis.height - l + c : -l - c : o.y, s ? \"hidden\" === e.visibility && (e.show(), e.attr({\n        opacity: 0\n      }).animate({\n        opacity: 1\n      })) : e.attr({\n        opacity: 1\n      }).animate({\n        opacity: 0\n      }, void 0, e.hide), r.hasRendered && (i && e.attr({\n        x: e.startXPos,\n        y: e.startYPos\n      }), e.placed = !0);\n    }\n    t.compose = function (t) {\n      let a = t.prototype;\n      a.initDataLabels || (a.initDataLabels = o, a.initDataLabelsGroup = s, a.alignDataLabel = i, a.drawDataLabels = r, a.justifyDataLabel = n, a.setDataLabelStartPos = l, a.hasDataLabels = e);\n    };\n  }(m || (m = {}));\n  let hp = m,\n    {\n      composed: hu\n    } = O,\n    {\n      series: hg\n    } = ry,\n    {\n      merge: hf,\n      pick: hm,\n      pushUnique: hx\n    } = tt;\n  !function (t) {\n    function e(t, e, i, s, o) {\n      let r = this.chart.inverted,\n        n = t.series,\n        a = (n.xAxis ? n.xAxis.len : this.chart.plotSizeX) || 0,\n        h = (n.yAxis ? n.yAxis.len : this.chart.plotSizeY) || 0,\n        l = t.dlBox || t.shapeArgs,\n        d = hm(t.below, t.plotY > hm(this.translatedThreshold, h)),\n        c = hm(i.inside, !!this.options.stacking);\n      if (l) {\n        if (s = hf(l), !(\"allow\" === i.overflow && !1 === i.crop)) {\n          s.y < 0 && (s.height += s.y, s.y = 0);\n          let t = s.y + s.height - h;\n          t > 0 && t < s.height - 1 && (s.height -= t);\n        }\n        r && (s = {\n          x: h - s.y - s.height,\n          y: a - s.x - s.width,\n          width: s.height,\n          height: s.width\n        }), c || (r ? (s.x += d ? 0 : s.width, s.width = 0) : (s.y += d ? s.height : 0, s.height = 0));\n      }\n      i.align = hm(i.align, !r || c ? \"center\" : d ? \"right\" : \"left\"), i.verticalAlign = hm(i.verticalAlign, r || c ? \"middle\" : d ? \"top\" : \"bottom\"), hg.prototype.alignDataLabel.call(this, t, e, i, s, o), i.inside && t.contrastColor && e.css({\n        color: t.contrastColor\n      });\n    }\n    t.compose = function (t) {\n      hp.compose(hg), hx(hu, \"ColumnDataLabel\") && (t.prototype.alignDataLabel = e);\n    };\n  }(x || (x = {}));\n  let hy = x,\n    {\n      extend: hb,\n      merge: hv\n    } = tt;\n  class hM extends a8 {}\n  hM.defaultOptions = hv(a8.defaultOptions, {}), hb(hM.prototype, {\n    inverted: !0\n  }), ry.registerSeriesType(\"bar\", hM);\n  let {\n      column: hk,\n      line: hw\n    } = ry.seriesTypes,\n    {\n      addEvent: hS,\n      extend: hA,\n      merge: hT\n    } = tt;\n  class hP extends hw {\n    applyJitter() {\n      let t = this,\n        e = this.options.jitter,\n        i = this.points.length;\n      e && this.points.forEach(function (s, o) {\n        [\"x\", \"y\"].forEach(function (r, n) {\n          if (e[r] && !s.isNull) {\n            let a = `plot${r.toUpperCase()}`,\n              h = t[`${r}Axis`],\n              l = e[r] * h.transA;\n            if (h && !h.logarithmic) {\n              let t = Math.max(0, (s[a] || 0) - l),\n                e = Math.min(h.len, (s[a] || 0) + l);\n              s[a] = t + (e - t) * function (t) {\n                let e = 1e4 * Math.sin(t);\n                return e - Math.floor(e);\n              }(o + n * i), \"x\" === r && (s.clientX = s.plotX);\n            }\n          }\n        });\n      });\n    }\n    drawGraph() {\n      this.options.lineWidth ? super.drawGraph() : this.graph && (this.graph = this.graph.destroy());\n    }\n  }\n  hP.defaultOptions = hT(hw.defaultOptions, {\n    lineWidth: 0,\n    findNearestPointBy: \"xy\",\n    jitter: {\n      x: 0,\n      y: 0\n    },\n    marker: {\n      enabled: !0\n    },\n    tooltip: {\n      headerFormat: '<span style=\"color:{point.color}\">●</span> <span style=\"font-size: 0.8em\"> {series.name}</span><br/>',\n      pointFormat: \"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>\"\n    }\n  }), hA(hP.prototype, {\n    drawTracker: hk.prototype.drawTracker,\n    sorted: !1,\n    requireSorting: !1,\n    noSharedTooltip: !0,\n    trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"]\n  }), hS(hP, \"afterTranslate\", function () {\n    this.applyJitter();\n  }), ry.registerSeriesType(\"scatter\", hP);\n  let {\n      deg2rad: hC\n    } = O,\n    {\n      fireEvent: hO,\n      isNumber: hE,\n      pick: hL,\n      relativeLength: hB\n    } = tt;\n  !function (t) {\n    t.getCenter = function () {\n      let t = this.options,\n        e = this.chart,\n        i = 2 * (t.slicedOffset || 0),\n        s = e.plotWidth - 2 * i,\n        o = e.plotHeight - 2 * i,\n        r = t.center,\n        n = Math.min(s, o),\n        a = t.thickness,\n        h,\n        l = t.size,\n        d = t.innerSize || 0,\n        c,\n        p;\n      \"string\" == typeof l && (l = parseFloat(l)), \"string\" == typeof d && (d = parseFloat(d));\n      let u = [hL(r?.[0], \"50%\"), hL(r?.[1], \"50%\"), hL(l && l < 0 ? void 0 : t.size, \"100%\"), hL(d && d < 0 ? void 0 : t.innerSize || 0, \"0%\")];\n      for (!e.angular || this instanceof rK || (u[3] = 0), c = 0; c < 4; ++c) p = u[c], h = c < 2 || 2 === c && /%$/.test(p), u[c] = hB(p, [s, o, n, u[2]][c]) + (h ? i : 0);\n      return u[3] > u[2] && (u[3] = u[2]), hE(a) && 2 * a < u[2] && a > 0 && (u[3] = u[2] - 2 * a), hO(this, \"afterGetCenter\", {\n        positions: u\n      }), u;\n    }, t.getStartAndEndRadians = function (t, e) {\n      let i = hE(t) ? t : 0,\n        s = hE(e) && e > i && e - i < 360 ? e : i + 360;\n      return {\n        start: hC * (i + -90),\n        end: hC * (s + -90)\n      };\n    };\n  }(y || (y = {}));\n  let hI = y,\n    {\n      setAnimation: hD\n    } = tU,\n    {\n      addEvent: hR,\n      defined: hN,\n      extend: hz,\n      isNumber: hW,\n      pick: hG,\n      relativeLength: hH\n    } = tt;\n  class hF extends oq {\n    getConnectorPath(t) {\n      let e = t.dataLabelPosition,\n        i = t.options || {},\n        s = i.connectorShape,\n        o = this.connectorShapes[s] || s;\n      return e && o.call(this, {\n        ...e.computed,\n        alignment: e.alignment\n      }, e.connectorPosition, i) || [];\n    }\n    getTranslate() {\n      return this.sliced && this.slicedTranslation || {\n        translateX: 0,\n        translateY: 0\n      };\n    }\n    haloPath(t) {\n      let e = this.shapeArgs;\n      return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(e.x, e.y, e.r + t, e.r + t, {\n        innerR: e.r - 1,\n        start: e.start,\n        end: e.end,\n        borderRadius: e.borderRadius\n      });\n    }\n    constructor(t, e, i) {\n      super(t, e, i), this.half = 0, this.name ?? (this.name = \"Slice\");\n      let s = t => {\n        this.slice(\"select\" === t.type);\n      };\n      hR(this, \"select\", s), hR(this, \"unselect\", s);\n    }\n    isValid() {\n      return hW(this.y) && this.y >= 0;\n    }\n    setVisible(t, e = !0) {\n      t !== this.visible && this.update({\n        visible: t ?? !this.visible\n      }, e, void 0, !1);\n    }\n    slice(t, e, i) {\n      let s = this.series;\n      hD(i, s.chart), e = hG(e, !0), this.sliced = this.options.sliced = t = hN(t) ? t : !this.sliced, s.options.data[s.data.indexOf(this)] = this.options, this.graphic && this.graphic.animate(this.getTranslate());\n    }\n  }\n  hz(hF.prototype, {\n    connectorShapes: {\n      fixedOffset: function (t, e, i) {\n        let s = e.breakAt,\n          o = e.touchingSliceAt,\n          r = i.softConnector ? [\"C\", t.x + (\"left\" === t.alignment ? -5 : 5), t.y, 2 * s.x - o.x, 2 * s.y - o.y, s.x, s.y] : [\"L\", s.x, s.y];\n        return [[\"M\", t.x, t.y], r, [\"L\", o.x, o.y]];\n      },\n      straight: function (t, e) {\n        let i = e.touchingSliceAt;\n        return [[\"M\", t.x, t.y], [\"L\", i.x, i.y]];\n      },\n      crookedLine: function (t, e, i) {\n        let {\n            angle: s = this.angle || 0,\n            breakAt: o,\n            touchingSliceAt: r\n          } = e,\n          {\n            series: n\n          } = this,\n          [a, h, l] = n.center,\n          d = l / 2,\n          {\n            plotLeft: c,\n            plotWidth: p\n          } = n.chart,\n          u = \"left\" === t.alignment,\n          {\n            x: g,\n            y: f\n          } = t,\n          m = o.x;\n        if (i.crookDistance) {\n          let t = hH(i.crookDistance, 1);\n          m = u ? a + d + (p + c - a - d) * (1 - t) : c + (a - d) * t;\n        } else m = a + (h - f) * Math.tan(s - Math.PI / 2);\n        let x = [[\"M\", g, f]];\n        return (u ? m <= g && m >= o.x : m >= g && m <= o.x) && x.push([\"L\", m, f]), x.push([\"L\", o.x, o.y], [\"L\", r.x, r.y]), x;\n      }\n    }\n  });\n  let {\n      getStartAndEndRadians: hX\n    } = hI,\n    {\n      noop: hY\n    } = O,\n    {\n      clamp: hj,\n      extend: hU,\n      fireEvent: hV,\n      merge: h$,\n      pick: h_\n    } = tt;\n  class hq extends rK {\n    animate(t) {\n      let e = this,\n        i = e.points,\n        s = e.startAngleRad;\n      t || i.forEach(function (t) {\n        let i = t.graphic,\n          o = t.shapeArgs;\n        i && o && (i.attr({\n          r: h_(t.startR, e.center && e.center[3] / 2),\n          start: s,\n          end: s\n        }), i.animate({\n          r: o.r,\n          start: o.start,\n          end: o.end\n        }, e.options.animation));\n      });\n    }\n    drawEmpty() {\n      let t, e;\n      let i = this.startAngleRad,\n        s = this.endAngleRad,\n        o = this.options;\n      0 === this.total && this.center ? (t = this.center[0], e = this.center[1], this.graph || (this.graph = this.chart.renderer.arc(t, e, this.center[1] / 2, 0, i, s).addClass(\"highcharts-empty-series\").add(this.group)), this.graph.attr({\n        d: is.arc(t, e, this.center[2] / 2, 0, {\n          start: i,\n          end: s,\n          innerR: this.center[3] / 2\n        })\n      }), this.chart.styledMode || this.graph.attr({\n        \"stroke-width\": o.borderWidth,\n        fill: o.fillColor || \"none\",\n        stroke: o.color || \"#cccccc\"\n      })) : this.graph && (this.graph = this.graph.destroy());\n    }\n    drawPoints() {\n      let t = this.chart.renderer;\n      this.points.forEach(function (e) {\n        e.graphic && e.hasNewShapeType() && (e.graphic = e.graphic.destroy()), e.graphic || (e.graphic = t[e.shapeType](e.shapeArgs).add(e.series.group), e.delayedRendering = !0);\n      });\n    }\n    generatePoints() {\n      super.generatePoints(), this.updateTotals();\n    }\n    getX(t, e, i, s) {\n      let o = this.center,\n        r = this.radii ? this.radii[i.index] || 0 : o[2] / 2,\n        n = s.dataLabelPosition,\n        a = n?.distance || 0,\n        h = Math.asin(hj((t - o[1]) / (r + a), -1, 1));\n      return o[0] + Math.cos(h) * (r + a) * (e ? -1 : 1) + (a > 0 ? (e ? -1 : 1) * (s.padding || 0) : 0);\n    }\n    hasData() {\n      return !!this.dataTable.rowCount;\n    }\n    redrawPoints() {\n      let t, e, i, s;\n      let o = this,\n        r = o.chart;\n      this.drawEmpty(), o.group && !r.styledMode && o.group.shadow(o.options.shadow), o.points.forEach(function (n) {\n        let a = {};\n        e = n.graphic, !n.isNull && e ? (s = n.shapeArgs, t = n.getTranslate(), r.styledMode || (i = o.pointAttribs(n, n.selected && \"select\")), n.delayedRendering ? (e.setRadialReference(o.center).attr(s).attr(t), r.styledMode || e.attr(i).attr({\n          \"stroke-linejoin\": \"round\"\n        }), n.delayedRendering = !1) : (e.setRadialReference(o.center), r.styledMode || h$(!0, a, i), h$(!0, a, s, t), e.animate(a)), e.attr({\n          visibility: n.visible ? \"inherit\" : \"hidden\"\n        }), e.addClass(n.getClassName(), !0)) : e && (n.graphic = e.destroy());\n      });\n    }\n    sortByAngle(t, e) {\n      t.sort(function (t, i) {\n        return void 0 !== t.angle && (i.angle - t.angle) * e;\n      });\n    }\n    translate(t) {\n      hV(this, \"translate\"), this.generatePoints();\n      let e = this.options,\n        i = e.slicedOffset,\n        s = hX(e.startAngle, e.endAngle),\n        o = this.startAngleRad = s.start,\n        r = (this.endAngleRad = s.end) - o,\n        n = this.points,\n        a = e.ignoreHiddenPoint,\n        h = n.length,\n        l,\n        d,\n        c,\n        p,\n        u,\n        g,\n        f,\n        m = 0;\n      for (t || (this.center = t = this.getCenter()), g = 0; g < h; g++) {\n        f = n[g], l = o + m * r, f.isValid() && (!a || f.visible) && (m += f.percentage / 100), d = o + m * r;\n        let e = {\n          x: t[0],\n          y: t[1],\n          r: t[2] / 2,\n          innerR: t[3] / 2,\n          start: Math.round(1e3 * l) / 1e3,\n          end: Math.round(1e3 * d) / 1e3\n        };\n        f.shapeType = \"arc\", f.shapeArgs = e, (c = (d + l) / 2) > 1.5 * Math.PI ? c -= 2 * Math.PI : c < -Math.PI / 2 && (c += 2 * Math.PI), f.slicedTranslation = {\n          translateX: Math.round(Math.cos(c) * i),\n          translateY: Math.round(Math.sin(c) * i)\n        }, p = Math.cos(c) * t[2] / 2, u = Math.sin(c) * t[2] / 2, f.tooltipPos = [t[0] + .7 * p, t[1] + .7 * u], f.half = c < -Math.PI / 2 || c > Math.PI / 2 ? 1 : 0, f.angle = c;\n      }\n      hV(this, \"afterTranslate\");\n    }\n    updateTotals() {\n      let t = this.points,\n        e = t.length,\n        i = this.options.ignoreHiddenPoint,\n        s,\n        o,\n        r = 0;\n      for (s = 0; s < e; s++) (o = t[s]).isValid() && (!i || o.visible) && (r += o.y);\n      for (s = 0, this.total = r; s < e; s++) (o = t[s]).percentage = r > 0 && (o.visible || !i) ? o.y / r * 100 : 0, o.total = r;\n    }\n  }\n  hq.defaultOptions = h$(rK.defaultOptions, {\n    borderRadius: 3,\n    center: [null, null],\n    clip: !1,\n    colorByPoint: !0,\n    dataLabels: {\n      connectorPadding: 5,\n      connectorShape: \"crookedLine\",\n      crookDistance: void 0,\n      distance: 30,\n      enabled: !0,\n      formatter: function () {\n        return this.isNull ? void 0 : this.name;\n      },\n      softConnector: !0,\n      x: 0\n    },\n    fillColor: void 0,\n    ignoreHiddenPoint: !0,\n    inactiveOtherPoints: !0,\n    legendType: \"point\",\n    marker: null,\n    size: null,\n    showInLegend: !1,\n    slicedOffset: 10,\n    stickyTracking: !1,\n    tooltip: {\n      followPointer: !0\n    },\n    borderColor: \"#ffffff\",\n    borderWidth: 1,\n    lineWidth: void 0,\n    states: {\n      hover: {\n        brightness: .1\n      }\n    }\n  }), hU(hq.prototype, {\n    axisTypes: [],\n    directTouch: !0,\n    drawGraph: void 0,\n    drawTracker: a8.prototype.drawTracker,\n    getCenter: hI.getCenter,\n    getSymbol: hY,\n    invertible: !1,\n    isCartesian: !1,\n    noSharedTooltip: !0,\n    pointAttribs: a8.prototype.pointAttribs,\n    pointClass: hF,\n    requireSorting: !1,\n    searchPoint: hY,\n    trackerGroups: [\"group\", \"dataLabelsGroup\"]\n  }), ry.registerSeriesType(\"pie\", hq);\n  let {\n      composed: hZ,\n      noop: hK\n    } = O,\n    {\n      distribute: hJ\n    } = ey,\n    {\n      series: hQ\n    } = ry,\n    {\n      arrayMax: h0,\n      clamp: h1,\n      defined: h2,\n      pick: h3,\n      pushUnique: h5,\n      relativeLength: h6\n    } = tt;\n  !function (t) {\n    let e = {\n      radialDistributionY: function (t, e) {\n        return (e.dataLabelPosition?.top || 0) + t.distributeBox.pos;\n      },\n      radialDistributionX: function (t, e, i, s, o) {\n        let r = o.dataLabelPosition;\n        return t.getX(i < (r?.top || 0) + 2 || i > (r?.bottom || 0) - 2 ? s : i, e.half, e, o);\n      },\n      justify: function (t, e, i, s) {\n        return s[0] + (t.half ? -1 : 1) * (i + (e.dataLabelPosition?.distance || 0));\n      },\n      alignToPlotEdges: function (t, e, i, s) {\n        let o = t.getBBox().width;\n        return e ? o + s : i - o - s;\n      },\n      alignToConnectors: function (t, e, i, s) {\n        let o = 0,\n          r;\n        return t.forEach(function (t) {\n          (r = t.dataLabel.getBBox().width) > o && (o = r);\n        }), e ? o + s : i - o - s;\n      }\n    };\n    function i(t, e) {\n      let i = Math.PI / 2,\n        {\n          start: s = 0,\n          end: o = 0\n        } = t.shapeArgs || {},\n        r = t.angle || 0;\n      e > 0 && s < i && o > i && r > i / 2 && r < 1.5 * i && (r = r <= i ? Math.max(i / 2, (s + i) / 2) : Math.min(1.5 * i, (i + o) / 2));\n      let {\n          center: n,\n          options: a\n        } = this,\n        h = n[2] / 2,\n        l = Math.cos(r),\n        d = Math.sin(r),\n        c = n[0] + l * h,\n        p = n[1] + d * h,\n        u = Math.min((a.slicedOffset || 0) + (a.borderWidth || 0), e / 5);\n      return {\n        natural: {\n          x: c + l * e,\n          y: p + d * e\n        },\n        computed: {},\n        alignment: e < 0 ? \"center\" : t.half ? \"right\" : \"left\",\n        connectorPosition: {\n          angle: r,\n          breakAt: {\n            x: c + l * u,\n            y: p + d * u\n          },\n          touchingSliceAt: {\n            x: c,\n            y: p\n          }\n        },\n        distance: e\n      };\n    }\n    function s() {\n      let t = this,\n        e = t.points,\n        i = t.chart,\n        s = i.plotWidth,\n        o = i.plotHeight,\n        r = i.plotLeft,\n        n = Math.round(i.chartWidth / 3),\n        a = t.center,\n        h = a[2] / 2,\n        l = a[1],\n        d = [[], []],\n        c = [0, 0, 0, 0],\n        p = t.dataLabelPositioners,\n        u,\n        g,\n        f,\n        m = 0;\n      t.visible && t.hasDataLabels?.() && (e.forEach(t => {\n        (t.dataLabels || []).forEach(t => {\n          t.shortened && (t.attr({\n            width: \"auto\"\n          }).css({\n            width: \"auto\",\n            textOverflow: \"clip\"\n          }), t.shortened = !1);\n        });\n      }), hQ.prototype.drawDataLabels.apply(t), e.forEach(t => {\n        (t.dataLabels || []).forEach((e, i) => {\n          let s = a[2] / 2,\n            o = e.options,\n            r = h6(o?.distance || 0, s);\n          0 === i && d[t.half].push(t), !h2(o?.style?.width) && e.getBBox().width > n && (e.css({\n            width: Math.round(.7 * n) + \"px\"\n          }), e.shortened = !0), e.dataLabelPosition = this.getDataLabelPosition(t, r), m = Math.max(m, r);\n        });\n      }), d.forEach((e, n) => {\n        let d = e.length,\n          u = [],\n          x,\n          y,\n          b = 0,\n          v;\n        d && (t.sortByAngle(e, n - .5), m > 0 && (x = Math.max(0, l - h - m), y = Math.min(l + h + m, i.plotHeight), e.forEach(t => {\n          (t.dataLabels || []).forEach(e => {\n            let s = e.dataLabelPosition;\n            s && s.distance > 0 && (s.top = Math.max(0, l - h - s.distance), s.bottom = Math.min(l + h + s.distance, i.plotHeight), b = e.getBBox().height || 21, e.lineHeight = i.renderer.fontMetrics(e.text || e).h + 2 * e.padding, t.distributeBox = {\n              target: (e.dataLabelPosition?.natural.y || 0) - s.top + e.lineHeight / 2,\n              size: b,\n              rank: t.y\n            }, u.push(t.distributeBox));\n          });\n        }), hJ(u, v = y + b - x, v / 5)), e.forEach(i => {\n          (i.dataLabels || []).forEach(l => {\n            let d = l.options || {},\n              m = i.distributeBox,\n              x = l.dataLabelPosition,\n              y = x?.natural.y || 0,\n              b = d.connectorPadding || 0,\n              v = l.lineHeight || 21,\n              M = (v - l.getBBox().height) / 2,\n              k = 0,\n              w = y,\n              S = \"inherit\";\n            if (x) {\n              if (u && h2(m) && x.distance > 0 && (void 0 === m.pos ? S = \"hidden\" : (f = m.size, w = p.radialDistributionY(i, l))), d.justify) k = p.justify(i, l, h, a);else switch (d.alignTo) {\n                case \"connectors\":\n                  k = p.alignToConnectors(e, n, s, r);\n                  break;\n                case \"plotEdges\":\n                  k = p.alignToPlotEdges(l, n, s, r);\n                  break;\n                default:\n                  k = p.radialDistributionX(t, i, w - M, y, l);\n              }\n              if (x.attribs = {\n                visibility: S,\n                align: x.alignment\n              }, x.posAttribs = {\n                x: k + (d.x || 0) + ({\n                  left: b,\n                  right: -b\n                }[x.alignment] || 0),\n                y: w + (d.y || 0) - v / 2\n              }, x.computed.x = k, x.computed.y = w - M, h3(d.crop, !0)) {\n                let t;\n                k - (g = l.getBBox().width) < b && 1 === n ? (t = Math.round(g - k + b), c[3] = Math.max(t, c[3])) : k + g > s - b && 0 === n && (t = Math.round(k + g - s + b), c[1] = Math.max(t, c[1])), w - f / 2 < 0 ? c[0] = Math.max(Math.round(-w + f / 2), c[0]) : w + f / 2 > o && (c[2] = Math.max(Math.round(w + f / 2 - o), c[2])), x.sideOverflow = t;\n              }\n            }\n          });\n        }));\n      }), (0 === h0(c) || this.verifyDataLabelOverflow(c)) && (this.placeDataLabels(), this.points.forEach(e => {\n        (e.dataLabels || []).forEach(s => {\n          let {\n              connectorColor: o,\n              connectorWidth: r = 1\n            } = s.options || {},\n            n = s.dataLabelPosition;\n          if (r) {\n            let a;\n            u = s.connector, n && n.distance > 0 ? (a = !u, u || (s.connector = u = i.renderer.path().addClass(\"highcharts-data-label-connector  highcharts-color-\" + e.colorIndex + (e.className ? \" \" + e.className : \"\")).add(t.dataLabelsGroup)), i.styledMode || u.attr({\n              \"stroke-width\": r,\n              stroke: o || e.color || \"#666666\"\n            }), u[a ? \"attr\" : \"animate\"]({\n              d: e.getConnectorPath(s)\n            }), u.attr({\n              visibility: n.attribs?.visibility\n            })) : u && (s.connector = u.destroy());\n          }\n        });\n      })));\n    }\n    function o() {\n      this.points.forEach(t => {\n        (t.dataLabels || []).forEach(t => {\n          let e = t.dataLabelPosition;\n          e ? (e.sideOverflow && (t.css({\n            width: Math.max(t.getBBox().width - e.sideOverflow, 0) + \"px\",\n            textOverflow: (t.options?.style || {}).textOverflow || \"ellipsis\"\n          }), t.shortened = !0), t.attr(e.attribs), t[t.moved ? \"animate\" : \"attr\"](e.posAttribs), t.moved = !0) : t && t.attr({\n            y: -9999\n          });\n        }), delete t.distributeBox;\n      }, this);\n    }\n    function r(t) {\n      let e = this.center,\n        i = this.options,\n        s = i.center,\n        o = i.minSize || 80,\n        r = o,\n        n = null !== i.size;\n      return !n && (null !== s[0] ? r = Math.max(e[2] - Math.max(t[1], t[3]), o) : (r = Math.max(e[2] - t[1] - t[3], o), e[0] += (t[3] - t[1]) / 2), null !== s[1] ? r = h1(r, o, e[2] - Math.max(t[0], t[2])) : (r = h1(r, o, e[2] - t[0] - t[2]), e[1] += (t[0] - t[2]) / 2), r < e[2] ? (e[2] = r, e[3] = Math.min(i.thickness ? Math.max(0, r - 2 * i.thickness) : Math.max(0, h6(i.innerSize || 0, r)), r), this.translate(e), this.drawDataLabels && this.drawDataLabels()) : n = !0), n;\n    }\n    t.compose = function (t) {\n      if (hp.compose(hQ), h5(hZ, \"PieDataLabel\")) {\n        let n = t.prototype;\n        n.dataLabelPositioners = e, n.alignDataLabel = hK, n.drawDataLabels = s, n.getDataLabelPosition = i, n.placeDataLabels = o, n.verifyDataLabelOverflow = r;\n      }\n    };\n  }(b || (b = {}));\n  let h9 = b;\n  !function (t) {\n    t.getCenterOfPoints = function (t) {\n      let e = t.reduce((t, e) => (t.x += e.x, t.y += e.y, t), {\n        x: 0,\n        y: 0\n      });\n      return {\n        x: e.x / t.length,\n        y: e.y / t.length\n      };\n    }, t.getDistanceBetweenPoints = function (t, e) {\n      return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));\n    }, t.getAngleBetweenPoints = function (t, e) {\n      return Math.atan2(e.x - t.x, e.y - t.y);\n    }, t.pointInPolygon = function ({\n      x: t,\n      y: e\n    }, i) {\n      let s = i.length,\n        o,\n        r,\n        n = !1;\n      for (o = 0, r = s - 1; o < s; r = o++) {\n        let [s, a] = i[o],\n          [h, l] = i[r];\n        a > e != l > e && t < (h - s) * (e - a) / (l - a) + s && (n = !n);\n      }\n      return n;\n    };\n  }(v || (v = {}));\n  let {\n      pointInPolygon: h4\n    } = v,\n    {\n      addEvent: h8,\n      fireEvent: h7,\n      objectEach: lt,\n      pick: le\n    } = tt;\n  function li(t) {\n    let e = t.length,\n      i = (t, e) => !(e.x >= t.x + t.width || e.x + e.width <= t.x || e.y >= t.y + t.height || e.y + e.height <= t.y),\n      s = (t, e) => {\n        for (let i of t) if (h4({\n          x: i[0],\n          y: i[1]\n        }, e)) return !0;\n        return !1;\n      },\n      o,\n      r,\n      n,\n      a,\n      h,\n      l = !1;\n    for (let i = 0; i < e; i++) (o = t[i]) && (o.oldOpacity = o.opacity, o.newOpacity = 1, o.absoluteBox = function (t) {\n      if (t && (!t.alignAttr || t.placed)) {\n        let e = t.box ? 0 : t.padding || 0,\n          i = t.alignAttr || {\n            x: t.attr(\"x\"),\n            y: t.attr(\"y\")\n          },\n          s = t.getBBox();\n        return t.width = s.width, t.height = s.height, {\n          x: i.x + (t.parentGroup?.translateX || 0) + e,\n          y: i.y + (t.parentGroup?.translateY || 0) + e,\n          width: (t.width || 0) - 2 * e,\n          height: (t.height || 0) - 2 * e,\n          polygon: s?.polygon\n        };\n      }\n    }(o));\n    t.sort((t, e) => (e.labelrank || 0) - (t.labelrank || 0));\n    for (let o = 0; o < e; ++o) {\n      a = (r = t[o]) && r.absoluteBox;\n      let l = a?.polygon;\n      for (let d = o + 1; d < e; ++d) {\n        h = (n = t[d]) && n.absoluteBox;\n        let e = !1;\n        if (a && h && r !== n && 0 !== r.newOpacity && 0 !== n.newOpacity && \"hidden\" !== r.visibility && \"hidden\" !== n.visibility) {\n          let t = h.polygon;\n          if (l && t && l !== t ? s(l, t) && (e = !0) : i(a, h) && (e = !0), e) {\n            let t = r.labelrank < n.labelrank ? r : n,\n              e = t.text;\n            t.newOpacity = 0, e?.element.querySelector(\"textPath\") && e.hide();\n          }\n        }\n      }\n    }\n    for (let e of t) ls(e, this) && (l = !0);\n    l && h7(this, \"afterHideAllOverlappingLabels\");\n  }\n  function ls(t, e) {\n    let i,\n      s,\n      o = !1;\n    return t && (s = t.newOpacity, t.oldOpacity !== s && (t.hasClass(\"highcharts-data-label\") ? (t[s ? \"removeClass\" : \"addClass\"](\"highcharts-data-label-hidden\"), i = function () {\n      e.styledMode || t.css({\n        pointerEvents: s ? \"auto\" : \"none\"\n      });\n    }, o = !0, t[t.isOld ? \"animate\" : \"attr\"]({\n      opacity: s\n    }, void 0, i), h7(e, \"afterHideOverlappingLabel\")) : t.attr({\n      opacity: s\n    })), t.isOld = !0), o;\n  }\n  function lo() {\n    let t = this,\n      e = [];\n    for (let i of t.labelCollectors || []) e = e.concat(i());\n    for (let i of t.yAxis || []) i.stacking && i.options.stackLabels && !i.options.stackLabels.allowOverlap && lt(i.stacking.stacks, t => {\n      lt(t, t => {\n        t.label && e.push(t.label);\n      });\n    });\n    for (let i of t.series || []) if (i.visible && i.hasDataLabels?.()) {\n      let s = i => {\n        for (let s of i) s.visible && (s.dataLabels || []).forEach(i => {\n          let o = i.options || {};\n          i.labelrank = le(o.labelrank, s.labelrank, s.shapeArgs?.height), o.allowOverlap ?? Number(o.distance) > 0 ? (i.oldOpacity = i.opacity, i.newOpacity = 1, ls(i, t)) : e.push(i);\n        });\n      };\n      s(i.nodes || []), s(i.points);\n    }\n    this.hideOverlappingLabels(e);\n  }\n  let lr = {\n      compose: function (t) {\n        let e = t.prototype;\n        e.hideOverlappingLabels || (e.hideOverlappingLabels = li, h8(t, \"render\", lo));\n      }\n    },\n    {\n      defaultOptions: ln\n    } = tS,\n    {\n      noop: la\n    } = O,\n    {\n      addEvent: lh,\n      extend: ll,\n      isObject: ld,\n      merge: lc,\n      relativeLength: lp\n    } = tt,\n    lu = {\n      radius: 0,\n      scope: \"stack\",\n      where: void 0\n    },\n    lg = la,\n    lf = la;\n  function lm(t, e, i, s, o = {}) {\n    let r = lg(t, e, i, s, o),\n      {\n        innerR: n = 0,\n        r: a = i,\n        start: h = 0,\n        end: l = 0\n      } = o;\n    if (o.open || !o.borderRadius) return r;\n    let d = l - h,\n      c = Math.sin(d / 2),\n      p = Math.max(Math.min(lp(o.borderRadius || 0, a - n), (a - n) / 2, a * c / (1 + c)), 0),\n      u = Math.min(p, d / Math.PI * 2 * n),\n      g = r.length - 1;\n    for (; g--;) !function (t, e, i) {\n      let s, o, r;\n      let n = t[e],\n        a = t[e + 1];\n      if (\"Z\" === a[0] && (a = t[0]), (\"M\" === n[0] || \"L\" === n[0]) && \"A\" === a[0] ? (s = n, o = a, r = !0) : \"A\" === n[0] && (\"M\" === a[0] || \"L\" === a[0]) && (s = a, o = n), s && o && o.params) {\n        let n = o[1],\n          a = o[5],\n          h = o.params,\n          {\n            start: l,\n            end: d,\n            cx: c,\n            cy: p\n          } = h,\n          u = a ? n - i : n + i,\n          g = u ? Math.asin(i / u) : 0,\n          f = a ? g : -g,\n          m = Math.cos(g) * u;\n        r ? (h.start = l + f, s[1] = c + m * Math.cos(l), s[2] = p + m * Math.sin(l), t.splice(e + 1, 0, [\"A\", i, i, 0, 0, 1, c + n * Math.cos(h.start), p + n * Math.sin(h.start)])) : (h.end = d - f, o[6] = c + n * Math.cos(h.end), o[7] = p + n * Math.sin(h.end), t.splice(e + 1, 0, [\"A\", i, i, 0, 0, 1, c + m * Math.cos(d), p + m * Math.sin(d)])), o[4] = Math.abs(h.end - h.start) < Math.PI ? 0 : 1;\n      }\n    }(r, g, g > 1 ? u : p);\n    return r;\n  }\n  function lx() {\n    if (this.options.borderRadius && !(this.chart.is3d && this.chart.is3d())) {\n      let {\n          options: t,\n          yAxis: e\n        } = this,\n        i = \"percent\" === t.stacking,\n        s = ln.plotOptions?.[this.type]?.borderRadius,\n        o = ly(t.borderRadius, ld(s) ? s : {}),\n        r = e.options.reversed;\n      for (let s of this.points) {\n        let {\n          shapeArgs: n\n        } = s;\n        if (\"roundedRect\" === s.shapeType && n) {\n          let {\n              width: a = 0,\n              height: h = 0,\n              y: l = 0\n            } = n,\n            d = l,\n            c = h;\n          if (\"stack\" === o.scope && s.stackTotal) {\n            let o = e.translate(i ? 100 : s.stackTotal, !1, !0, !1, !0),\n              r = e.translate(t.threshold || 0, !1, !0, !1, !0),\n              n = this.crispCol(0, Math.min(o, r), 0, Math.abs(o - r));\n            d = n.y, c = n.height;\n          }\n          let p = (s.negative ? -1 : 1) * (r ? -1 : 1) == -1,\n            u = o.where;\n          !u && this.is(\"waterfall\") && Math.abs((s.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth && (u = \"all\"), u || (u = \"end\");\n          let g = Math.min(lp(o.radius, a), a / 2, \"all\" === u ? h / 2 : 1 / 0) || 0;\n          \"end\" === u && (p && (d -= g), c += g), ll(n, {\n            brBoxHeight: c,\n            brBoxY: d,\n            r: g\n          });\n        }\n      }\n    }\n  }\n  function ly(t, e) {\n    return ld(t) || (t = {\n      radius: t || 0\n    }), lc(lu, e, t);\n  }\n  function lb() {\n    let t = ly(this.options.borderRadius);\n    for (let e of this.points) {\n      let i = e.shapeArgs;\n      i && (i.borderRadius = lp(t.radius, (i.r || 0) - (i.innerR || 0)));\n    }\n  }\n  function lv(t, e, i, s, o = {}) {\n    let r = lf(t, e, i, s, o),\n      {\n        r: n = 0,\n        brBoxHeight: a = s,\n        brBoxY: h = e\n      } = o,\n      l = e - h,\n      d = h + a - (e + s),\n      c = l - n > -.1 ? 0 : n,\n      p = d - n > -.1 ? 0 : n,\n      u = Math.max(c && l, 0),\n      g = Math.max(p && d, 0),\n      f = [t + c, e],\n      m = [t + i - c, e],\n      x = [t + i, e + c],\n      y = [t + i, e + s - p],\n      b = [t + i - p, e + s],\n      v = [t + p, e + s],\n      M = [t, e + s - p],\n      k = [t, e + c],\n      w = (t, e) => Math.sqrt(Math.pow(t, 2) - Math.pow(e, 2));\n    if (u) {\n      let t = w(c, c - u);\n      f[0] -= t, m[0] += t, x[1] = k[1] = e + c - u;\n    }\n    if (s < c - u) {\n      let o = w(c, c - u - s);\n      x[0] = y[0] = t + i - c + o, b[0] = Math.min(x[0], b[0]), v[0] = Math.max(y[0], v[0]), M[0] = k[0] = t + c - o, x[1] = k[1] = e + s;\n    }\n    if (g) {\n      let t = w(p, p - g);\n      b[0] += t, v[0] -= t, y[1] = M[1] = e + s - p + g;\n    }\n    if (s < p - g) {\n      let o = w(p, p - g - s);\n      x[0] = y[0] = t + i - p + o, m[0] = Math.min(x[0], m[0]), f[0] = Math.max(y[0], f[0]), M[0] = k[0] = t + p - o, y[1] = M[1] = e;\n    }\n    return r.length = 0, r.push([\"M\", ...f], [\"L\", ...m], [\"A\", c, c, 0, 0, 1, ...x], [\"L\", ...y], [\"A\", p, p, 0, 0, 1, ...b], [\"L\", ...v], [\"A\", p, p, 0, 0, 1, ...M], [\"L\", ...k], [\"A\", c, c, 0, 0, 1, ...f], [\"Z\"]), r;\n  }\n  let {\n    diffObjects: lM,\n    extend: lk,\n    find: lw,\n    merge: lS,\n    pick: lA,\n    uniqueKey: lT\n  } = tt;\n  !function (t) {\n    function e(t, e) {\n      let i = t.condition;\n      (i.callback || function () {\n        return this.chartWidth <= lA(i.maxWidth, Number.MAX_VALUE) && this.chartHeight <= lA(i.maxHeight, Number.MAX_VALUE) && this.chartWidth >= lA(i.minWidth, 0) && this.chartHeight >= lA(i.minHeight, 0);\n      }).call(this) && e.push(t._id);\n    }\n    function i(t, e) {\n      let i = this.options.responsive,\n        s = this.currentResponsive,\n        o = [],\n        r;\n      !e && i && i.rules && i.rules.forEach(t => {\n        void 0 === t._id && (t._id = lT()), this.matchResponsiveRule(t, o);\n      }, this);\n      let n = lS(...o.map(t => lw((i || {}).rules || [], e => e._id === t)).map(t => t && t.chartOptions));\n      n.isResponsiveOptions = !0, o = o.toString() || void 0;\n      let a = s && s.ruleIds;\n      o === a || (s && (this.currentResponsive = void 0, this.updatingResponsive = !0, this.update(s.undoOptions, t, !0), this.updatingResponsive = !1), o ? ((r = lM(n, this.options, !0, this.collectionsWithUpdate)).isResponsiveOptions = !0, this.currentResponsive = {\n        ruleIds: o,\n        mergedOptions: n,\n        undoOptions: r\n      }, this.updatingResponsive || this.update(n, t, !0)) : this.currentResponsive = void 0);\n    }\n    t.compose = function (t) {\n      let s = t.prototype;\n      return s.matchResponsiveRule || lk(s, {\n        matchResponsiveRule: e,\n        setResponsive: i\n      }), t;\n    };\n  }(M || (M = {}));\n  let lP = M;\n  function lC(t, e, i, s) {\n    return [[\"M\", t, e + s / 2], [\"L\", t + i, e], [\"L\", t, e + s / 2], [\"L\", t + i, e + s]];\n  }\n  function lO(t, e, i, s) {\n    return lC(t, e, i / 2, s);\n  }\n  function lE(t, e, i, s) {\n    return [[\"M\", t + i, e], [\"L\", t, e + s / 2], [\"L\", t + i, e + s], [\"Z\"]];\n  }\n  function lL(t, e, i, s) {\n    return lE(t, e, i / 2, s);\n  }\n  O.AST = t6, O.Axis = sU, O.Chart = nK, O.Color = tO, O.DataLabel = hp, O.DataTableCore = rl, O.Fx = tD, O.HTMLElement = i5, O.Legend = nd, O.LegendSymbol = ru, O.OverlappingDataLabels = O.OverlappingDataLabels || lr, O.PlotLineOrBand = or, O.Point = oq, O.Pointer = ro, O.RendererRegistry = eu, O.Series = rK, O.SeriesRegistry = ry, O.StackItem = aa, O.SVGElement = eJ, O.SVGRenderer = iU, O.Templating = ep, O.Tick = sg, O.Time = ty, O.Tooltip = oO, O.animate = tU.animate, O.animObject = tU.animObject, O.chart = nK.chart, O.color = tO.parse, O.dateFormat = ep.dateFormat, O.defaultOptions = tS.defaultOptions, O.distribute = ey.distribute, O.format = ep.format, O.getDeferredAnimation = tU.getDeferredAnimation, O.getOptions = tS.getOptions, O.numberFormat = ep.numberFormat, O.seriesType = ry.seriesType, O.setAnimation = tU.setAnimation, O.setOptions = tS.setOptions, O.stop = tU.stop, O.time = tS.defaultTime, O.timers = tD.timers, {\n    compose: function (t, e, i) {\n      let s = t.types.pie;\n      if (!e.symbolCustomAttribs.includes(\"borderRadius\")) {\n        let o = i.prototype.symbols;\n        lh(t, \"afterColumnTranslate\", lx, {\n          order: 9\n        }), lh(s, \"afterTranslate\", lb), e.symbolCustomAttribs.push(\"borderRadius\", \"brBoxHeight\", \"brBoxY\"), lg = o.arc, lf = o.roundedRect, o.arc = lm, o.roundedRect = lv;\n      }\n    },\n    optionsToObject: ly\n  }.compose(O.Series, O.SVGElement, O.SVGRenderer), hy.compose(O.Series.types.column), hp.compose(O.Series), sZ.compose(O.Axis), i5.compose(O.SVGRenderer), nd.compose(O.Chart), s0.compose(O.Axis), lr.compose(O.Chart), h9.compose(O.Series.types.pie), or.compose(O.Chart, O.Axis), ro.compose(O.Chart), lP.compose(O.Chart), n7.compose(O.Axis, O.Chart, O.Series), aP.compose(O.Axis, O.Chart, O.Series), oO.compose(O.Pointer), tt.extend(O, tt);\n  let lB = {\n      compose: function (t) {\n        let e = t.prototype.symbols;\n        e.arrow = lC, e[\"arrow-filled\"] = lE, e[\"arrow-filled-half\"] = lL, e[\"arrow-half\"] = lO, e[\"triangle-left\"] = lE, e[\"triangle-left-half\"] = lL;\n      }\n    },\n    {\n      defined: lI,\n      error: lD,\n      merge: lR,\n      objectEach: lN\n    } = tt,\n    lz = O.deg2rad,\n    lW = Math.max,\n    lG = Math.min,\n    lH = class {\n      constructor(t, e, i) {\n        this.init(t, e, i);\n      }\n      init(t, e, i) {\n        this.fromPoint = t, this.toPoint = e, this.options = i, this.chart = t.series.chart, this.pathfinder = this.chart.pathfinder;\n      }\n      renderPath(t, e) {\n        let i = this.chart,\n          s = i.styledMode,\n          o = this.pathfinder,\n          r = {},\n          n = this.graphics && this.graphics.path;\n        o.group || (o.group = i.renderer.g().addClass(\"highcharts-pathfinder-group\").attr({\n          zIndex: -1\n        }).add(i.seriesGroup)), o.group.translate(i.plotLeft, i.plotTop), n && n.renderer || (n = i.renderer.path().add(o.group), s || n.attr({\n          opacity: 0\n        })), n.attr(e), r.d = t, s || (r.opacity = 1), n.animate(r), this.graphics = this.graphics || {}, this.graphics.path = n;\n      }\n      addMarker(t, e, i) {\n        let s, o, r, n, a, h, l, d;\n        let c = this.fromPoint.series.chart,\n          p = c.pathfinder,\n          u = c.renderer,\n          g = \"start\" === t ? this.fromPoint : this.toPoint,\n          f = g.getPathfinderAnchorPoint(e);\n        e.enabled && ((d = \"start\" === t ? i[1] : i[i.length - 2]) && \"M\" === d[0] || \"L\" === d[0]) && (l = {\n          x: d[1],\n          y: d[2]\n        }, o = g.getRadiansToVector(l, f), s = g.getMarkerVector(o, e.radius, f), r = -o / lz, e.width && e.height ? (a = e.width, h = e.height) : a = h = 2 * e.radius, this.graphics = this.graphics || {}, n = {\n          x: s.x - a / 2,\n          y: s.y - h / 2,\n          width: a,\n          height: h,\n          rotation: r,\n          rotationOriginX: s.x,\n          rotationOriginY: s.y\n        }, this.graphics[t] ? this.graphics[t].animate(n) : (this.graphics[t] = u.symbol(e.symbol).addClass(\"highcharts-point-connecting-path-\" + t + \"-marker highcharts-color-\" + this.fromPoint.colorIndex).attr(n).add(p.group), u.styledMode || this.graphics[t].attr({\n          fill: e.color || this.fromPoint.color,\n          stroke: e.lineColor,\n          \"stroke-width\": e.lineWidth,\n          opacity: 0\n        }).animate({\n          opacity: 1\n        }, g.series.options.animation)));\n      }\n      getPath(t) {\n        let e = this.pathfinder,\n          i = this.chart,\n          s = e.algorithms[t.type],\n          o = e.chartObstacles;\n        return \"function\" != typeof s ? (lD('\"' + t.type + '\" is not a Pathfinder algorithm.'), {\n          path: [],\n          obstacles: []\n        }) : (s.requiresObstacles && !o && (o = e.chartObstacles = e.getChartObstacles(t), i.options.connectors.algorithmMargin = t.algorithmMargin, e.chartObstacleMetrics = e.getObstacleMetrics(o)), s(this.fromPoint.getPathfinderAnchorPoint(t.startMarker), this.toPoint.getPathfinderAnchorPoint(t.endMarker), lR({\n          chartObstacles: o,\n          lineObstacles: e.lineObstacles || [],\n          obstacleMetrics: e.chartObstacleMetrics,\n          hardBounds: {\n            xMin: 0,\n            xMax: i.plotWidth,\n            yMin: 0,\n            yMax: i.plotHeight\n          },\n          obstacleOptions: {\n            margin: t.algorithmMargin\n          },\n          startDirectionX: e.getAlgorithmStartDirection(t.startMarker)\n        }, t)));\n      }\n      render() {\n        let t = this.fromPoint,\n          e = t.series,\n          i = e.chart,\n          s = i.pathfinder,\n          o = {},\n          r = lR(i.options.connectors, e.options.connectors, t.options.connectors, this.options);\n        !i.styledMode && (o.stroke = r.lineColor || t.color, o[\"stroke-width\"] = r.lineWidth, r.dashStyle && (o.dashstyle = r.dashStyle)), o.class = \"highcharts-point-connecting-path highcharts-color-\" + t.colorIndex, lI((r = lR(o, r)).marker.radius) || (r.marker.radius = lG(lW(Math.ceil((r.algorithmMargin || 8) / 2) - 1, 1), 5));\n        let n = this.getPath(r),\n          a = n.path;\n        n.obstacles && (s.lineObstacles = s.lineObstacles || [], s.lineObstacles = s.lineObstacles.concat(n.obstacles)), this.renderPath(a, o), this.addMarker(\"start\", lR(r.marker, r.startMarker), a), this.addMarker(\"end\", lR(r.marker, r.endMarker), a);\n      }\n      destroy() {\n        this.graphics && (lN(this.graphics, function (t) {\n          t.destroy();\n        }), delete this.graphics);\n      }\n    },\n    {\n      composed: lF\n    } = O,\n    {\n      addEvent: lX,\n      merge: lY,\n      pushUnique: lj,\n      wrap: lU\n    } = tt,\n    lV = {\n      color: \"#ccd3ff\",\n      width: 2,\n      label: {\n        format: \"%[abdYHM]\",\n        formatter: function (t, e) {\n          return this.axis.chart.time.dateFormat(e || \"\", t, !0);\n        },\n        rotation: 0,\n        style: {\n          fontSize: \"0.7em\"\n        }\n      }\n    };\n  function l$() {\n    let t = this.options,\n      e = t.currentDateIndicator;\n    if (e) {\n      let i = \"object\" == typeof e ? lY(lV, e) : lY(lV);\n      i.value = Date.now(), i.className = \"highcharts-current-date-indicator\", t.plotLines || (t.plotLines = []), t.plotLines.push(i);\n    }\n  }\n  function l_() {\n    this.label && this.label.attr({\n      text: this.getLabelText(this.options.label)\n    });\n  }\n  function lq(t, e) {\n    let i = this.options;\n    return i && i.className && -1 !== i.className.indexOf(\"highcharts-current-date-indicator\") && i.label && \"function\" == typeof i.label.formatter ? (i.value = Date.now(), i.label.formatter.call(this, i.value, i.label.format)) : t.call(this, e);\n  }\n  let {\n      defaultOptions: lZ\n    } = tS,\n    {\n      isArray: lK,\n      merge: lJ,\n      splat: lQ\n    } = tt;\n  class l0 extends nK {\n    init(t, e) {\n      let i;\n      let s = t.xAxis,\n        o = t.yAxis;\n      t.xAxis = t.yAxis = void 0;\n      let r = lJ(!0, {\n        chart: {\n          type: \"gantt\"\n        },\n        title: {\n          text: \"\"\n        },\n        legend: {\n          enabled: !1\n        },\n        navigator: {\n          series: {\n            type: \"gantt\"\n          },\n          yAxis: {\n            type: \"category\"\n          }\n        }\n      }, t, {\n        isGantt: !0\n      });\n      t.xAxis = s, t.yAxis = o, r.xAxis = (lK(t.xAxis) ? t.xAxis : [t.xAxis || {}, {}]).map((t, e) => (1 === e && (i = 0), lJ({\n        grid: {\n          borderColor: \"#cccccc\",\n          enabled: !0\n        },\n        opposite: lZ.xAxis?.opposite ?? t.opposite ?? !0,\n        linkedTo: i\n      }, t, {\n        type: \"datetime\"\n      }))), r.yAxis = lQ(t.yAxis || {}).map(t => lJ({\n        grid: {\n          borderColor: \"#cccccc\",\n          enabled: !0\n        },\n        staticScale: 50,\n        reversed: !0,\n        type: t.categories ? t.type : \"treegrid\"\n      }, t)), super.init(r, e);\n    }\n  }\n  !function (t) {\n    t.ganttChart = function (e, i, s) {\n      return new t(e, i, s);\n    };\n  }(l0 || (l0 = {}));\n  let l1 = l0,\n    {\n      isTouchDevice: l2\n    } = O,\n    {\n      addEvent: l3,\n      merge: l5,\n      pick: l6\n    } = tt,\n    l9 = [];\n  function l4() {\n    this.navigator && this.navigator.setBaseSeries(null, !1);\n  }\n  function l8() {\n    let t, e, i;\n    let s = this.legend,\n      o = this.navigator;\n    if (o) {\n      t = s && s.options, e = o.xAxis, i = o.yAxis;\n      let {\n        scrollbarHeight: r,\n        scrollButtonSize: n\n      } = o;\n      this.inverted ? (o.left = o.opposite ? this.chartWidth - r - o.height : this.spacing[3] + r, o.top = this.plotTop + n) : (o.left = l6(e.left, this.plotLeft + n), o.top = o.navigatorOptions.top || this.chartHeight - o.height - r - (this.scrollbar?.options.margin || 0) - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (t && \"bottom\" === t.verticalAlign && \"proximate\" !== t.layout && t.enabled && !t.floating ? s.legendHeight + l6(t.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0)), e && i && (this.inverted ? e.options.left = i.options.left = o.left : e.options.top = i.options.top = o.top, e.setAxisSize(), i.setAxisSize());\n    }\n  }\n  function l7(t) {\n    !this.navigator && !this.scroller && (this.options.navigator.enabled || this.options.scrollbar.enabled) && (this.scroller = this.navigator = new i(this), l6(t.redraw, !0) && this.redraw(t.animation));\n  }\n  function dt() {\n    let t = this.options;\n    (t.navigator.enabled || t.scrollbar.enabled) && (this.scroller = this.navigator = new i(this));\n  }\n  function de() {\n    let t = this.options,\n      e = t.navigator,\n      i = t.rangeSelector;\n    if ((e && e.enabled || i && i.enabled) && (!l2 && \"x\" === this.zooming.type || l2 && \"x\" === this.zooming.pinchType)) return !1;\n  }\n  function di(t) {\n    let e = t.navigator;\n    if (e && t.xAxis[0]) {\n      let i = t.xAxis[0].getExtremes();\n      e.render(i.min, i.max);\n    }\n  }\n  function ds(t) {\n    let e = t.options.navigator || {},\n      i = t.options.scrollbar || {};\n    !this.navigator && !this.scroller && (e.enabled || i.enabled) && (l5(!0, this.options.navigator, e), l5(!0, this.options.scrollbar, i), delete t.options.navigator, delete t.options.scrollbar);\n  }\n  let dr = {\n      compose: function (t, e) {\n        if (tt.pushUnique(l9, t)) {\n          let s = t.prototype;\n          i = e, s.callbacks.push(di), l3(t, \"afterAddSeries\", l4), l3(t, \"afterSetChartSize\", l8), l3(t, \"afterUpdate\", l7), l3(t, \"beforeRender\", dt), l3(t, \"beforeShowResetZoom\", de), l3(t, \"update\", ds);\n        }\n      }\n    },\n    {\n      isTouchDevice: dn\n    } = O,\n    {\n      addEvent: da,\n      correctFloat: dh,\n      defined: dl,\n      isNumber: dd,\n      pick: dc\n    } = tt;\n  function dp() {\n    this.navigatorAxis || (this.navigatorAxis = new dg(this));\n  }\n  function du(t) {\n    let e;\n    let i = this.chart,\n      s = i.options,\n      o = s.navigator,\n      r = this.navigatorAxis,\n      n = i.zooming.pinchType,\n      a = s.rangeSelector,\n      h = i.zooming.type;\n    if (this.isXAxis && (o?.enabled || a?.enabled)) {\n      if (\"y\" === h && \"zoom\" === t.trigger) e = !1;else if ((\"zoom\" === t.trigger && \"xy\" === h || dn && \"xy\" === n) && this.options.range) {\n        let e = r.previousZoom;\n        dl(t.min) ? r.previousZoom = [this.min, this.max] : e && (t.min = e[0], t.max = e[1], r.previousZoom = void 0);\n      }\n    }\n    void 0 !== e && t.preventDefault();\n  }\n  class dg {\n    static compose(t) {\n      t.keepProps.includes(\"navigatorAxis\") || (t.keepProps.push(\"navigatorAxis\"), da(t, \"init\", dp), da(t, \"setExtremes\", du));\n    }\n    constructor(t) {\n      this.axis = t;\n    }\n    destroy() {\n      this.axis = void 0;\n    }\n    toFixedRange(t, e, i, s) {\n      let o = this.axis,\n        r = (o.pointRange || 0) / 2,\n        n = dc(i, o.translate(t, !0, !o.horiz)),\n        a = dc(s, o.translate(e, !0, !o.horiz));\n      return dl(i) || (n = dh(n + r)), dl(s) || (a = dh(a - r)), dd(n) && dd(a) || (n = a = void 0), {\n        min: n,\n        max: a\n      };\n    }\n  }\n  let {\n      parse: df\n    } = tO,\n    {\n      seriesTypes: dm\n    } = ry,\n    dx = {\n      height: 40,\n      margin: 25,\n      maskInside: !0,\n      handles: {\n        width: 7,\n        borderRadius: 0,\n        height: 15,\n        symbols: [\"navigator-handle\", \"navigator-handle\"],\n        enabled: !0,\n        lineWidth: 1,\n        backgroundColor: \"#f2f2f2\",\n        borderColor: \"#999999\"\n      },\n      maskFill: df(\"#667aff\").setOpacity(.3).get(),\n      outlineColor: \"#999999\",\n      outlineWidth: 1,\n      series: {\n        type: void 0 === dm.areaspline ? \"line\" : \"areaspline\",\n        fillOpacity: .05,\n        lineWidth: 1,\n        compare: null,\n        sonification: {\n          enabled: !1\n        },\n        dataGrouping: {\n          approximation: \"average\",\n          enabled: !0,\n          groupPixelWidth: 2,\n          firstAnchor: \"firstPoint\",\n          anchor: \"middle\",\n          lastAnchor: \"lastPoint\",\n          units: [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2, 3, 4]], [\"week\", [1, 2, 3]], [\"month\", [1, 3, 6]], [\"year\", null]]\n        },\n        dataLabels: {\n          enabled: !1,\n          zIndex: 2\n        },\n        id: \"highcharts-navigator-series\",\n        className: \"highcharts-navigator-series\",\n        lineColor: null,\n        marker: {\n          enabled: !1\n        },\n        threshold: null\n      },\n      xAxis: {\n        className: \"highcharts-navigator-xaxis\",\n        tickLength: 0,\n        lineWidth: 0,\n        gridLineColor: \"#e6e6e6\",\n        id: \"navigator-x-axis\",\n        gridLineWidth: 1,\n        tickPixelInterval: 200,\n        labels: {\n          align: \"left\",\n          style: {\n            color: \"#000000\",\n            fontSize: \"0.7em\",\n            opacity: .6,\n            textOutline: \"2px contrast\"\n          },\n          x: 3,\n          y: -4\n        },\n        crosshair: !1\n      },\n      yAxis: {\n        className: \"highcharts-navigator-yaxis\",\n        gridLineWidth: 0,\n        startOnTick: !1,\n        endOnTick: !1,\n        minPadding: .1,\n        id: \"navigator-y-axis\",\n        maxPadding: .1,\n        labels: {\n          enabled: !1\n        },\n        crosshair: !1,\n        title: {\n          text: null\n        },\n        tickLength: 0,\n        tickWidth: 0\n      }\n    },\n    {\n      relativeLength: dy\n    } = tt,\n    db = {\n      \"navigator-handle\": function (t, e, i, s, o = {}) {\n        let r = o.width ? o.width / 2 : i,\n          n = dy(o.borderRadius || 0, Math.min(2 * r, s));\n        return [[\"M\", -1.5, (s = o.height || s) / 2 - 3.5], [\"L\", -1.5, s / 2 + 4.5], [\"M\", .5, s / 2 - 3.5], [\"L\", .5, s / 2 + 4.5], ...is.rect(-r - 1, .5, 2 * r + 1, s, {\n          r: n\n        })];\n      }\n    },\n    {\n      defined: dv\n    } = tt,\n    {\n      setOptions: dM\n    } = tS,\n    {\n      composed: dk\n    } = O,\n    {\n      getRendererType: dw\n    } = eu,\n    {\n      setFixedRange: dS\n    } = {\n      setFixedRange: function (t) {\n        let e = this.xAxis[0];\n        dv(e.dataMax) && dv(e.dataMin) && t ? this.fixedRange = Math.min(t, e.dataMax - e.dataMin) : this.fixedRange = t;\n      }\n    },\n    {\n      addEvent: dA,\n      extend: dT,\n      pushUnique: dP\n    } = tt;\n  function dC() {\n    this.chart.navigator && !this.options.isInternal && this.chart.navigator.setBaseSeries(null, !1);\n  }\n  let dO = {\n      compose: function (t, e, i) {\n        dg.compose(e), dP(dk, \"Navigator\") && (t.prototype.setFixedRange = dS, dT(dw().prototype.symbols, db), dA(i, \"afterUpdate\", dC), dM({\n          navigator: dx\n        }));\n      }\n    },\n    {\n      composed: dE\n    } = O,\n    {\n      addEvent: dL,\n      defined: dB,\n      pick: dI,\n      pushUnique: dD\n    } = tt;\n  !function (t) {\n    let e;\n    function i(t) {\n      let e = dI(t.options && t.options.min, t.min),\n        i = dI(t.options && t.options.max, t.max);\n      return {\n        axisMin: e,\n        axisMax: i,\n        scrollMin: dB(t.dataMin) ? Math.min(e, t.min, t.dataMin, dI(t.threshold, 1 / 0)) : e,\n        scrollMax: dB(t.dataMax) ? Math.max(i, t.max, t.dataMax, dI(t.threshold, -1 / 0)) : i\n      };\n    }\n    function s() {\n      let t = this.scrollbar,\n        e = t && !t.options.opposite,\n        i = this.horiz ? 2 : e ? 3 : 1;\n      t && (this.chart.scrollbarsOffsets = [0, 0], this.chart.axisOffset[i] += t.size + (t.options.margin || 0));\n    }\n    function o() {\n      let t = this;\n      t.options && t.options.scrollbar && t.options.scrollbar.enabled && (t.options.scrollbar.vertical = !t.horiz, t.options.startOnTick = t.options.endOnTick = !1, t.scrollbar = new e(t.chart.renderer, t.options.scrollbar, t.chart), dL(t.scrollbar, \"changed\", function (e) {\n        let s, o;\n        let {\n            axisMin: r,\n            axisMax: n,\n            scrollMin: a,\n            scrollMax: h\n          } = i(t),\n          l = h - a;\n        if (dB(r) && dB(n)) {\n          if (t.horiz && !t.reversed || !t.horiz && t.reversed ? (s = a + l * this.to, o = a + l * this.from) : (s = a + l * (1 - this.from), o = a + l * (1 - this.to)), this.shouldUpdateExtremes(e.DOMType)) {\n            let i = \"mousemove\" !== e.DOMType && \"touchmove\" !== e.DOMType && void 0;\n            t.setExtremes(o, s, !0, i, e);\n          } else this.setRange(this.from, this.to);\n        }\n      }));\n    }\n    function r() {\n      let t, e, s;\n      let {\n          scrollMin: o,\n          scrollMax: r\n        } = i(this),\n        n = this.scrollbar,\n        a = this.axisTitleMargin + (this.titleOffset || 0),\n        h = this.chart.scrollbarsOffsets,\n        l = this.options.margin || 0;\n      if (n && h) {\n        if (this.horiz) this.opposite || (h[1] += a), n.position(this.left, this.top + this.height + 2 + h[1] - (this.opposite ? l : 0), this.width, this.height), this.opposite || (h[1] += l), t = 1;else {\n          let e;\n          this.opposite && (h[0] += a), e = n.options.opposite ? this.left + this.width + 2 + h[0] - (this.opposite ? 0 : l) : this.opposite ? 0 : l, n.position(e, this.top, this.width, this.height), this.opposite && (h[0] += l), t = 0;\n        }\n        if (h[t] += n.size + (n.options.margin || 0), isNaN(o) || isNaN(r) || !dB(this.min) || !dB(this.max) || this.dataMin === this.dataMax) n.setRange(0, 1);else if (this.min === this.max) {\n          let t = this.pointRange / (this.dataMax + 1);\n          e = t * this.min, s = t * (this.max + 1), n.setRange(e, s);\n        } else e = (this.min - o) / (r - o), s = (this.max - o) / (r - o), this.horiz && !this.reversed || !this.horiz && this.reversed ? n.setRange(e, s) : n.setRange(1 - s, 1 - e);\n      }\n    }\n    t.compose = function (t, i) {\n      dD(dE, \"Axis.Scrollbar\") && (e = i, dL(t, \"afterGetOffset\", s), dL(t, \"afterInit\", o), dL(t, \"afterRender\", r));\n    };\n  }(k || (k = {}));\n  let dR = k,\n    dN = {\n      height: 10,\n      barBorderRadius: 5,\n      buttonBorderRadius: 0,\n      buttonsEnabled: !1,\n      liveRedraw: void 0,\n      margin: void 0,\n      minWidth: 6,\n      opposite: !0,\n      step: .2,\n      zIndex: 3,\n      barBackgroundColor: \"#cccccc\",\n      barBorderWidth: 0,\n      barBorderColor: \"#cccccc\",\n      buttonArrowColor: \"#333333\",\n      buttonBackgroundColor: \"#e6e6e6\",\n      buttonBorderColor: \"#cccccc\",\n      buttonBorderWidth: 1,\n      rifleColor: \"none\",\n      trackBackgroundColor: \"rgba(255, 255, 255, 0.001)\",\n      trackBorderColor: \"#cccccc\",\n      trackBorderRadius: 5,\n      trackBorderWidth: 1\n    },\n    {\n      defaultOptions: dz\n    } = tS,\n    {\n      addEvent: dW,\n      correctFloat: dG,\n      crisp: dH,\n      defined: dF,\n      destroyObjectProperties: dX,\n      fireEvent: dY,\n      merge: dj,\n      pick: dU,\n      removeEvent: dV\n    } = tt;\n  class d$ {\n    static compose(t) {\n      dR.compose(t, d$);\n    }\n    static swapXY(t, e) {\n      return e && t.forEach(t => {\n        let e;\n        let i = t.length;\n        for (let s = 0; s < i; s += 2) \"number\" == typeof (e = t[s + 1]) && (t[s + 1] = t[s + 2], t[s + 2] = e);\n      }), t;\n    }\n    constructor(t, e, i) {\n      this._events = [], this.chartX = 0, this.chartY = 0, this.from = 0, this.scrollbarButtons = [], this.scrollbarLeft = 0, this.scrollbarStrokeWidth = 1, this.scrollbarTop = 0, this.size = 0, this.to = 0, this.trackBorderWidth = 1, this.x = 0, this.y = 0, this.init(t, e, i);\n    }\n    addEvents() {\n      let t = this.options.inverted ? [1, 0] : [0, 1],\n        e = this.scrollbarButtons,\n        i = this.scrollbarGroup.element,\n        s = this.track.element,\n        o = this.mouseDownHandler.bind(this),\n        r = this.mouseMoveHandler.bind(this),\n        n = this.mouseUpHandler.bind(this),\n        a = [[e[t[0]].element, \"click\", this.buttonToMinClick.bind(this)], [e[t[1]].element, \"click\", this.buttonToMaxClick.bind(this)], [s, \"click\", this.trackClick.bind(this)], [i, \"mousedown\", o], [i.ownerDocument, \"mousemove\", r], [i.ownerDocument, \"mouseup\", n], [i, \"touchstart\", o], [i.ownerDocument, \"touchmove\", r], [i.ownerDocument, \"touchend\", n]];\n      a.forEach(function (t) {\n        dW.apply(null, t);\n      }), this._events = a;\n    }\n    buttonToMaxClick(t) {\n      let e = (this.to - this.from) * dU(this.options.step, .2);\n      this.updatePosition(this.from + e, this.to + e), dY(this, \"changed\", {\n        from: this.from,\n        to: this.to,\n        trigger: \"scrollbar\",\n        DOMEvent: t\n      });\n    }\n    buttonToMinClick(t) {\n      let e = dG(this.to - this.from) * dU(this.options.step, .2);\n      this.updatePosition(dG(this.from - e), dG(this.to - e)), dY(this, \"changed\", {\n        from: this.from,\n        to: this.to,\n        trigger: \"scrollbar\",\n        DOMEvent: t\n      });\n    }\n    cursorToScrollbarPosition(t) {\n      let e = this.options,\n        i = e.minWidth > this.calculatedWidth ? e.minWidth : 0;\n      return {\n        chartX: (t.chartX - this.x - this.xOffset) / (this.barWidth - i),\n        chartY: (t.chartY - this.y - this.yOffset) / (this.barWidth - i)\n      };\n    }\n    destroy() {\n      let t = this,\n        e = t.chart.scroller;\n      t.removeEvents(), [\"track\", \"scrollbarRifles\", \"scrollbar\", \"scrollbarGroup\", \"group\"].forEach(function (e) {\n        t[e] && t[e].destroy && (t[e] = t[e].destroy());\n      }), e && t === e.scrollbar && (e.scrollbar = null, dX(e.scrollbarButtons));\n    }\n    drawScrollbarButton(t) {\n      let e = this.renderer,\n        i = this.scrollbarButtons,\n        s = this.options,\n        o = this.size,\n        r = e.g().add(this.group);\n      if (i.push(r), s.buttonsEnabled) {\n        let n = e.rect().addClass(\"highcharts-scrollbar-button\").add(r);\n        this.chart.styledMode || n.attr({\n          stroke: s.buttonBorderColor,\n          \"stroke-width\": s.buttonBorderWidth,\n          fill: s.buttonBackgroundColor\n        }), n.attr(n.crisp({\n          x: -.5,\n          y: -.5,\n          width: o,\n          height: o,\n          r: s.buttonBorderRadius\n        }, n.strokeWidth()));\n        let a = e.path(d$.swapXY([[\"M\", o / 2 + (t ? -1 : 1), o / 2 - 3], [\"L\", o / 2 + (t ? -1 : 1), o / 2 + 3], [\"L\", o / 2 + (t ? 2 : -2), o / 2]], s.vertical)).addClass(\"highcharts-scrollbar-arrow\").add(i[t]);\n        this.chart.styledMode || a.attr({\n          fill: s.buttonArrowColor\n        });\n      }\n    }\n    init(t, e, i) {\n      this.scrollbarButtons = [], this.renderer = t, this.userOptions = e, this.options = dj(dN, dz.scrollbar, e), this.options.margin = dU(this.options.margin, 10), this.chart = i, this.size = dU(this.options.size, this.options.height), e.enabled && (this.render(), this.addEvents());\n    }\n    mouseDownHandler(t) {\n      let e = this.chart.pointer?.normalize(t) || t,\n        i = this.cursorToScrollbarPosition(e);\n      this.chartX = i.chartX, this.chartY = i.chartY, this.initPositions = [this.from, this.to], this.grabbedCenter = !0;\n    }\n    mouseMoveHandler(t) {\n      let e;\n      let i = this.chart.pointer?.normalize(t) || t,\n        s = this.options.vertical ? \"chartY\" : \"chartX\",\n        o = this.initPositions || [];\n      this.grabbedCenter && (!t.touches || 0 !== t.touches[0][s]) && (e = this.cursorToScrollbarPosition(i)[s] - this[s], this.hasDragged = !0, this.updatePosition(o[0] + e, o[1] + e), this.hasDragged && dY(this, \"changed\", {\n        from: this.from,\n        to: this.to,\n        trigger: \"scrollbar\",\n        DOMType: t.type,\n        DOMEvent: t\n      }));\n    }\n    mouseUpHandler(t) {\n      this.hasDragged && dY(this, \"changed\", {\n        from: this.from,\n        to: this.to,\n        trigger: \"scrollbar\",\n        DOMType: t.type,\n        DOMEvent: t\n      }), this.grabbedCenter = this.hasDragged = this.chartX = this.chartY = null;\n    }\n    position(t, e, i, s) {\n      let {\n          buttonsEnabled: o,\n          margin: r = 0,\n          vertical: n\n        } = this.options,\n        a = this.rendered ? \"animate\" : \"attr\",\n        h = s,\n        l = 0;\n      this.group.show(), this.x = t, this.y = e + this.trackBorderWidth, this.width = i, this.height = s, this.xOffset = h, this.yOffset = l, n ? (this.width = this.yOffset = i = l = this.size, this.xOffset = h = 0, this.yOffset = l = o ? this.size : 0, this.barWidth = s - (o ? 2 * i : 0), this.x = t += r) : (this.height = s = this.size, this.xOffset = h = o ? this.size : 0, this.barWidth = i - (o ? 2 * s : 0), this.y = this.y + r), this.group[a]({\n        translateX: t,\n        translateY: this.y\n      }), this.track[a]({\n        width: i,\n        height: s\n      }), this.scrollbarButtons[1][a]({\n        translateX: n ? 0 : i - h,\n        translateY: n ? s - l : 0\n      });\n    }\n    removeEvents() {\n      this._events.forEach(function (t) {\n        dV.apply(null, t);\n      }), this._events.length = 0;\n    }\n    render() {\n      let t = this.renderer,\n        e = this.options,\n        i = this.size,\n        s = this.chart.styledMode,\n        o = t.g(\"scrollbar\").attr({\n          zIndex: e.zIndex\n        }).hide().add();\n      this.group = o, this.track = t.rect().addClass(\"highcharts-scrollbar-track\").attr({\n        r: e.trackBorderRadius || 0,\n        height: i,\n        width: i\n      }).add(o), s || this.track.attr({\n        fill: e.trackBackgroundColor,\n        stroke: e.trackBorderColor,\n        \"stroke-width\": e.trackBorderWidth\n      });\n      let r = this.trackBorderWidth = this.track.strokeWidth();\n      this.track.attr({\n        x: -dH(0, r),\n        y: -dH(0, r)\n      }), this.scrollbarGroup = t.g().add(o), this.scrollbar = t.rect().addClass(\"highcharts-scrollbar-thumb\").attr({\n        height: i - r,\n        width: i - r,\n        r: e.barBorderRadius || 0\n      }).add(this.scrollbarGroup), this.scrollbarRifles = t.path(d$.swapXY([[\"M\", -3, i / 4], [\"L\", -3, 2 * i / 3], [\"M\", 0, i / 4], [\"L\", 0, 2 * i / 3], [\"M\", 3, i / 4], [\"L\", 3, 2 * i / 3]], e.vertical)).addClass(\"highcharts-scrollbar-rifles\").add(this.scrollbarGroup), s || (this.scrollbar.attr({\n        fill: e.barBackgroundColor,\n        stroke: e.barBorderColor,\n        \"stroke-width\": e.barBorderWidth\n      }), this.scrollbarRifles.attr({\n        stroke: e.rifleColor,\n        \"stroke-width\": 1\n      })), this.scrollbarStrokeWidth = this.scrollbar.strokeWidth(), this.scrollbarGroup.translate(-dH(0, this.scrollbarStrokeWidth), -dH(0, this.scrollbarStrokeWidth)), this.drawScrollbarButton(0), this.drawScrollbarButton(1);\n    }\n    setRange(t, e) {\n      let i, s;\n      let o = this.options,\n        r = o.vertical,\n        n = o.minWidth,\n        a = this.barWidth,\n        h = !this.rendered || this.hasDragged || this.chart.navigator && this.chart.navigator.hasDragged ? \"attr\" : \"animate\";\n      if (!dF(a)) return;\n      let l = a * Math.min(e, 1);\n      i = Math.ceil(a * (t = Math.max(t, 0))), this.calculatedWidth = s = dG(l - i), s < n && (i = (a - n + s) * t, s = n);\n      let d = Math.floor(i + this.xOffset + this.yOffset),\n        c = s / 2 - .5;\n      this.from = t, this.to = e, r ? (this.scrollbarGroup[h]({\n        translateY: d\n      }), this.scrollbar[h]({\n        height: s\n      }), this.scrollbarRifles[h]({\n        translateY: c\n      }), this.scrollbarTop = d, this.scrollbarLeft = 0) : (this.scrollbarGroup[h]({\n        translateX: d\n      }), this.scrollbar[h]({\n        width: s\n      }), this.scrollbarRifles[h]({\n        translateX: c\n      }), this.scrollbarLeft = d, this.scrollbarTop = 0), s <= 12 ? this.scrollbarRifles.hide() : this.scrollbarRifles.show(), !1 === o.showFull && (t <= 0 && e >= 1 ? this.group.hide() : this.group.show()), this.rendered = !0;\n    }\n    shouldUpdateExtremes(t) {\n      return dU(this.options.liveRedraw, O.svg && !O.isTouchDevice && !this.chart.boosted) || \"mouseup\" === t || \"touchend\" === t || !dF(t);\n    }\n    trackClick(t) {\n      let e = this.chart.pointer?.normalize(t) || t,\n        i = this.to - this.from,\n        s = this.y + this.scrollbarTop,\n        o = this.x + this.scrollbarLeft;\n      this.options.vertical && e.chartY > s || !this.options.vertical && e.chartX > o ? this.updatePosition(this.from + i, this.to + i) : this.updatePosition(this.from - i, this.to - i), dY(this, \"changed\", {\n        from: this.from,\n        to: this.to,\n        trigger: \"scrollbar\",\n        DOMEvent: t\n      });\n    }\n    update(t) {\n      this.destroy(), this.init(this.chart.renderer, dj(!0, this.options, t), this.chart);\n    }\n    updatePosition(t, e) {\n      e > 1 && (t = dG(1 - dG(e - t)), e = 1), t < 0 && (e = dG(e - t), t = 0), this.from = t, this.to = e;\n    }\n  }\n  d$.defaultOptions = dN, dz.scrollbar = dj(!0, d$.defaultOptions, dz.scrollbar);\n  let {\n      defaultOptions: d_\n    } = tS,\n    {\n      isTouchDevice: dq\n    } = O,\n    {\n      prototype: {\n        symbols: dZ\n      }\n    } = iU,\n    {\n      addEvent: dK,\n      clamp: dJ,\n      correctFloat: dQ,\n      defined: d0,\n      destroyObjectProperties: d1,\n      erase: d2,\n      extend: d3,\n      find: d5,\n      fireEvent: d6,\n      isArray: d9,\n      isNumber: d4,\n      merge: d8,\n      pick: d7,\n      removeEvent: ct,\n      splat: ce\n    } = tt;\n  function ci(t, ...e) {\n    let i = [].filter.call(e, d4);\n    if (i.length) return Math[t].apply(0, i);\n  }\n  class cs {\n    static compose(t, e, i) {\n      dr.compose(t, cs), dO.compose(t, e, i);\n    }\n    constructor(t) {\n      this.isDirty = !1, this.scrollbarHeight = 0, this.init(t);\n    }\n    drawHandle(t, e, i, s) {\n      let o = this.navigatorOptions.handles.height;\n      this.handles[e][s](i ? {\n        translateX: Math.round(this.left + this.height / 2),\n        translateY: Math.round(this.top + parseInt(t, 10) + .5 - o)\n      } : {\n        translateX: Math.round(this.left + parseInt(t, 10)),\n        translateY: Math.round(this.top + this.height / 2 - o / 2 - 1)\n      });\n    }\n    drawOutline(t, e, i, s) {\n      let o = this.navigatorOptions.maskInside,\n        r = this.outline.strokeWidth(),\n        n = r / 2,\n        a = r % 2 / 2,\n        h = this.scrollButtonSize,\n        l = this.size,\n        d = this.top,\n        c = this.height,\n        p = d - n,\n        u = d + c,\n        g = this.left,\n        f,\n        m;\n      i ? (f = d + e + a, e = d + t + a, m = [[\"M\", g + c, d - h - a], [\"L\", g + c, f], [\"L\", g, f], [\"M\", g, e], [\"L\", g + c, e], [\"L\", g + c, d + l + h]], o && m.push([\"M\", g + c, f - n], [\"L\", g + c, e + n])) : (g -= h, t += g + h - a, e += g + h - a, m = [[\"M\", g, p], [\"L\", t, p], [\"L\", t, u], [\"M\", e, u], [\"L\", e, p], [\"L\", g + l + 2 * h, p]], o && m.push([\"M\", t - n, p], [\"L\", e + n, p])), this.outline[s]({\n        d: m\n      });\n    }\n    drawMasks(t, e, i, s) {\n      let o, r, n, a;\n      let h = this.left,\n        l = this.top,\n        d = this.height;\n      i ? (n = [h, h, h], a = [l, l + t, l + e], r = [d, d, d], o = [t, e - t, this.size - e]) : (n = [h, h + t, h + e], a = [l, l, l], r = [t, e - t, this.size - e], o = [d, d, d]), this.shades.forEach((t, e) => {\n        t[s]({\n          x: n[e],\n          y: a[e],\n          width: r[e],\n          height: o[e]\n        });\n      });\n    }\n    renderElements() {\n      let t = this,\n        e = t.navigatorOptions,\n        i = e.maskInside,\n        s = t.chart,\n        o = s.inverted,\n        r = s.renderer,\n        n = {\n          cursor: o ? \"ns-resize\" : \"ew-resize\"\n        },\n        a = t.navigatorGroup ?? (t.navigatorGroup = r.g(\"navigator\").attr({\n          zIndex: 8,\n          visibility: \"hidden\"\n        }).add());\n      if ([!i, i, !i].forEach((i, o) => {\n        let h = t.shades[o] ?? (t.shades[o] = r.rect().addClass(\"highcharts-navigator-mask\" + (1 === o ? \"-inside\" : \"-outside\")).add(a));\n        s.styledMode || (h.attr({\n          fill: i ? e.maskFill : \"rgba(0,0,0,0)\"\n        }), 1 === o && h.css(n));\n      }), t.outline || (t.outline = r.path().addClass(\"highcharts-navigator-outline\").add(a)), s.styledMode || t.outline.attr({\n        \"stroke-width\": e.outlineWidth,\n        stroke: e.outlineColor\n      }), e.handles?.enabled) {\n        let i = e.handles,\n          {\n            height: o,\n            width: h\n          } = i;\n        [0, 1].forEach(e => {\n          let l = i.symbols[e];\n          if (t.handles[e] && t.handles[e].symbolUrl === l) {\n            if (!t.handles[e].isImg && t.handles[e].symbolName !== l) {\n              let i = dZ[l].call(dZ, -h / 2 - 1, 0, h, o);\n              t.handles[e].attr({\n                d: i\n              }), t.handles[e].symbolName = l;\n            }\n          } else t.handles[e]?.destroy(), t.handles[e] = r.symbol(l, -h / 2 - 1, 0, h, o, i), t.handles[e].attr({\n            zIndex: 7 - e\n          }).addClass(\"highcharts-navigator-handle highcharts-navigator-handle-\" + [\"left\", \"right\"][e]).add(a), t.addMouseEvents();\n          s.inverted && t.handles[e].attr({\n            rotation: 90,\n            rotationOriginX: Math.floor(-h / 2),\n            rotationOriginY: (o + h) / 2\n          }), s.styledMode || t.handles[e].attr({\n            fill: i.backgroundColor,\n            stroke: i.borderColor,\n            \"stroke-width\": i.lineWidth,\n            width: i.width,\n            height: i.height,\n            x: -h / 2 - 1,\n            y: 0\n          }).css(n);\n        });\n      }\n    }\n    update(t, e = !1) {\n      let i = this.chart,\n        s = i.options.chart.inverted !== i.scrollbar?.options.vertical;\n      if (d8(!0, i.options.navigator, t), this.navigatorOptions = i.options.navigator || {}, this.setOpposite(), d0(t.enabled) || s) return this.destroy(), this.navigatorEnabled = t.enabled || this.navigatorEnabled, this.init(i);\n      if (this.navigatorEnabled && (this.isDirty = !0, !1 === t.adaptToUpdatedData && this.baseSeries.forEach(t => {\n        ct(t, \"updatedData\", this.updatedDataHandler);\n      }, this), t.adaptToUpdatedData && this.baseSeries.forEach(t => {\n        t.eventsToUnbind.push(dK(t, \"updatedData\", this.updatedDataHandler));\n      }, this), (t.series || t.baseSeries) && this.setBaseSeries(void 0, !1), t.height || t.xAxis || t.yAxis)) {\n        this.height = t.height ?? this.height;\n        let e = this.getXAxisOffsets();\n        this.xAxis.update({\n          ...t.xAxis,\n          offsets: e,\n          [i.inverted ? \"width\" : \"height\"]: this.height,\n          [i.inverted ? \"height\" : \"width\"]: void 0\n        }, !1), this.yAxis.update({\n          ...t.yAxis,\n          [i.inverted ? \"width\" : \"height\"]: this.height\n        }, !1);\n      }\n      e && i.redraw();\n    }\n    render(t, e, i, s) {\n      let o = this.chart,\n        r = this.xAxis,\n        n = r.pointRange || 0,\n        a = r.navigatorAxis.fake ? o.xAxis[0] : r,\n        h = this.navigatorEnabled,\n        l = this.rendered,\n        d = o.inverted,\n        c = o.xAxis[0].minRange,\n        p = o.xAxis[0].options.maxRange,\n        u = this.scrollButtonSize,\n        g,\n        f,\n        m,\n        x = this.scrollbarHeight,\n        y,\n        b;\n      if (this.hasDragged && !d0(i)) return;\n      if (this.isDirty && this.renderElements(), t = dQ(t - n / 2), e = dQ(e + n / 2), !d4(t) || !d4(e)) {\n        if (!l) return;\n        i = 0, s = d7(r.width, a.width);\n      }\n      this.left = d7(r.left, o.plotLeft + u + (d ? o.plotWidth : 0));\n      let v = this.size = y = d7(r.len, (d ? o.plotHeight : o.plotWidth) - 2 * u);\n      g = d ? x : y + 2 * u, i = d7(i, r.toPixels(t, !0)), s = d7(s, r.toPixels(e, !0)), d4(i) && Math.abs(i) !== 1 / 0 || (i = 0, s = g);\n      let M = r.toValue(i, !0),\n        k = r.toValue(s, !0),\n        w = Math.abs(dQ(k - M));\n      w < c ? this.grabbedLeft ? i = r.toPixels(k - c - n, !0) : this.grabbedRight && (s = r.toPixels(M + c + n, !0)) : d0(p) && dQ(w - n) > p && (this.grabbedLeft ? i = r.toPixels(k - p - n, !0) : this.grabbedRight && (s = r.toPixels(M + p + n, !0))), this.zoomedMax = dJ(Math.max(i, s), 0, v), this.zoomedMin = dJ(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(i, s), 0, v), this.range = this.zoomedMax - this.zoomedMin, v = Math.round(this.zoomedMax);\n      let S = Math.round(this.zoomedMin);\n      h && (this.navigatorGroup.attr({\n        visibility: \"inherit\"\n      }), b = l && !this.hasDragged ? \"animate\" : \"attr\", this.drawMasks(S, v, d, b), this.drawOutline(S, v, d, b), this.navigatorOptions.handles.enabled && (this.drawHandle(S, 0, d, b), this.drawHandle(v, 1, d, b))), this.scrollbar && (d ? (m = this.top - u, f = this.left - x + (h || !a.opposite ? 0 : (a.titleOffset || 0) + a.axisTitleMargin), x = y + 2 * u) : (m = this.top + (h ? this.height : -x), f = this.left - u), this.scrollbar.position(f, m, g, x), this.scrollbar.setRange(this.zoomedMin / (y || 1), this.zoomedMax / (y || 1))), this.rendered = !0, this.isDirty = !1, d6(this, \"afterRender\");\n    }\n    addMouseEvents() {\n      let t = this,\n        e = t.chart,\n        i = e.container,\n        s = [],\n        o,\n        r;\n      t.mouseMoveHandler = o = function (e) {\n        t.onMouseMove(e);\n      }, t.mouseUpHandler = r = function (e) {\n        t.onMouseUp(e);\n      }, (s = t.getPartsEvents(\"mousedown\")).push(dK(e.renderTo, \"mousemove\", o), dK(i.ownerDocument, \"mouseup\", r), dK(e.renderTo, \"touchmove\", o), dK(i.ownerDocument, \"touchend\", r)), s.concat(t.getPartsEvents(\"touchstart\")), t.eventsToUnbind = s, t.series && t.series[0] && s.push(dK(t.series[0].xAxis, \"foundExtremes\", function () {\n        e.navigator.modifyNavigatorAxisExtremes();\n      }));\n    }\n    getPartsEvents(t) {\n      let e = this,\n        i = [];\n      return [\"shades\", \"handles\"].forEach(function (s) {\n        e[s].forEach(function (o, r) {\n          i.push(dK(o.element, t, function (t) {\n            e[s + \"Mousedown\"](t, r);\n          }));\n        });\n      }), i;\n    }\n    shadesMousedown(t, e) {\n      t = this.chart.pointer?.normalize(t) || t;\n      let i = this.chart,\n        s = this.xAxis,\n        o = this.zoomedMin,\n        r = this.size,\n        n = this.range,\n        a = this.left,\n        h = t.chartX,\n        l,\n        d,\n        c,\n        p;\n      i.inverted && (h = t.chartY, a = this.top), 1 === e ? (this.grabbedCenter = h, this.fixedWidth = n, this.dragOffset = h - o) : (p = h - a - n / 2, 0 === e ? p = Math.max(0, p) : 2 === e && p + n >= r && (p = r - n, this.reversedExtremes ? (p -= n, d = this.getUnionExtremes().dataMin) : l = this.getUnionExtremes().dataMax), p !== o && (this.fixedWidth = n, d0((c = s.navigatorAxis.toFixedRange(p, p + n, d, l)).min) && d6(this, \"setRange\", {\n        min: Math.min(c.min, c.max),\n        max: Math.max(c.min, c.max),\n        redraw: !0,\n        eventArguments: {\n          trigger: \"navigator\"\n        }\n      })));\n    }\n    handlesMousedown(t, e) {\n      t = this.chart.pointer?.normalize(t) || t;\n      let i = this.chart,\n        s = i.xAxis[0],\n        o = this.reversedExtremes;\n      0 === e ? (this.grabbedLeft = !0, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = o ? s.min : s.max) : (this.grabbedRight = !0, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = o ? s.max : s.min), i.setFixedRange(void 0);\n    }\n    onMouseMove(t) {\n      let e = this,\n        i = e.chart,\n        s = e.navigatorSize,\n        o = e.range,\n        r = e.dragOffset,\n        n = i.inverted,\n        a = e.left,\n        h;\n      (!t.touches || 0 !== t.touches[0].pageX) && (h = (t = i.pointer?.normalize(t) || t).chartX, n && (a = e.top, h = t.chartY), e.grabbedLeft ? (e.hasDragged = !0, e.render(0, 0, h - a, e.otherHandlePos)) : e.grabbedRight ? (e.hasDragged = !0, e.render(0, 0, e.otherHandlePos, h - a)) : e.grabbedCenter && (e.hasDragged = !0, h < r ? h = r : h > s + r - o && (h = s + r - o), e.render(0, 0, h - r, h - r + o)), e.hasDragged && e.scrollbar && d7(e.scrollbar.options.liveRedraw, !dq && !this.chart.boosted) && (t.DOMType = t.type, setTimeout(function () {\n        e.onMouseUp(t);\n      }, 0)));\n    }\n    onMouseUp(t) {\n      let e, i, s, o, r, n;\n      let a = this.chart,\n        h = this.xAxis,\n        l = this.scrollbar,\n        d = t.DOMEvent || t,\n        c = a.inverted,\n        p = this.rendered && !this.hasDragged ? \"animate\" : \"attr\";\n      (this.hasDragged && (!l || !l.hasDragged) || \"scrollbar\" === t.trigger) && (s = this.getUnionExtremes(), this.zoomedMin === this.otherHandlePos ? o = this.fixedExtreme : this.zoomedMax === this.otherHandlePos && (r = this.fixedExtreme), this.zoomedMax === this.size && (r = this.reversedExtremes ? s.dataMin : s.dataMax), 0 === this.zoomedMin && (o = this.reversedExtremes ? s.dataMax : s.dataMin), d0((n = h.navigatorAxis.toFixedRange(this.zoomedMin, this.zoomedMax, o, r)).min) && d6(this, \"setRange\", {\n        min: Math.min(n.min, n.max),\n        max: Math.max(n.min, n.max),\n        redraw: !0,\n        animation: !this.hasDragged && null,\n        eventArguments: {\n          trigger: \"navigator\",\n          triggerOp: \"navigator-drag\",\n          DOMEvent: d\n        }\n      })), \"mousemove\" !== t.DOMType && \"touchmove\" !== t.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null), this.navigatorEnabled && d4(this.zoomedMin) && d4(this.zoomedMax) && (i = Math.round(this.zoomedMin), e = Math.round(this.zoomedMax), this.shades && this.drawMasks(i, e, c, p), this.outline && this.drawOutline(i, e, c, p), this.navigatorOptions.handles.enabled && Object.keys(this.handles).length === this.handles.length && (this.drawHandle(i, 0, c, p), this.drawHandle(e, 1, c, p)));\n    }\n    removeEvents() {\n      this.eventsToUnbind && (this.eventsToUnbind.forEach(function (t) {\n        t();\n      }), this.eventsToUnbind = void 0), this.removeBaseSeriesEvents();\n    }\n    removeBaseSeriesEvents() {\n      let t = this.baseSeries || [];\n      this.navigatorEnabled && t[0] && (!1 !== this.navigatorOptions.adaptToUpdatedData && t.forEach(function (t) {\n        ct(t, \"updatedData\", this.updatedDataHandler);\n      }, this), t[0].xAxis && ct(t[0].xAxis, \"foundExtremes\", this.modifyBaseAxisExtremes));\n    }\n    getXAxisOffsets() {\n      return this.chart.inverted ? [this.scrollButtonSize, 0, -this.scrollButtonSize, 0] : [0, -this.scrollButtonSize, 0, this.scrollButtonSize];\n    }\n    init(t) {\n      let e = t.options,\n        i = e.navigator || {},\n        s = i.enabled,\n        o = e.scrollbar || {},\n        r = o.enabled,\n        n = s && i.height || 0,\n        a = r && o.height || 0,\n        h = o.buttonsEnabled && a || 0;\n      this.handles = [], this.shades = [], this.chart = t, this.setBaseSeries(), this.height = n, this.scrollbarHeight = a, this.scrollButtonSize = h, this.scrollbarEnabled = r, this.navigatorEnabled = s, this.navigatorOptions = i, this.scrollbarOptions = o, this.setOpposite();\n      let l = this,\n        d = l.baseSeries,\n        c = t.xAxis.length,\n        p = t.yAxis.length,\n        u = d && d[0] && d[0].xAxis || t.xAxis[0] || {\n          options: {}\n        };\n      if (t.isDirtyBox = !0, l.navigatorEnabled) {\n        let e = this.getXAxisOffsets();\n        l.xAxis = new sU(t, d8({\n          breaks: u.options.breaks,\n          ordinal: u.options.ordinal,\n          overscroll: u.options.overscroll\n        }, i.xAxis, {\n          type: \"datetime\",\n          yAxis: i.yAxis?.id,\n          index: c,\n          isInternal: !0,\n          offset: 0,\n          keepOrdinalPadding: !0,\n          startOnTick: !1,\n          endOnTick: !1,\n          minPadding: u.options.ordinal ? 0 : u.options.minPadding,\n          maxPadding: u.options.ordinal ? 0 : u.options.maxPadding,\n          zoomEnabled: !1\n        }, t.inverted ? {\n          offsets: e,\n          width: n\n        } : {\n          offsets: e,\n          height: n\n        }), \"xAxis\"), l.yAxis = new sU(t, d8(i.yAxis, {\n          alignTicks: !1,\n          offset: 0,\n          index: p,\n          isInternal: !0,\n          reversed: d7(i.yAxis && i.yAxis.reversed, t.yAxis[0] && t.yAxis[0].reversed, !1),\n          zoomEnabled: !1\n        }, t.inverted ? {\n          width: n\n        } : {\n          height: n\n        }), \"yAxis\"), d || i.series.data ? l.updateNavigatorSeries(!1) : 0 === t.series.length && (l.unbindRedraw = dK(t, \"beforeRedraw\", function () {\n          t.series.length > 0 && !l.series && (l.setBaseSeries(), l.unbindRedraw());\n        })), l.reversedExtremes = t.inverted && !l.xAxis.reversed || !t.inverted && l.xAxis.reversed, l.renderElements(), l.addMouseEvents();\n      } else l.xAxis = {\n        chart: t,\n        navigatorAxis: {\n          fake: !0\n        },\n        translate: function (e, i) {\n          let s = t.xAxis[0],\n            o = s.getExtremes(),\n            r = s.len - 2 * h,\n            n = ci(\"min\", s.options.min, o.dataMin),\n            a = ci(\"max\", s.options.max, o.dataMax) - n;\n          return i ? e * a / r + n : r * (e - n) / a;\n        },\n        toPixels: function (t) {\n          return this.translate(t);\n        },\n        toValue: function (t) {\n          return this.translate(t, !0);\n        }\n      }, l.xAxis.navigatorAxis.axis = l.xAxis, l.xAxis.navigatorAxis.toFixedRange = dg.prototype.toFixedRange.bind(l.xAxis.navigatorAxis);\n      if (t.options.scrollbar.enabled) {\n        let e = d8(t.options.scrollbar, {\n          vertical: t.inverted\n        });\n        !d4(e.margin) && l.navigatorEnabled && (e.margin = t.inverted ? -3 : 3), t.scrollbar = l.scrollbar = new d$(t.renderer, e, t), dK(l.scrollbar, \"changed\", function (t) {\n          let e = l.size,\n            i = e * this.to,\n            s = e * this.from;\n          l.hasDragged = l.scrollbar.hasDragged, l.render(0, 0, s, i), this.shouldUpdateExtremes(t.DOMType) && setTimeout(function () {\n            l.onMouseUp(t);\n          });\n        });\n      }\n      l.addBaseSeriesEvents(), l.addChartEvents();\n    }\n    setOpposite() {\n      let t = this.navigatorOptions,\n        e = this.navigatorEnabled,\n        i = this.chart;\n      this.opposite = d7(t.opposite, !!(!e && i.inverted));\n    }\n    getUnionExtremes(t) {\n      let e;\n      let i = this.chart.xAxis[0],\n        s = this.chart.time,\n        o = this.xAxis,\n        r = o.options,\n        n = i.options;\n      return t && null === i.dataMin || (e = {\n        dataMin: d7(s.parse(r?.min), ci(\"min\", s.parse(n.min), i.dataMin, o.dataMin, o.min)),\n        dataMax: d7(s.parse(r?.max), ci(\"max\", s.parse(n.max), i.dataMax, o.dataMax, o.max))\n      }), e;\n    }\n    setBaseSeries(t, e) {\n      let i = this.chart,\n        s = this.baseSeries = [];\n      t = t || i.options && i.options.navigator.baseSeries || (i.series.length ? d5(i.series, t => !t.options.isInternal).index : 0), (i.series || []).forEach((e, i) => {\n        !e.options.isInternal && (e.options.showInNavigator || (i === t || e.options.id === t) && !1 !== e.options.showInNavigator) && s.push(e);\n      }), this.xAxis && !this.xAxis.navigatorAxis.fake && this.updateNavigatorSeries(!0, e);\n    }\n    updateNavigatorSeries(t, e) {\n      let i = this,\n        s = i.chart,\n        o = i.baseSeries,\n        r = {\n          enableMouseTracking: !1,\n          index: null,\n          linkedTo: null,\n          group: \"nav\",\n          padXAxis: !1,\n          xAxis: this.navigatorOptions.xAxis?.id,\n          yAxis: this.navigatorOptions.yAxis?.id,\n          showInLegend: !1,\n          stacking: void 0,\n          isInternal: !0,\n          states: {\n            inactive: {\n              opacity: 1\n            }\n          }\n        },\n        n = i.series = (i.series || []).filter(t => {\n          let e = t.baseSeries;\n          return !(0 > o.indexOf(e)) || (e && (ct(e, \"updatedData\", i.updatedDataHandler), delete e.navigatorSeries), t.chart && t.destroy(), !1);\n        }),\n        a,\n        h,\n        l = i.navigatorOptions.series,\n        d;\n      o && o.length && o.forEach(t => {\n        let c = t.navigatorSeries,\n          p = d3({\n            color: t.color,\n            visible: t.visible\n          }, d9(l) ? d_.navigator.series : l);\n        if (c && !1 === i.navigatorOptions.adaptToUpdatedData) return;\n        r.name = \"Navigator \" + o.length, d = (a = t.options || {}).navigatorOptions || {}, p.dataLabels = ce(p.dataLabels), (h = d8(a, r, p, d)).pointRange = d7(p.pointRange, d.pointRange, d_.plotOptions[h.type || \"line\"].pointRange);\n        let u = d.data || p.data;\n        i.hasNavigatorData = i.hasNavigatorData || !!u, h.data = u || a.data?.slice(0), c && c.options ? c.update(h, e) : (t.navigatorSeries = s.initSeries(h), s.setSortedData(), t.navigatorSeries.baseSeries = t, n.push(t.navigatorSeries));\n      }), (l.data && !(o && o.length) || d9(l)) && (i.hasNavigatorData = !1, (l = ce(l)).forEach((t, e) => {\n        r.name = \"Navigator \" + (n.length + 1), (h = d8(d_.navigator.series, {\n          color: s.series[e] && !s.series[e].options.isInternal && s.series[e].color || s.options.colors[e] || s.options.colors[0]\n        }, r, t)).data = t.data, h.data && (i.hasNavigatorData = !0, n.push(s.initSeries(h)));\n      })), t && this.addBaseSeriesEvents();\n    }\n    addBaseSeriesEvents() {\n      let t = this,\n        e = t.baseSeries || [];\n      e[0] && e[0].xAxis && e[0].eventsToUnbind.push(dK(e[0].xAxis, \"foundExtremes\", this.modifyBaseAxisExtremes)), e.forEach(i => {\n        i.eventsToUnbind.push(dK(i, \"show\", function () {\n          this.navigatorSeries && this.navigatorSeries.setVisible(!0, !1);\n        })), i.eventsToUnbind.push(dK(i, \"hide\", function () {\n          this.navigatorSeries && this.navigatorSeries.setVisible(!1, !1);\n        })), !1 !== this.navigatorOptions.adaptToUpdatedData && i.xAxis && i.eventsToUnbind.push(dK(i, \"updatedData\", this.updatedDataHandler)), i.eventsToUnbind.push(dK(i, \"remove\", function () {\n          e && d2(e, i), this.navigatorSeries && t.series && (d2(t.series, this.navigatorSeries), d0(this.navigatorSeries.options) && this.navigatorSeries.remove(!1), delete this.navigatorSeries);\n        }));\n      });\n    }\n    getBaseSeriesMin(t) {\n      return this.baseSeries.reduce(function (t, e) {\n        return Math.min(t, e.getColumn(\"x\")[0] ?? t);\n      }, t);\n    }\n    modifyNavigatorAxisExtremes() {\n      let t = this.xAxis;\n      if (void 0 !== t.getExtremes) {\n        let e = this.getUnionExtremes(!0);\n        e && (e.dataMin !== t.min || e.dataMax !== t.max) && (t.min = e.dataMin, t.max = e.dataMax);\n      }\n    }\n    modifyBaseAxisExtremes() {\n      let t, e;\n      let i = this.chart.navigator,\n        s = this.getExtremes(),\n        o = s.min,\n        r = s.max,\n        n = s.dataMin,\n        a = s.dataMax,\n        h = r - o,\n        l = i.stickToMin,\n        d = i.stickToMax,\n        c = d7(this.ordinal?.convertOverscroll(this.options.overscroll), 0),\n        p = i.series && i.series[0],\n        u = !!this.setExtremes;\n      !(this.eventArgs && \"rangeSelectorButton\" === this.eventArgs.trigger) && (l && (t = (e = n) + h), d && (t = a + c, l || (e = Math.max(n, t - h, i.getBaseSeriesMin(p && p.xData ? p.xData[0] : -Number.MAX_VALUE)))), u && (l || d) && d4(e) && (this.min = this.userMin = e, this.max = this.userMax = t)), i.stickToMin = i.stickToMax = null;\n    }\n    updatedDataHandler() {\n      let t = this.chart.navigator,\n        e = this.navigatorSeries,\n        i = t.reversedExtremes ? 0 === Math.round(t.zoomedMin) : Math.round(t.zoomedMax) >= Math.round(t.size);\n      t.stickToMax = d7(this.chart.options.navigator && this.chart.options.navigator.stickToMax, i), t.stickToMin = t.shouldStickToMin(this, t), e && !t.hasNavigatorData && (e.options.pointStart = this.getColumn(\"x\")[0], e.setData(this.options.data, !1, null, !1));\n    }\n    shouldStickToMin(t, e) {\n      let i = e.getBaseSeriesMin(t.getColumn(\"x\")[0]),\n        s = t.xAxis,\n        o = s.max,\n        r = s.min,\n        n = s.options.range;\n      return !!(d4(o) && d4(r)) && (n && o - i > 0 ? o - i < n : r <= i);\n    }\n    addChartEvents() {\n      this.eventsToUnbind || (this.eventsToUnbind = []), this.eventsToUnbind.push(dK(this.chart, \"redraw\", function () {\n        let t = this.navigator,\n          e = t && (t.baseSeries && t.baseSeries[0] && t.baseSeries[0].xAxis || this.xAxis[0]);\n        e && t.render(e.min, e.max);\n      }), dK(this.chart, \"getMargins\", function () {\n        let t = this.navigator,\n          e = t.opposite ? \"plotTop\" : \"marginBottom\";\n        this.inverted && (e = t.opposite ? \"marginRight\" : \"plotLeft\"), this[e] = (this[e] || 0) + (t.navigatorEnabled || !this.inverted ? t.height + t.scrollbarHeight : 0) + t.navigatorOptions.margin;\n      }), dK(cs, \"setRange\", function (t) {\n        this.chart.xAxis[0].setExtremes(t.min, t.max, t.redraw, t.animation, t.eventArguments);\n      }));\n    }\n    destroy() {\n      this.removeEvents(), this.xAxis && (d2(this.chart.xAxis, this.xAxis), d2(this.chart.axes, this.xAxis)), this.yAxis && (d2(this.chart.yAxis, this.yAxis), d2(this.chart.axes, this.yAxis)), (this.series || []).forEach(t => {\n        t.destroy && t.destroy();\n      }), [\"series\", \"xAxis\", \"yAxis\", \"shades\", \"outline\", \"scrollbarTrack\", \"scrollbarRifles\", \"scrollbarGroup\", \"scrollbar\", \"navigatorGroup\", \"rendered\"].forEach(t => {\n        this[t] && this[t].destroy && this[t].destroy(), this[t] = null;\n      }), [this.handles].forEach(t => {\n        d1(t);\n      }), this.navigatorEnabled = !1;\n    }\n  }\n  let co = {\n      lang: {\n        rangeSelectorZoom: \"Zoom\",\n        rangeSelectorFrom: \"\",\n        rangeSelectorTo: \"→\"\n      },\n      rangeSelector: {\n        allButtonsEnabled: !1,\n        buttons: [{\n          type: \"month\",\n          count: 1,\n          text: \"1m\",\n          title: \"View 1 month\"\n        }, {\n          type: \"month\",\n          count: 3,\n          text: \"3m\",\n          title: \"View 3 months\"\n        }, {\n          type: \"month\",\n          count: 6,\n          text: \"6m\",\n          title: \"View 6 months\"\n        }, {\n          type: \"ytd\",\n          text: \"YTD\",\n          title: \"View year to date\"\n        }, {\n          type: \"year\",\n          count: 1,\n          text: \"1y\",\n          title: \"View 1 year\"\n        }, {\n          type: \"all\",\n          text: \"All\",\n          title: \"View all\"\n        }],\n        buttonSpacing: 5,\n        dropdown: \"responsive\",\n        enabled: void 0,\n        verticalAlign: \"top\",\n        buttonTheme: {\n          width: 28,\n          height: 18,\n          padding: 2,\n          zIndex: 7\n        },\n        floating: !1,\n        x: 0,\n        y: 0,\n        height: void 0,\n        inputBoxBorderColor: \"none\",\n        inputBoxHeight: 17,\n        inputBoxWidth: void 0,\n        inputDateFormat: \"%[ebY]\",\n        inputDateParser: void 0,\n        inputEditDateFormat: \"%Y-%m-%d\",\n        inputEnabled: !0,\n        inputPosition: {\n          align: \"right\",\n          x: 0,\n          y: 0\n        },\n        inputSpacing: 5,\n        selected: void 0,\n        buttonPosition: {\n          align: \"left\",\n          x: 0,\n          y: 0\n        },\n        inputStyle: {\n          color: \"#334eff\",\n          cursor: \"pointer\",\n          fontSize: \"0.8em\"\n        },\n        labelStyle: {\n          color: \"#666666\",\n          fontSize: \"0.8em\"\n        }\n      }\n    },\n    {\n      defaultOptions: cr\n    } = tS,\n    {\n      composed: cn\n    } = O,\n    {\n      addEvent: ca,\n      defined: ch,\n      extend: cl,\n      isNumber: cd,\n      merge: cc,\n      pick: cp,\n      pushUnique: cu\n    } = tt,\n    cg = [];\n  function cf() {\n    let t, e;\n    let i = this.range,\n      s = i.type,\n      o = this.max,\n      r = this.chart.time,\n      n = function (t, e) {\n        let i = r.toParts(t),\n          o = i.slice();\n        \"year\" === s ? o[0] += e : o[1] += e;\n        let n = r.makeTime.apply(r, o),\n          a = r.toParts(n);\n        return \"month\" === s && i[1] === a[1] && 1 === Math.abs(e) && (o[0] = i[0], o[1] = i[1], o[2] = 0), (n = r.makeTime.apply(r, o)) - t;\n      };\n    cd(i) ? (t = o - i, e = i) : i && (t = o + n(o, -(i.count || 1)), this.chart && this.chart.setFixedRange(o - t));\n    let a = cp(this.dataMin, Number.MIN_VALUE);\n    return cd(t) || (t = a), t <= a && (t = a, void 0 === e && (e = n(t, i.count)), this.newMax = Math.min(t + e, cp(this.dataMax, Number.MAX_VALUE))), cd(o) ? !cd(i) && i && i._offsetMin && (t += i._offsetMin) : t = void 0, t;\n  }\n  function cm() {\n    this.rangeSelector?.redrawElements();\n  }\n  function cx() {\n    this.options.rangeSelector && this.options.rangeSelector.enabled && (this.rangeSelector = new s(this));\n  }\n  function cy() {\n    let t = this.rangeSelector;\n    if (t) {\n      cd(t.deferredYTDClick) && (t.clickButton(t.deferredYTDClick), delete t.deferredYTDClick);\n      let e = t.options.verticalAlign;\n      t.options.floating || (\"bottom\" === e ? this.extraBottomMargin = !0 : \"top\" !== e || (this.extraTopMargin = !0));\n    }\n  }\n  function cb() {\n    let t;\n    let e = this.rangeSelector;\n    if (!e) return;\n    let i = this.xAxis[0].getExtremes(),\n      s = this.legend,\n      o = e && e.options.verticalAlign;\n    cd(i.min) && e.render(i.min, i.max), s.display && \"top\" === o && o === s.options.verticalAlign && (t = cc(this.spacingBox), \"vertical\" === s.options.layout ? t.y = this.plotTop : t.y += e.getHeight(), s.group.placed = !1, s.align(t));\n  }\n  function cv() {\n    for (let t = 0, e = cg.length; t < e; ++t) {\n      let e = cg[t];\n      if (e[0] === this) {\n        e[1].forEach(t => t()), cg.splice(t, 1);\n        return;\n      }\n    }\n  }\n  function cM() {\n    let t = this.rangeSelector;\n    if (t?.options?.enabled) {\n      let e = t.getHeight(),\n        i = t.options.verticalAlign;\n      t.options.floating || (\"bottom\" === i ? this.marginBottom += e : \"middle\" === i || (this.plotTop += e));\n    }\n  }\n  function ck(t) {\n    let e = t.options.rangeSelector,\n      i = this.extraBottomMargin,\n      o = this.extraTopMargin,\n      r = this.rangeSelector;\n    if (e && e.enabled && !ch(r) && this.options.rangeSelector && (this.options.rangeSelector.enabled = !0, this.rangeSelector = r = new s(this)), this.extraBottomMargin = !1, this.extraTopMargin = !1, r) {\n      let t = e && e.verticalAlign || r.options && r.options.verticalAlign;\n      r.options.floating || (\"bottom\" === t ? this.extraBottomMargin = !0 : \"middle\" === t || (this.extraTopMargin = !0)), (this.extraBottomMargin !== i || this.extraTopMargin !== o) && (this.isDirtyBox = !0);\n    }\n  }\n  let cw = {\n      compose: function (t, e, i) {\n        if (s = i, cu(cn, \"RangeSelector\")) {\n          let i = e.prototype;\n          t.prototype.minFromRange = cf, ca(e, \"afterGetContainer\", cx), ca(e, \"beforeRender\", cy), ca(e, \"destroy\", cv), ca(e, \"getMargins\", cM), ca(e, \"redraw\", cb), ca(e, \"update\", ck), ca(e, \"beforeRedraw\", cm), i.callbacks.push(cb), cl(cr, {\n            rangeSelector: co.rangeSelector\n          }), cl(cr.lang, co.lang);\n        }\n      }\n    },\n    {\n      addEvent: cS,\n      correctFloat: cA,\n      css: cT,\n      defined: cP,\n      error: cC,\n      isNumber: cO,\n      pick: cE,\n      timeUnits: cL,\n      isString: cB\n    } = tt;\n  !function (t) {\n    function e(t, i, s, o, r = [], n = 0, a) {\n      let h = {},\n        l = this.options.tickPixelInterval,\n        d = this.chart.time,\n        c = [],\n        p,\n        u,\n        g,\n        f,\n        m,\n        x = 0,\n        y = [],\n        b = -Number.MAX_VALUE;\n      if (!this.options.ordinal && !this.options.breaks || !r || r.length < 3 || void 0 === i) return d.getTimeTicks.apply(d, arguments);\n      let v = r.length;\n      for (p = 0; p < v; p++) {\n        if (m = p && r[p - 1] > s, r[p] < i && (x = p), p === v - 1 || r[p + 1] - r[p] > 5 * n || m) {\n          if (r[p] > b) {\n            for (u = d.getTimeTicks(t, r[x], r[p], o); u.length && u[0] <= b;) u.shift();\n            u.length && (b = u[u.length - 1]), c.push(y.length), y = y.concat(u);\n          }\n          x = p + 1;\n        }\n        if (m) break;\n      }\n      if (u) {\n        if (f = u.info, a && f.unitRange <= cL.hour) {\n          for (x = 1, p = y.length - 1; x < p; x++) d.dateFormat(\"%d\", y[x]) !== d.dateFormat(\"%d\", y[x - 1]) && (h[y[x]] = \"day\", g = !0);\n          g && (h[y[0]] = \"day\"), f.higherRanks = h;\n        }\n        f.segmentStarts = c, y.info = f;\n      } else cC(12, !1, this.chart);\n      if (a && cP(l)) {\n        let t = y.length,\n          e = [],\n          i = [],\n          o,\n          r,\n          n,\n          a,\n          d,\n          c = t;\n        for (; c--;) r = this.translate(y[c]), n && (i[c] = n - r), e[c] = n = r;\n        for (i.sort((t, e) => t - e), (a = i[Math.floor(i.length / 2)]) < .6 * l && (a = null), c = y[t - 1] > s ? t - 1 : t, n = void 0; c--;) d = Math.abs(n - (r = e[c])), n && d < .8 * l && (null === a || d < .8 * a) ? (h[y[c]] && !h[y[c + 1]] ? (o = c + 1, n = r) : o = c, y.splice(o, 1)) : n = r;\n      }\n      return y;\n    }\n    function i(t) {\n      let e = this.ordinal.positions;\n      if (!e) return t;\n      let i = e.length - 1,\n        s;\n      return (t < 0 ? t = e[0] : t > i ? t = e[i] : (i = Math.floor(t), s = t - i), void 0 !== s && void 0 !== e[i]) ? e[i] + (s ? s * (e[i + 1] - e[i]) : 0) : t;\n    }\n    function s(t) {\n      let e = this.ordinal,\n        i = this.old ? this.old.min : this.min,\n        s = this.old ? this.old.transA : this.transA,\n        o = e.getExtendedPositions();\n      if (o?.length) {\n        let r = cA((t - i) * s + this.minPixelPadding),\n          n = cA(e.getIndexOfPoint(r, o)),\n          a = cA(n % 1);\n        if (n >= 0 && n <= o.length - 1) {\n          let t = o[Math.floor(n)],\n            e = o[Math.ceil(n)];\n          return o[Math.floor(n)] + a * (e - t);\n        }\n      }\n      return t;\n    }\n    function o(e, i) {\n      let s = t.Additions.findIndexOf(e, i, !0);\n      if (e[s] === i) return s;\n      let o = (i - e[s]) / (e[s + 1] - e[s]);\n      return s + o;\n    }\n    function r() {\n      this.ordinal || (this.ordinal = new t.Additions(this));\n    }\n    function n() {\n      let {\n        eventArgs: t,\n        options: e\n      } = this;\n      if (this.isXAxis && cP(e.overscroll) && 0 !== e.overscroll && cO(this.max) && cO(this.min) && (this.options.ordinal && !this.ordinal.originalOrdinalRange && this.ordinal.getExtendedPositions(!1), this.max === this.dataMax && (t?.trigger !== \"pan\" || this.isInternal) && t?.trigger !== \"navigator\")) {\n        let i = this.ordinal.convertOverscroll(e.overscroll);\n        this.max += i, !this.isInternal && cP(this.userMin) && t?.trigger !== \"mousewheel\" && (this.min += i);\n      }\n    }\n    function a() {\n      this.horiz && !this.isDirty && (this.isDirty = this.isOrdinal && this.chart.navigator && !this.chart.navigator.adaptToUpdatedData);\n    }\n    function h() {\n      this.ordinal && (this.ordinal.beforeSetTickPositions(), this.tickInterval = this.ordinal.postProcessTickInterval(this.tickInterval));\n    }\n    function l(t) {\n      let e = this.xAxis[0],\n        i = e.ordinal.convertOverscroll(e.options.overscroll),\n        s = t.originalEvent.chartX,\n        o = this.options.chart.panning,\n        r = !1;\n      if (o && \"y\" !== o.type && e.options.ordinal && e.series.length && (!t.touches || t.touches.length <= 1)) {\n        let t, o;\n        let n = this.mouseDownX,\n          a = e.getExtremes(),\n          h = a.dataMin,\n          l = a.dataMax,\n          d = a.min,\n          c = a.max,\n          p = this.hoverPoints,\n          u = e.closestPointRange || e.ordinal && e.ordinal.overscrollPointsRange,\n          g = Math.round((n - s) / (e.translationSlope * (e.ordinal.slope || u))),\n          f = e.ordinal.getExtendedPositions(),\n          m = {\n            ordinal: {\n              positions: f,\n              extendedOrdinalPositions: f\n            }\n          },\n          x = e.index2val,\n          y = e.val2lin;\n        if (d <= h && g < 0 || c + i >= l && g > 0) return;\n        m.ordinal.positions ? Math.abs(g) > 1 && (p && p.forEach(function (t) {\n          t.setState();\n        }), l > (o = m.ordinal.positions)[o.length - 1] && o.push(l), this.setFixedRange(c - d), (t = e.navigatorAxis.toFixedRange(void 0, void 0, x.apply(m, [y.apply(m, [d, !0]) + g]), x.apply(m, [y.apply(m, [c, !0]) + g]))).min >= Math.min(o[0], d) && t.max <= Math.max(o[o.length - 1], c) + i && e.setExtremes(t.min, t.max, !0, !1, {\n          trigger: \"pan\"\n        }), this.mouseDownX = s, cT(this.container, {\n          cursor: \"move\"\n        })) : r = !0;\n      } else r = !0;\n      r || o && /y/.test(o.type) ? i && (e.max = e.dataMax + i) : t.preventDefault();\n    }\n    function d() {\n      let t = this.xAxis;\n      t && t.options.ordinal && (delete t.ordinal.index, delete t.ordinal.originalOrdinalRange);\n    }\n    function c(t, e) {\n      let i;\n      let s = this.ordinal,\n        r = s.positions,\n        n = s.slope,\n        a;\n      if (!r) return t;\n      let h = r.length;\n      if (r[0] <= t && r[h - 1] >= t) i = o(r, t);else {\n        if (!((a = s.getExtendedPositions && s.getExtendedPositions()) && a.length)) return t;\n        let h = a.length;\n        n || (n = (a[h - 1] - a[0]) / h);\n        let l = o(a, r[0]);\n        if (t >= a[0] && t <= a[h - 1]) i = o(a, t) - l;else {\n          if (!e) return t;\n          i = t < a[0] ? -l - (a[0] - t) / n : (t - a[h - 1]) / n + h - l;\n        }\n      }\n      return e ? i : n * (i || 0) + s.offset;\n    }\n    t.compose = function (t, o, p) {\n      let u = t.prototype;\n      return u.ordinal2lin || (u.getTimeTicks = e, u.index2val = i, u.lin2val = s, u.val2lin = c, u.ordinal2lin = u.val2lin, cS(t, \"afterInit\", r), cS(t, \"foundExtremes\", n), cS(t, \"afterSetScale\", a), cS(t, \"initialAxisTranslation\", h), cS(p, \"pan\", l), cS(p, \"touchpan\", l), cS(o, \"updatedData\", d)), t;\n    }, t.Additions = class {\n      constructor(t) {\n        this.index = {}, this.axis = t;\n      }\n      beforeSetTickPositions() {\n        let t = this.axis,\n          e = t.ordinal,\n          i = t.getExtremes(),\n          s = i.min,\n          o = i.max,\n          r = t.brokenAxis?.hasBreaks,\n          n = t.options.ordinal,\n          a,\n          h,\n          l,\n          d,\n          c,\n          p,\n          u,\n          g = [],\n          f = Number.MAX_VALUE,\n          m = !1,\n          x = !1,\n          y = !1;\n        if (n || r) {\n          let i = 0;\n          if (t.series.forEach(function (t, e) {\n            let s = t.getColumn(\"x\", !0);\n            if (h = [], e > 0 && \"highcharts-navigator-series\" !== t.options.id && s.length > 1 && (x = i !== s[1] - s[0]), i = s[1] - s[0], t.boosted && (y = t.boosted), t.reserveSpace() && (!1 !== t.takeOrdinalPosition || r) && (a = (g = g.concat(s)).length, g.sort(function (t, e) {\n              return t - e;\n            }), f = Math.min(f, cE(t.closestPointRange, f)), a)) {\n              for (e = 0; e < a - 1;) g[e] !== g[e + 1] && h.push(g[e + 1]), e++;\n              h[0] !== g[0] && h.unshift(g[0]), g = h;\n            }\n          }), t.ordinal.originalOrdinalRange || (t.ordinal.originalOrdinalRange = (g.length - 1) * f), x && y && (g.pop(), g.shift()), (a = g.length) > 2) {\n            for (l = g[1] - g[0], u = a - 1; u-- && !m;) g[u + 1] - g[u] !== l && (m = !0);\n            !t.options.keepOrdinalPadding && (g[0] - s > l || o - g[g.length - 1] > l) && (m = !0);\n          } else t.options.overscroll && (2 === a ? f = g[1] - g[0] : 1 === a ? (f = t.ordinal.convertOverscroll(t.options.overscroll), g = [g[0], g[0] + f]) : f = e.overscrollPointsRange);\n          m || t.forceOrdinal ? (t.options.overscroll && (e.overscrollPointsRange = f, g = g.concat(e.getOverscrollPositions())), e.positions = g, d = t.ordinal2lin(Math.max(s, g[0]), !0), c = Math.max(t.ordinal2lin(Math.min(o, g[g.length - 1]), !0), 1), e.slope = p = (o - s) / (c - d), e.offset = s - d * p) : (e.overscrollPointsRange = cE(t.closestPointRange, e.overscrollPointsRange), e.positions = t.ordinal.slope = e.offset = void 0);\n        }\n        t.isOrdinal = n && m, e.groupIntervalFactor = null;\n      }\n      static findIndexOf(t, e, i) {\n        let s = 0,\n          o = t.length - 1,\n          r;\n        for (; s < o;) t[r = Math.ceil((s + o) / 2)] <= e ? s = r : o = r - 1;\n        return t[s] === e ? s : i ? s : -1;\n      }\n      getExtendedPositions(t = !0) {\n        let e = this,\n          i = e.axis,\n          s = i.constructor.prototype,\n          o = i.chart,\n          r = i.series.reduce((t, e) => {\n            let i = e.currentDataGrouping;\n            return t + (i ? i.count + i.unitName : \"raw\");\n          }, \"\"),\n          n = t ? i.ordinal.convertOverscroll(i.options.overscroll) : 0,\n          a = i.getExtremes(),\n          h,\n          l,\n          d = e.index;\n        return d || (d = e.index = {}), !d[r] && ((h = {\n          series: [],\n          chart: o,\n          forceOrdinal: !1,\n          getExtremes: function () {\n            return {\n              min: a.dataMin,\n              max: a.dataMax + n\n            };\n          },\n          applyGrouping: s.applyGrouping,\n          getGroupPixelWidth: s.getGroupPixelWidth,\n          getTimeTicks: s.getTimeTicks,\n          options: {\n            ordinal: !0\n          },\n          ordinal: {\n            getGroupIntervalFactor: this.getGroupIntervalFactor\n          },\n          ordinal2lin: s.ordinal2lin,\n          getIndexOfPoint: s.getIndexOfPoint,\n          val2lin: s.val2lin\n        }).ordinal.axis = h, i.series.forEach(i => {\n          l = {\n            xAxis: h,\n            chart: o,\n            groupPixelWidth: i.groupPixelWidth,\n            destroyGroupedData: O.noop,\n            getColumn: i.getColumn,\n            applyGrouping: i.applyGrouping,\n            getProcessedData: i.getProcessedData,\n            reserveSpace: i.reserveSpace,\n            visible: i.visible\n          };\n          let s = i.getColumn(\"x\").concat(t ? e.getOverscrollPositions() : []);\n          l.dataTable = new rl({\n            columns: {\n              x: s\n            }\n          }), l.options = {\n            ...i.options,\n            dataGrouping: i.currentDataGrouping ? {\n              firstAnchor: i.options.dataGrouping?.firstAnchor,\n              anchor: i.options.dataGrouping?.anchor,\n              lastAnchor: i.options.dataGrouping?.firstAnchor,\n              enabled: !0,\n              forced: !0,\n              approximation: \"open\",\n              units: [[i.currentDataGrouping.unitName, [i.currentDataGrouping.count]]]\n            } : {\n              enabled: !1\n            }\n          }, h.series.push(l), i.processData.apply(l);\n        }), h.applyGrouping({\n          hasExtremesChanged: !0\n        }), l?.closestPointRange !== l?.basePointRange && l.currentDataGrouping && (h.forceOrdinal = !0), i.ordinal.beforeSetTickPositions.apply({\n          axis: h\n        }), !i.ordinal.originalOrdinalRange && h.ordinal.originalOrdinalRange && (i.ordinal.originalOrdinalRange = h.ordinal.originalOrdinalRange), h.ordinal.positions && (d[r] = h.ordinal.positions)), d[r];\n      }\n      getGroupIntervalFactor(t, e, i) {\n        let s = i.getColumn(\"x\", !0),\n          o = s.length,\n          r = [],\n          n,\n          a,\n          h = this.groupIntervalFactor;\n        if (!h) {\n          for (a = 0; a < o - 1; a++) r[a] = s[a + 1] - s[a];\n          r.sort(function (t, e) {\n            return t - e;\n          }), n = r[Math.floor(o / 2)], t = Math.max(t, s[0]), e = Math.min(e, s[o - 1]), this.groupIntervalFactor = h = o * n / (e - t);\n        }\n        return h;\n      }\n      getIndexOfPoint(t, e) {\n        let i = this.axis,\n          s = i.min,\n          r = i.minPixelPadding;\n        return o(e, s) + cA((t - r) / (i.translationSlope * (this.slope || i.closestPointRange || this.overscrollPointsRange)));\n      }\n      getOverscrollPositions() {\n        let t = this.axis,\n          e = this.convertOverscroll(t.options.overscroll),\n          i = this.overscrollPointsRange,\n          s = [],\n          o = t.dataMax;\n        if (cP(i)) for (; o < t.dataMax + e;) s.push(o += i);\n        return s;\n      }\n      postProcessTickInterval(t) {\n        let e = this.axis,\n          i = this.slope,\n          s = e.closestPointRange;\n        return i && s ? e.options.breaks ? s || t : t / (i / s) : t;\n      }\n      convertOverscroll(t = 0) {\n        let e = this,\n          i = e.axis,\n          s = function (t) {\n            return cE(e.originalOrdinalRange, cP(i.dataMax) && cP(i.dataMin) ? i.dataMax - i.dataMin : 0) * t;\n          };\n        if (cB(t)) {\n          let e = parseInt(t, 10);\n          if (/%$/.test(t)) return s(e / 100);\n          if (/px/.test(t)) {\n            let t = Math.min(e, .9 * i.len) / i.len;\n            return s(t / (1 - t));\n          }\n          return 0;\n        }\n        return t;\n      }\n    };\n  }(w || (w = {}));\n  let cI = w,\n    {\n      defaultOptions: cD\n    } = tS,\n    {\n      addEvent: cR,\n      createElement: cN,\n      css: cz,\n      defined: cW,\n      destroyObjectProperties: cG,\n      diffObjects: cH,\n      discardElement: cF,\n      extend: cX,\n      fireEvent: cY,\n      isNumber: cj,\n      isString: cU,\n      merge: cV,\n      objectEach: c$,\n      pick: c_,\n      splat: cq\n    } = tt;\n  function cZ(t) {\n    let e = e => RegExp(`%[[a-zA-Z]*${e}`).test(t);\n    if (cU(t) ? -1 !== t.indexOf(\"%L\") : t.fractionalSecondDigits) return \"text\";\n    let i = cU(t) ? [\"a\", \"A\", \"d\", \"e\", \"w\", \"b\", \"B\", \"m\", \"o\", \"y\", \"Y\"].some(e) : t.dateStyle || t.day || t.month || t.year,\n      s = cU(t) ? [\"H\", \"k\", \"I\", \"l\", \"M\", \"S\"].some(e) : t.timeStyle || t.hour || t.minute || t.second;\n    return i && s ? \"datetime-local\" : i ? \"date\" : s ? \"time\" : \"text\";\n  }\n  class cK {\n    static compose(t, e) {\n      cw.compose(t, e, cK);\n    }\n    constructor(t) {\n      this.isDirty = !1, this.buttonOptions = cK.prototype.defaultButtons, this.initialButtonGroupWidth = 0, this.maxButtonWidth = () => {\n        let t = 0;\n        return this.buttons.forEach(e => {\n          let i = e.getBBox();\n          i.width > t && (t = i.width);\n        }), t;\n      }, this.init(t);\n    }\n    clickButton(t, e) {\n      let i = this.chart,\n        s = this.buttonOptions[t],\n        o = i.xAxis[0],\n        r = i.scroller && i.scroller.getUnionExtremes() || o || {},\n        n = s.type,\n        a = s.dataGrouping,\n        h = r.dataMin,\n        l = r.dataMax,\n        d,\n        c = cj(o?.max) ? Math.round(Math.min(o.max, l ?? o.max)) : void 0,\n        p,\n        u = s._range,\n        g,\n        f,\n        m,\n        x = !0;\n      if (null !== h && null !== l) {\n        if (this.setSelected(t), a && (this.forcedDataGrouping = !0, sU.prototype.setDataGrouping.call(o || {\n          chart: this.chart\n        }, a, !1), this.frozenStates = s.preserveDataGrouping), \"month\" === n || \"year\" === n) o ? (f = {\n          range: s,\n          max: c,\n          chart: i,\n          dataMin: h,\n          dataMax: l\n        }, d = o.minFromRange.call(f), cj(f.newMax) && (c = f.newMax), x = !1) : u = s;else if (u) cj(c) && (c = Math.min((d = Math.max(c - u, h)) + u, l), x = !1);else if (\"ytd\" === n) {\n          if (o) !o.hasData() || cj(l) && cj(h) || (h = Number.MAX_VALUE, l = -Number.MAX_VALUE, i.series.forEach(t => {\n            let e = t.getColumn(\"x\");\n            e.length && (h = Math.min(e[0], h), l = Math.max(e[e.length - 1], l));\n          }), e = !1), cj(l) && cj(h) && (d = g = (m = this.getYTDExtremes(l, h)).min, c = m.max);else {\n            this.deferredYTDClick = t;\n            return;\n          }\n        } else \"all\" === n && o && (i.navigator && i.navigator.baseSeries[0] && (i.navigator.baseSeries[0].xAxis.options.range = void 0), d = h, c = l);\n        if (x && s._offsetMin && cW(d) && (d += s._offsetMin), s._offsetMax && cW(c) && (c += s._offsetMax), this.dropdown && (this.dropdown.selectedIndex = t + 1), o) cj(d) && cj(c) && (o.setExtremes(d, c, c_(e, !0), void 0, {\n          trigger: \"rangeSelectorButton\",\n          rangeSelectorButton: s\n        }), i.setFixedRange(s._range));else {\n          p = cq(i.options.xAxis || {})[0];\n          let t = cR(i, \"afterCreateAxes\", function () {\n            let t = i.xAxis[0];\n            t.range = t.options.range = u, t.min = t.options.min = g;\n          });\n          cR(i, \"load\", function () {\n            let e = i.xAxis[0];\n            i.setFixedRange(s._range), e.options.range = p.range, e.options.min = p.min, t();\n          });\n        }\n        cY(this, \"afterBtnClick\");\n      }\n    }\n    setSelected(t) {\n      this.selected = this.options.selected = t;\n    }\n    init(t) {\n      let e = this,\n        i = t.options.rangeSelector,\n        s = i.buttons,\n        o = i.selected,\n        r = function () {\n          let t = e.minInput,\n            i = e.maxInput;\n          t && t.blur && cY(t, \"blur\"), i && i.blur && cY(i, \"blur\");\n        };\n      e.chart = t, e.options = i, e.buttons = [], e.buttonOptions = s, this.eventsToUnbind = [], this.eventsToUnbind.push(cR(t.container, \"mousedown\", r)), this.eventsToUnbind.push(cR(t, \"resize\", r)), s.forEach(e.computeButtonRange), void 0 !== o && s[o] && this.clickButton(o, !1), this.eventsToUnbind.push(cR(t, \"load\", function () {\n        t.xAxis && t.xAxis[0] && cR(t.xAxis[0], \"setExtremes\", function (i) {\n          cj(this.max) && cj(this.min) && this.max - this.min !== t.fixedRange && \"rangeSelectorButton\" !== i.trigger && \"updatedData\" !== i.trigger && e.forcedDataGrouping && !e.frozenStates && this.setDataGrouping(!1, !1);\n        });\n      })), this.createElements();\n    }\n    updateButtonStates() {\n      let t = this,\n        e = this.chart,\n        i = this.dropdown,\n        s = this.dropdownLabel,\n        o = e.xAxis[0],\n        r = Math.round(o.max - o.min),\n        n = !o.hasVisibleSeries,\n        a = 24 * 36e5,\n        h = e.scroller && e.scroller.getUnionExtremes() || o,\n        l = h.dataMin,\n        d = h.dataMax,\n        c = t.getYTDExtremes(d, l),\n        p = c.min,\n        u = c.max,\n        g = t.selected,\n        f = t.options.allButtonsEnabled,\n        m = Array(t.buttonOptions.length).fill(0),\n        x = cj(g),\n        y = t.buttons,\n        b = !1,\n        v = null;\n      t.buttonOptions.forEach((e, i) => {\n        let s = e._range,\n          h = e.type,\n          c = e.count || 1,\n          y = e._offsetMax - e._offsetMin,\n          M = i === g,\n          k = s > d - l,\n          w = s < o.minRange,\n          S = !1,\n          A = s === r;\n        if (M && k && (b = !0), o.isOrdinal && o.ordinal?.positions && s && r < s) {\n          let t = o.ordinal.positions,\n            e = cI.Additions.findIndexOf(t, o.min, !0),\n            i = Math.min(cI.Additions.findIndexOf(t, o.max, !0) + 1, t.length - 1);\n          t[i] - t[e] > s && (A = !0);\n        } else (\"month\" === h || \"year\" === h) && r + 36e5 >= {\n          month: 28,\n          year: 365\n        }[h] * a * c - y && r - 36e5 <= {\n          month: 31,\n          year: 366\n        }[h] * a * c + y ? A = !0 : \"ytd\" === h ? (A = u - p + y === r, S = !M) : \"all\" === h && (A = o.max - o.min >= d - l);\n        let T = !f && !(b && \"all\" === h) && (k || w || n),\n          P = b && \"all\" === h || !S && A || M && t.frozenStates;\n        T ? m[i] = 3 : P && (!x || i === g) && (v = i);\n      }), null !== v ? (m[v] = 2, t.setSelected(v), this.dropdown && (this.dropdown.selectedIndex = v + 1)) : (t.setSelected(), this.dropdown && (this.dropdown.selectedIndex = -1), s && (s.setState(0), s.attr({\n        text: (cD.lang.rangeSelectorZoom || \"\") + \" ▾\"\n      })));\n      for (let e = 0; e < m.length; e++) {\n        let o = m[e],\n          r = y[e];\n        if (r.state !== o && (r.setState(o), i)) {\n          i.options[e + 1].disabled = 3 === o, 2 === o && (s && (s.setState(2), s.attr({\n            text: t.buttonOptions[e].text + \" ▾\"\n          })), i.selectedIndex = e + 1);\n          let r = s.getBBox();\n          cz(i, {\n            width: `${r.width}px`,\n            height: `${r.height}px`\n          });\n        }\n      }\n    }\n    computeButtonRange(t) {\n      let e = t.type,\n        i = t.count || 1,\n        s = {\n          millisecond: 1,\n          second: 1e3,\n          minute: 6e4,\n          hour: 36e5,\n          day: 864e5,\n          week: 6048e5\n        };\n      s[e] ? t._range = s[e] * i : (\"month\" === e || \"year\" === e) && (t._range = 24 * {\n        month: 30,\n        year: 365\n      }[e] * 36e5 * i), t._offsetMin = c_(t.offsetMin, 0), t._offsetMax = c_(t.offsetMax, 0), t._range += t._offsetMax - t._offsetMin;\n    }\n    getInputValue(t) {\n      let e = \"min\" === t ? this.minInput : this.maxInput,\n        i = this.chart.options.rangeSelector,\n        s = this.chart.time;\n      return e ? (\"text\" === e.type && i.inputDateParser || this.defaultInputDateParser)(e.value, \"UTC\" === s.timezone, s) : 0;\n    }\n    setInputValue(t, e) {\n      let i = this.options,\n        s = this.chart.time,\n        o = \"min\" === t ? this.minInput : this.maxInput,\n        r = \"min\" === t ? this.minDateBox : this.maxDateBox;\n      if (o) {\n        o.setAttribute(\"type\", cZ(i.inputDateFormat || \"%e %b %Y\"));\n        let t = o.getAttribute(\"data-hc-time\"),\n          n = cW(t) ? Number(t) : void 0;\n        if (cW(e)) {\n          let t = n;\n          cW(t) && o.setAttribute(\"data-hc-time-previous\", t), o.setAttribute(\"data-hc-time\", e), n = e;\n        }\n        o.value = s.dateFormat(this.inputTypeFormats[o.type] || i.inputEditDateFormat, n), r && r.attr({\n          text: s.dateFormat(i.inputDateFormat, n)\n        });\n      }\n    }\n    setInputExtremes(t, e, i) {\n      let s = \"min\" === t ? this.minInput : this.maxInput;\n      if (s) {\n        let t = this.inputTypeFormats[s.type],\n          o = this.chart.time;\n        if (t) {\n          let r = o.dateFormat(t, e);\n          s.min !== r && (s.min = r);\n          let n = o.dateFormat(t, i);\n          s.max !== n && (s.max = n);\n        }\n      }\n    }\n    showInput(t) {\n      let e = \"min\" === t ? this.minDateBox : this.maxDateBox,\n        i = \"min\" === t ? this.minInput : this.maxInput;\n      if (i && e && this.inputGroup) {\n        let t = \"text\" === i.type,\n          {\n            translateX: s = 0,\n            translateY: o = 0\n          } = this.inputGroup,\n          {\n            x: r = 0,\n            width: n = 0,\n            height: a = 0\n          } = e,\n          {\n            inputBoxWidth: h\n          } = this.options;\n        cz(i, {\n          width: t ? n + (h ? -2 : 20) + \"px\" : \"auto\",\n          height: a - 2 + \"px\",\n          border: \"2px solid silver\"\n        }), t && h ? cz(i, {\n          left: s + r + \"px\",\n          top: o + \"px\"\n        }) : cz(i, {\n          left: Math.min(Math.round(r + s - (i.offsetWidth - n) / 2), this.chart.chartWidth - i.offsetWidth) + \"px\",\n          top: o - (i.offsetHeight - a) / 2 + \"px\"\n        });\n      }\n    }\n    hideInput(t) {\n      let e = \"min\" === t ? this.minInput : this.maxInput;\n      e && cz(e, {\n        top: \"-9999em\",\n        border: 0,\n        width: \"1px\",\n        height: \"1px\"\n      });\n    }\n    defaultInputDateParser(t, e, i) {\n      return i?.parse(t) || 0;\n    }\n    drawInput(t) {\n      let {\n          chart: e,\n          div: i,\n          inputGroup: s\n        } = this,\n        o = this,\n        r = e.renderer.style || {},\n        n = e.renderer,\n        a = e.options.rangeSelector,\n        h = cD.lang,\n        l = \"min\" === t;\n      function d(t) {\n        let {\n            maxInput: i,\n            minInput: s\n          } = o,\n          r = e.xAxis[0],\n          n = e.scroller?.getUnionExtremes() || r,\n          a = n.dataMin,\n          h = n.dataMax,\n          d = e.xAxis[0].getExtremes()[t],\n          c = o.getInputValue(t);\n        cj(c) && c !== d && (l && i && cj(a) ? c > Number(i.getAttribute(\"data-hc-time\")) ? c = void 0 : c < a && (c = a) : s && cj(h) && (c < Number(s.getAttribute(\"data-hc-time\")) ? c = void 0 : c > h && (c = h)), void 0 !== c && r.setExtremes(l ? c : r.min, l ? r.max : c, void 0, void 0, {\n          trigger: \"rangeSelectorInput\"\n        }));\n      }\n      let c = h[l ? \"rangeSelectorFrom\" : \"rangeSelectorTo\"] || \"\",\n        p = n.label(c, 0).addClass(\"highcharts-range-label\").attr({\n          padding: c ? 2 : 0,\n          height: c ? a.inputBoxHeight : 0\n        }).add(s),\n        u = n.label(\"\", 0).addClass(\"highcharts-range-input\").attr({\n          padding: 2,\n          width: a.inputBoxWidth,\n          height: a.inputBoxHeight,\n          \"text-align\": \"center\"\n        }).on(\"click\", function () {\n          o.showInput(t), o[t + \"Input\"].focus();\n        });\n      e.styledMode || u.attr({\n        stroke: a.inputBoxBorderColor,\n        \"stroke-width\": 1\n      }), u.add(s);\n      let g = cN(\"input\", {\n        name: t,\n        className: \"highcharts-range-selector\"\n      }, void 0, i);\n      g.setAttribute(\"type\", cZ(a.inputDateFormat || \"%e %b %Y\")), e.styledMode || (p.css(cV(r, a.labelStyle)), u.css(cV({\n        color: \"#333333\"\n      }, r, a.inputStyle)), cz(g, cX({\n        position: \"absolute\",\n        border: 0,\n        boxShadow: \"0 0 15px rgba(0,0,0,0.3)\",\n        width: \"1px\",\n        height: \"1px\",\n        padding: 0,\n        textAlign: \"center\",\n        fontSize: r.fontSize,\n        fontFamily: r.fontFamily,\n        top: \"-9999em\"\n      }, a.inputStyle))), g.onfocus = () => {\n        o.showInput(t);\n      }, g.onblur = () => {\n        g === O.doc.activeElement && d(t), o.hideInput(t), o.setInputValue(t), g.blur();\n      };\n      let f = !1;\n      return g.onchange = () => {\n        f || (d(t), o.hideInput(t), g.blur());\n      }, g.onkeypress = e => {\n        13 === e.keyCode && d(t);\n      }, g.onkeydown = e => {\n        f = !0, (\"ArrowUp\" === e.key || \"ArrowDown\" === e.key || \"Tab\" === e.key) && d(t);\n      }, g.onkeyup = () => {\n        f = !1;\n      }, {\n        dateBox: u,\n        input: g,\n        label: p\n      };\n    }\n    getPosition() {\n      let t = this.chart,\n        e = t.options.rangeSelector,\n        i = \"top\" === e.verticalAlign ? t.plotTop - t.axisOffset[0] : 0;\n      return {\n        buttonTop: i + e.buttonPosition.y,\n        inputTop: i + e.inputPosition.y - 10\n      };\n    }\n    getYTDExtremes(t, e) {\n      let i = this.chart.time,\n        s = i.toParts(t)[0];\n      return {\n        max: t,\n        min: Math.max(e, i.makeTime(s, 0))\n      };\n    }\n    createElements() {\n      let t = this.chart,\n        e = t.renderer,\n        i = t.container,\n        s = t.options,\n        o = s.rangeSelector,\n        r = o.inputEnabled,\n        n = c_(s.chart.style?.zIndex, 0) + 1;\n      !1 !== o.enabled && (this.group = e.g(\"range-selector-group\").attr({\n        zIndex: 7\n      }).add(), this.div = cN(\"div\", void 0, {\n        position: \"relative\",\n        height: 0,\n        zIndex: n\n      }), this.buttonOptions.length && this.renderButtons(), i.parentNode && i.parentNode.insertBefore(this.div, i), r && this.createInputs());\n    }\n    createInputs() {\n      this.inputGroup = this.chart.renderer.g(\"input-group\").add(this.group);\n      let t = this.drawInput(\"min\");\n      this.minDateBox = t.dateBox, this.minLabel = t.label, this.minInput = t.input;\n      let e = this.drawInput(\"max\");\n      this.maxDateBox = e.dateBox, this.maxLabel = e.label, this.maxInput = e.input;\n    }\n    render(t, e) {\n      if (!1 === this.options.enabled) return;\n      let i = this.chart,\n        s = i.options.rangeSelector;\n      if (s.inputEnabled) {\n        this.inputGroup || this.createInputs(), this.setInputValue(\"min\", t), this.setInputValue(\"max\", e), this.chart.styledMode || (this.maxLabel?.css(s.labelStyle), this.minLabel?.css(s.labelStyle));\n        let o = i.scroller && i.scroller.getUnionExtremes() || i.xAxis[0] || {};\n        if (cW(o.dataMin) && cW(o.dataMax)) {\n          let t = i.xAxis[0].minRange || 0;\n          this.setInputExtremes(\"min\", o.dataMin, Math.min(o.dataMax, this.getInputValue(\"max\")) - t), this.setInputExtremes(\"max\", Math.max(o.dataMin, this.getInputValue(\"min\")) + t, o.dataMax);\n        }\n        if (this.inputGroup) {\n          let t = 0;\n          [this.minLabel, this.minDateBox, this.maxLabel, this.maxDateBox].forEach(e => {\n            if (e) {\n              let {\n                width: i\n              } = e.getBBox();\n              i && (e.attr({\n                x: t\n              }), t += i + s.inputSpacing);\n            }\n          });\n        }\n      } else this.inputGroup && (this.inputGroup.destroy(), delete this.inputGroup);\n      !this.chart.styledMode && this.zoomText && this.zoomText.css(s.labelStyle), this.alignElements(), this.updateButtonStates();\n    }\n    renderButtons() {\n      var t;\n      let {\n          chart: e,\n          options: i\n        } = this,\n        s = cD.lang,\n        o = e.renderer,\n        r = cV(i.buttonTheme),\n        n = r && r.states;\n      delete r.width, delete r.states, this.buttonGroup = o.g(\"range-selector-buttons\").add(this.group);\n      let a = this.dropdown = cN(\"select\", void 0, {\n          position: \"absolute\",\n          padding: 0,\n          border: 0,\n          cursor: \"pointer\",\n          opacity: 1e-4\n        }, this.div),\n        h = e.userOptions.rangeSelector?.buttonTheme;\n      this.dropdownLabel = o.button(\"\", 0, 0, () => {}, cV(r, {\n        \"stroke-width\": c_(r[\"stroke-width\"], 0),\n        width: \"auto\",\n        paddingLeft: c_(i.buttonTheme.paddingLeft, h?.padding, 8),\n        paddingRight: c_(i.buttonTheme.paddingRight, h?.padding, 8)\n      }), n && n.hover, n && n.select, n && n.disabled).hide().add(this.group), cR(a, \"touchstart\", () => {\n        a.style.fontSize = \"16px\";\n      });\n      let l = O.isMS ? \"mouseover\" : \"mouseenter\",\n        d = O.isMS ? \"mouseout\" : \"mouseleave\";\n      cR(a, l, () => {\n        cY(this.dropdownLabel.element, l);\n      }), cR(a, d, () => {\n        cY(this.dropdownLabel.element, d);\n      }), cR(a, \"change\", () => {\n        cY(this.buttons[a.selectedIndex - 1].element, \"click\");\n      }), this.zoomText = o.label(s.rangeSelectorZoom || \"\", 0).attr({\n        padding: i.buttonTheme.padding,\n        height: i.buttonTheme.height,\n        paddingLeft: 0,\n        paddingRight: 0\n      }).add(this.buttonGroup), this.chart.styledMode || (this.zoomText.css(i.labelStyle), (t = i.buttonTheme)[\"stroke-width\"] ?? (t[\"stroke-width\"] = 0)), cN(\"option\", {\n        textContent: this.zoomText.textStr,\n        disabled: !0\n      }, void 0, a), this.createButtons();\n    }\n    createButtons() {\n      let {\n          options: t\n        } = this,\n        e = cV(t.buttonTheme),\n        i = e && e.states,\n        s = e.width || 28;\n      delete e.width, delete e.states, this.buttonOptions.forEach((t, e) => {\n        this.createButton(t, e, s, i);\n      });\n    }\n    createButton(t, e, i, s) {\n      let {\n          dropdown: o,\n          buttons: r,\n          chart: n,\n          options: a\n        } = this,\n        h = n.renderer,\n        l = cV(a.buttonTheme);\n      o?.add(cN(\"option\", {\n        textContent: t.title || t.text\n      }), e + 2), r[e] = h.button(t.text, 0, 0, i => {\n        let s;\n        let o = t.events && t.events.click;\n        o && (s = o.call(t, i)), !1 !== s && this.clickButton(e), this.isActive = !0;\n      }, l, s && s.hover, s && s.select, s && s.disabled).attr({\n        \"text-align\": \"center\",\n        width: i\n      }).add(this.buttonGroup), t.title && r[e].attr(\"title\", t.title);\n    }\n    alignElements() {\n      let {\n          buttonGroup: t,\n          buttons: e,\n          chart: i,\n          group: s,\n          inputGroup: o,\n          options: r,\n          zoomText: n\n        } = this,\n        a = i.options,\n        h = a.exporting && !1 !== a.exporting.enabled && a.navigation && a.navigation.buttonOptions,\n        {\n          buttonPosition: l,\n          inputPosition: d,\n          verticalAlign: c\n        } = r,\n        p = (t, e, s) => h && this.titleCollision(i) && \"top\" === c && s && e.y - t.getBBox().height - 12 < (h.y || 0) + (h.height || 0) + i.spacing[0] ? -40 : 0,\n        u = i.plotLeft;\n      if (s && l && d) {\n        let a = l.x - i.spacing[3];\n        if (t) {\n          if (this.positionButtons(), !this.initialButtonGroupWidth) {\n            let t = 0;\n            n && (t += n.getBBox().width + 5), e.forEach((i, s) => {\n              t += i.width || 0, s !== e.length - 1 && (t += r.buttonSpacing);\n            }), this.initialButtonGroupWidth = t;\n          }\n          u -= i.spacing[3];\n          let o = p(t, l, \"right\" === l.align || \"right\" === d.align);\n          this.alignButtonGroup(o), this.buttonGroup?.translateY && this.dropdownLabel.attr({\n            y: this.buttonGroup.translateY\n          }), s.placed = t.placed = i.hasLoaded;\n        }\n        let h = 0;\n        r.inputEnabled && o && (h = p(o, d, \"right\" === l.align || \"right\" === d.align), \"left\" === d.align ? a = u : \"right\" === d.align && (a = -Math.max(i.axisOffset[1], -h)), o.align({\n          y: d.y,\n          width: o.getBBox().width,\n          align: d.align,\n          x: d.x + a - 2\n        }, !0, i.spacingBox), o.placed = i.hasLoaded), this.handleCollision(h), s.align({\n          verticalAlign: c\n        }, !0, i.spacingBox);\n        let g = s.alignAttr.translateY,\n          f = s.getBBox().height + 20,\n          m = 0;\n        if (\"bottom\" === c) {\n          let t = i.legend && i.legend.options;\n          m = g - (f = f + (t && \"bottom\" === t.verticalAlign && t.enabled && !t.floating ? i.legend.legendHeight + c_(t.margin, 10) : 0) - 20) - (r.floating ? 0 : r.y) - (i.titleOffset ? i.titleOffset[2] : 0) - 10;\n        }\n        \"top\" === c ? (r.floating && (m = 0), i.titleOffset && i.titleOffset[0] && (m = i.titleOffset[0]), m += i.margin[0] - i.spacing[0] || 0) : \"middle\" === c && (d.y === l.y ? m = g : (d.y || l.y) && (d.y < 0 || l.y < 0 ? m -= Math.min(d.y, l.y) : m = g - f)), s.translate(r.x, r.y + Math.floor(m));\n        let {\n          minInput: x,\n          maxInput: y,\n          dropdown: b\n        } = this;\n        r.inputEnabled && x && y && (x.style.marginTop = s.translateY + \"px\", y.style.marginTop = s.translateY + \"px\"), b && (b.style.marginTop = s.translateY + \"px\");\n      }\n    }\n    redrawElements() {\n      let t = this.chart,\n        {\n          inputBoxHeight: e,\n          inputBoxBorderColor: i\n        } = this.options;\n      if (this.maxDateBox?.attr({\n        height: e\n      }), this.minDateBox?.attr({\n        height: e\n      }), t.styledMode || (this.maxDateBox?.attr({\n        stroke: i\n      }), this.minDateBox?.attr({\n        stroke: i\n      })), this.isDirty) {\n        this.isDirty = !1, this.isCollapsed = void 0;\n        let t = this.options.buttons ?? [],\n          e = Math.min(t.length, this.buttonOptions.length),\n          {\n            dropdown: i,\n            options: s\n          } = this,\n          o = cV(s.buttonTheme),\n          r = o && o.states,\n          n = o.width || 28;\n        if (t.length < this.buttonOptions.length) for (let e = this.buttonOptions.length - 1; e >= t.length; e--) {\n          let t = this.buttons.pop();\n          t?.destroy(), this.dropdown?.options.remove(e + 1);\n        }\n        for (let s = e - 1; s >= 0; s--) if (0 !== Object.keys(cH(t[s], this.buttonOptions[s])).length) {\n          let e = t[s];\n          this.buttons[s].destroy(), i?.options.remove(s + 1), this.createButton(e, s, n, r), this.computeButtonRange(e);\n        }\n        if (t.length > this.buttonOptions.length) for (let e = this.buttonOptions.length; e < t.length; e++) this.createButton(t[e], e, n, r), this.computeButtonRange(t[e]);\n        this.buttonOptions = this.options.buttons ?? [], cW(this.options.selected) && this.buttons.length && this.clickButton(this.options.selected, !1);\n      }\n    }\n    alignButtonGroup(t, e) {\n      let {\n          chart: i,\n          options: s,\n          buttonGroup: o,\n          dropdown: r,\n          dropdownLabel: n\n        } = this,\n        {\n          buttonPosition: a\n        } = s,\n        h = i.plotLeft - i.spacing[3],\n        l = a.x - i.spacing[3],\n        d = i.plotLeft;\n      \"right\" === a.align ? (l += t - h, this.hasVisibleDropdown && (d = i.chartWidth + t - this.maxButtonWidth() - 20)) : \"center\" === a.align && (l -= h / 2, this.hasVisibleDropdown && (d = i.chartWidth / 2 - this.maxButtonWidth())), r && cz(r, {\n        left: d + \"px\",\n        top: o?.translateY + \"px\"\n      }), n?.attr({\n        x: d\n      }), o && o.align({\n        y: a.y,\n        width: c_(e, this.initialButtonGroupWidth),\n        align: a.align,\n        x: l\n      }, !0, i.spacingBox);\n    }\n    positionButtons() {\n      let {\n          buttons: t,\n          chart: e,\n          options: i,\n          zoomText: s\n        } = this,\n        o = e.hasLoaded ? \"animate\" : \"attr\",\n        {\n          buttonPosition: r\n        } = i,\n        n = e.plotLeft,\n        a = n;\n      s && \"hidden\" !== s.visibility && (s[o]({\n        x: c_(n + r.x, n)\n      }), a += r.x + s.getBBox().width + 5);\n      for (let e = 0, s = this.buttonOptions.length; e < s; ++e) \"hidden\" !== t[e].visibility ? (t[e][o]({\n        x: a\n      }), a += (t[e].width || 0) + i.buttonSpacing) : t[e][o]({\n        x: n\n      });\n    }\n    handleCollision(t) {\n      let {\n          chart: e,\n          buttonGroup: i,\n          inputGroup: s,\n          initialButtonGroupWidth: o\n        } = this,\n        {\n          buttonPosition: r,\n          dropdown: n,\n          inputPosition: a\n        } = this.options,\n        h = () => {\n          s && i && s.attr({\n            translateX: s.alignAttr.translateX + (e.axisOffset[1] >= -t ? 0 : -t),\n            translateY: s.alignAttr.translateY + i.getBBox().height + 10\n          });\n        };\n      s && i ? a.align === r.align ? (h(), o > e.plotWidth + t - 20 ? this.collapseButtons() : this.expandButtons()) : o - t + s.getBBox().width > e.plotWidth ? \"responsive\" === n ? this.collapseButtons() : h() : this.expandButtons() : i && \"responsive\" === n && (o > e.plotWidth ? this.collapseButtons() : this.expandButtons()), i && (\"always\" === n && this.collapseButtons(), \"never\" === n && this.expandButtons()), this.alignButtonGroup(t);\n    }\n    collapseButtons() {\n      let {\n        buttons: t,\n        zoomText: e\n      } = this;\n      !0 !== this.isCollapsed && (this.isCollapsed = !0, e.hide(), t.forEach(t => void t.hide()), this.showDropdown());\n    }\n    expandButtons() {\n      let {\n        buttons: t,\n        zoomText: e\n      } = this;\n      !1 !== this.isCollapsed && (this.isCollapsed = !1, this.hideDropdown(), e.show(), t.forEach(t => void t.show()), this.positionButtons());\n    }\n    showDropdown() {\n      let {\n        buttonGroup: t,\n        dropdownLabel: e,\n        dropdown: i\n      } = this;\n      t && i && (e.show(), cz(i, {\n        visibility: \"inherit\"\n      }), this.hasVisibleDropdown = !0);\n    }\n    hideDropdown() {\n      let {\n        dropdown: t\n      } = this;\n      t && (this.dropdownLabel.hide(), cz(t, {\n        visibility: \"hidden\",\n        width: \"1px\",\n        height: \"1px\"\n      }), this.hasVisibleDropdown = !1);\n    }\n    getHeight() {\n      let t = this.options,\n        e = this.group,\n        i = t.inputPosition,\n        s = t.buttonPosition,\n        o = t.y,\n        r = s.y,\n        n = i.y,\n        a = 0;\n      if (t.height) return t.height;\n      this.alignElements(), a = e ? e.getBBox(!0).height + 13 + o : 0;\n      let h = Math.min(n, r);\n      return (n < 0 && r < 0 || n > 0 && r > 0) && (a += Math.abs(h)), a;\n    }\n    titleCollision(t) {\n      return !(t.options.title.text || t.options.subtitle.text);\n    }\n    update(t, e = !0) {\n      let i = this.chart;\n      if (cV(!0, this.options, t), this.options.selected && this.options.selected >= this.options.buttons.length && (this.options.selected = void 0, i.options.rangeSelector.selected = void 0), cW(t.enabled)) return this.destroy(), this.init(i);\n      this.isDirty = !!t.buttons, e && this.render();\n    }\n    destroy() {\n      let t = this,\n        e = t.minInput,\n        i = t.maxInput;\n      t.eventsToUnbind && (t.eventsToUnbind.forEach(t => t()), t.eventsToUnbind = void 0), cG(t.buttons), e && (e.onfocus = e.onblur = e.onchange = null), i && (i.onfocus = i.onblur = i.onchange = null), c$(t, function (e, i) {\n        e && \"chart\" !== i && (e instanceof eJ ? e.destroy() : e instanceof window.HTMLElement && cF(e), delete t[i]), e !== cK.prototype[i] && (t[i] = null);\n      }, this), this.buttons = [];\n    }\n  }\n  cX(cK.prototype, {\n    inputTypeFormats: {\n      \"datetime-local\": \"%Y-%m-%dT%H:%M:%S\",\n      date: \"%Y-%m-%d\",\n      time: \"%H:%M:%S\"\n    }\n  });\n  let cJ = {\n      applyRadius: function (t, e) {\n        let i = [];\n        for (let s = 0; s < t.length; s++) {\n          let o = t[s][1],\n            r = t[s][2];\n          if (\"number\" == typeof o && \"number\" == typeof r) {\n            if (0 === s) i.push([\"M\", o, r]);else if (s === t.length - 1) i.push([\"L\", o, r]);else if (e) {\n              let n = t[s - 1],\n                a = t[s + 1];\n              if (n && a) {\n                let t = n[1],\n                  s = n[2],\n                  h = a[1],\n                  l = a[2];\n                if (\"number\" == typeof t && \"number\" == typeof h && \"number\" == typeof s && \"number\" == typeof l && t !== h && s !== l) {\n                  let n = t < h ? 1 : -1,\n                    a = s < l ? 1 : -1;\n                  i.push([\"L\", o - n * Math.min(Math.abs(o - t), e), r - a * Math.min(Math.abs(r - s), e)], [\"C\", o, r, o, r, o + n * Math.min(Math.abs(o - h), e), r + a * Math.min(Math.abs(r - l), e)]);\n                }\n              }\n            } else i.push([\"L\", o, r]);\n          }\n        }\n        return i;\n      }\n    },\n    {\n      pick: cQ\n    } = tt,\n    {\n      min: c0,\n      max: c1,\n      abs: c2\n    } = Math;\n  function c3(t, e, i) {\n    let s = e - 1e-7,\n      o = i || 0,\n      r = t.length - 1,\n      n,\n      a;\n    for (; o <= r;) if ((a = s - t[n = r + o >> 1].xMin) > 0) o = n + 1;else {\n      if (!(a < 0)) return n;\n      r = n - 1;\n    }\n    return o > 0 ? o - 1 : 0;\n  }\n  function c5(t, e) {\n    let i = c3(t, e.x + 1) + 1;\n    for (; i--;) {\n      var s;\n      if (t[i].xMax >= e.x && (s = t[i], e.x <= s.xMax && e.x >= s.xMin && e.y <= s.yMax && e.y >= s.yMin)) return i;\n    }\n    return -1;\n  }\n  function c6(t) {\n    let e = [];\n    if (t.length) {\n      e.push([\"M\", t[0].start.x, t[0].start.y]);\n      for (let i = 0; i < t.length; ++i) e.push([\"L\", t[i].end.x, t[i].end.y]);\n    }\n    return e;\n  }\n  function c9(t, e) {\n    t.yMin = c1(t.yMin, e.yMin), t.yMax = c0(t.yMax, e.yMax), t.xMin = c1(t.xMin, e.xMin), t.xMax = c0(t.xMax, e.xMax);\n  }\n  let c4 = function (t, e, i) {\n    let s = [],\n      o = i.chartObstacles,\n      r = c5(o, t),\n      n = c5(o, e),\n      a,\n      h = cQ(i.startDirectionX, c2(e.x - t.x) > c2(e.y - t.y)) ? \"x\" : \"y\",\n      l,\n      d,\n      c,\n      p;\n    function u(t, e, i, s, o) {\n      let r = {\n        x: t.x,\n        y: t.y\n      };\n      return r[e] = i[s || e] + (o || 0), r;\n    }\n    function g(t, e, i) {\n      let s = c2(e[i] - t[i + \"Min\"]) > c2(e[i] - t[i + \"Max\"]);\n      return u(e, i, t, i + (s ? \"Max\" : \"Min\"), s ? 1 : -1);\n    }\n    n > -1 ? (a = {\n      start: d = g(o[n], e, h),\n      end: e\n    }, p = d) : p = e, r > -1 && (d = g(l = o[r], t, h), s.push({\n      start: t,\n      end: d\n    }), d[h] >= t[h] == d[h] >= p[h] && (c = t[h = \"y\" === h ? \"x\" : \"y\"] < e[h], s.push({\n      start: d,\n      end: u(d, h, l, h + (c ? \"Max\" : \"Min\"), c ? 1 : -1)\n    }), h = \"y\" === h ? \"x\" : \"y\"));\n    let f = s.length ? s[s.length - 1].end : t;\n    d = u(f, h, p), s.push({\n      start: f,\n      end: d\n    });\n    let m = u(d, h = \"y\" === h ? \"x\" : \"y\", p);\n    return s.push({\n      start: d,\n      end: m\n    }), s.push(a), {\n      path: cJ.applyRadius(c6(s), i.radius),\n      obstacles: s\n    };\n  };\n  function c8(t, e, i) {\n    let s = cQ(i.startDirectionX, c2(e.x - t.x) > c2(e.y - t.y)),\n      o = s ? \"x\" : \"y\",\n      r = [],\n      n = i.obstacleMetrics,\n      a = c0(t.x, e.x) - n.maxWidth - 10,\n      h = c1(t.x, e.x) + n.maxWidth + 10,\n      l = c0(t.y, e.y) - n.maxHeight - 10,\n      d = c1(t.y, e.y) + n.maxHeight + 10,\n      c,\n      p,\n      u,\n      g = !1,\n      f = i.chartObstacles,\n      m = c3(f, h),\n      x = c3(f, a);\n    function y(t, e, i) {\n      let s, o, r, n;\n      let a = t.x < e.x ? 1 : -1;\n      t.x < e.x ? (s = t, o = e) : (s = e, o = t), t.y < e.y ? (n = t, r = e) : (n = e, r = t);\n      let h = a < 0 ? c0(c3(f, o.x), f.length - 1) : 0;\n      for (; f[h] && (a > 0 && f[h].xMin <= o.x || a < 0 && f[h].xMax >= s.x);) {\n        if (f[h].xMin <= o.x && f[h].xMax >= s.x && f[h].yMin <= r.y && f[h].yMax >= n.y) {\n          if (i) return {\n            y: t.y,\n            x: t.x < e.x ? f[h].xMin - 1 : f[h].xMax + 1,\n            obstacle: f[h]\n          };\n          return {\n            x: t.x,\n            y: t.y < e.y ? f[h].yMin - 1 : f[h].yMax + 1,\n            obstacle: f[h]\n          };\n        }\n        h += a;\n      }\n      return e;\n    }\n    function b(t, e, i, s, o) {\n      let r = o.soft,\n        n = o.hard,\n        a = s ? \"x\" : \"y\",\n        h = {\n          x: e.x,\n          y: e.y\n        },\n        l = {\n          x: e.x,\n          y: e.y\n        },\n        d = t[a + \"Max\"] >= r[a + \"Max\"],\n        c = t[a + \"Min\"] <= r[a + \"Min\"],\n        p = t[a + \"Max\"] >= n[a + \"Max\"],\n        u = t[a + \"Min\"] <= n[a + \"Min\"],\n        g = c2(t[a + \"Min\"] - e[a]),\n        f = c2(t[a + \"Max\"] - e[a]),\n        m = 10 > c2(g - f) ? e[a] < i[a] : f < g;\n      l[a] = t[a + \"Min\"], h[a] = t[a + \"Max\"];\n      let x = y(e, l, s)[a] !== l[a],\n        b = y(e, h, s)[a] !== h[a];\n      return m = x ? !b || m : !b && m, m = c ? !d || m : !d && m, m = u ? !p || m : !p && m;\n    }\n    for ((m = c5(f = f.slice(x, m + 1), e)) > -1 && (u = function (t, e, s) {\n      let o = c0(t.xMax - e.x, e.x - t.xMin) < c0(t.yMax - e.y, e.y - t.yMin),\n        r = b(t, e, s, o, {\n          soft: i.hardBounds,\n          hard: i.hardBounds\n        });\n      return o ? {\n        y: e.y,\n        x: t[r ? \"xMax\" : \"xMin\"] + (r ? 1 : -1)\n      } : {\n        x: e.x,\n        y: t[r ? \"yMax\" : \"yMin\"] + (r ? 1 : -1)\n      };\n    }(f[m], e, t), r.push({\n      end: e,\n      start: u\n    }), e = u); (m = c5(f, e)) > -1;) p = e[o] - t[o] < 0, (u = {\n      x: e.x,\n      y: e.y\n    })[o] = f[m][p ? o + \"Max\" : o + \"Min\"] + (p ? 1 : -1), r.push({\n      end: e,\n      start: u\n    }), e = u;\n    return {\n      path: c6(c = (c = function t(e, s, o) {\n        let r, n, c, p, u, m, x;\n        if (e.x === s.x && e.y === s.y) return [];\n        let v = o ? \"x\" : \"y\",\n          M = i.obstacleOptions.margin,\n          k = {\n            soft: {\n              xMin: a,\n              xMax: h,\n              yMin: l,\n              yMax: d\n            },\n            hard: i.hardBounds\n          };\n        return (u = c5(f, e)) > -1 ? (p = b(u = f[u], e, s, o, k), c9(u, i.hardBounds), x = o ? {\n          y: e.y,\n          x: u[p ? \"xMax\" : \"xMin\"] + (p ? 1 : -1)\n        } : {\n          x: e.x,\n          y: u[p ? \"yMax\" : \"yMin\"] + (p ? 1 : -1)\n        }, (m = c5(f, x)) > -1 && (c9(m = f[m], i.hardBounds), x[v] = p ? c1(u[v + \"Max\"] - M + 1, (m[v + \"Min\"] + u[v + \"Max\"]) / 2) : c0(u[v + \"Min\"] + M - 1, (m[v + \"Max\"] + u[v + \"Min\"]) / 2), e.x === x.x && e.y === x.y ? (g && (x[v] = p ? c1(u[v + \"Max\"], m[v + \"Max\"]) + 1 : c0(u[v + \"Min\"], m[v + \"Min\"]) - 1), g = !g) : g = !1), n = [{\n          start: e,\n          end: x\n        }]) : (r = y(e, {\n          x: o ? s.x : e.x,\n          y: o ? e.y : s.y\n        }, o), n = [{\n          start: e,\n          end: {\n            x: r.x,\n            y: r.y\n          }\n        }], r[o ? \"x\" : \"y\"] !== s[o ? \"x\" : \"y\"] && (p = b(r.obstacle, r, s, !o, k), c9(r.obstacle, i.hardBounds), c = {\n          x: o ? r.x : r.obstacle[p ? \"xMax\" : \"xMin\"] + (p ? 1 : -1),\n          y: o ? r.obstacle[p ? \"yMax\" : \"yMin\"] + (p ? 1 : -1) : r.y\n        }, o = !o, n = n.concat(t({\n          x: r.x,\n          y: r.y\n        }, c, o)))), n = n.concat(t(n[n.length - 1].end, s, !o));\n      }(t, e, s)).concat(r.reverse())),\n      obstacles: c\n    };\n  }\n  c4.requiresObstacles = !0, c8.requiresObstacles = !0;\n  let c7 = {\n      connectors: {\n        type: \"straight\",\n        radius: 0,\n        lineWidth: 1,\n        marker: {\n          enabled: !1,\n          align: \"center\",\n          verticalAlign: \"middle\",\n          inside: !1,\n          lineWidth: 1\n        },\n        startMarker: {\n          symbol: \"diamond\"\n        },\n        endMarker: {\n          symbol: \"arrow-filled\"\n        }\n      }\n    },\n    {\n      setOptions: pt\n    } = tS,\n    {\n      defined: pe,\n      error: pi,\n      merge: ps\n    } = tt;\n  function po(t) {\n    let e = t.shapeArgs;\n    if (e) return {\n      xMin: e.x || 0,\n      xMax: (e.x || 0) + (e.width || 0),\n      yMin: e.y || 0,\n      yMax: (e.y || 0) + (e.height || 0)\n    };\n    let i = t.graphic && t.graphic.getBBox();\n    return i ? {\n      xMin: t.plotX - i.width / 2,\n      xMax: t.plotX + i.width / 2,\n      yMin: t.plotY - i.height / 2,\n      yMax: t.plotY + i.height / 2\n    } : null;\n  }\n  !function (t) {\n    function e(t) {\n      let e, i;\n      let s = po(this);\n      switch (t.align) {\n        case \"right\":\n          e = \"xMax\";\n          break;\n        case \"left\":\n          e = \"xMin\";\n      }\n      switch (t.verticalAlign) {\n        case \"top\":\n          i = \"yMin\";\n          break;\n        case \"bottom\":\n          i = \"yMax\";\n      }\n      return {\n        x: e ? s[e] : (s.xMin + s.xMax) / 2,\n        y: i ? s[i] : (s.yMin + s.yMax) / 2\n      };\n    }\n    function i(t, e) {\n      let i;\n      return !pe(e) && (i = po(this)) && (e = {\n        x: (i.xMin + i.xMax) / 2,\n        y: (i.yMin + i.yMax) / 2\n      }), Math.atan2(e.y - t.y, t.x - e.x);\n    }\n    function s(t, e, i) {\n      let s = 2 * Math.PI,\n        o = po(this),\n        r = o.xMax - o.xMin,\n        n = o.yMax - o.yMin,\n        a = Math.atan2(n, r),\n        h = r / 2,\n        l = n / 2,\n        d = o.xMin + h,\n        c = o.yMin + l,\n        p = {\n          x: d,\n          y: c\n        },\n        u = t,\n        g = 1,\n        f = !1,\n        m = 1,\n        x = 1;\n      for (; u < -Math.PI;) u += s;\n      for (; u > Math.PI;) u -= s;\n      return g = Math.tan(u), u > -a && u <= a ? (x = -1, f = !0) : u > a && u <= Math.PI - a ? x = -1 : u > Math.PI - a || u <= -(Math.PI - a) ? (m = -1, f = !0) : m = -1, f ? (p.x += m * h, p.y += x * h * g) : (p.x += n / (2 * g) * m, p.y += x * l), i.x !== d && (p.x = i.x), i.y !== c && (p.y = i.y), {\n        x: p.x + e * Math.cos(u),\n        y: p.y - e * Math.sin(u)\n      };\n    }\n    t.compose = function (t, o, r) {\n      let n = r.prototype;\n      n.getPathfinderAnchorPoint || (t.prototype.callbacks.push(function (t) {\n        !1 !== t.options.connectors.enabled && ((t.options.pathfinder || t.series.reduce(function (t, e) {\n          return e.options && ps(!0, e.options.connectors = e.options.connectors || {}, e.options.pathfinder), t || e.options && e.options.pathfinder;\n        }, !1)) && (ps(!0, t.options.connectors = t.options.connectors || {}, t.options.pathfinder), pi('WARNING: Pathfinder options have been renamed. Use \"chart.connectors\" or \"series.connectors\" instead.')), this.pathfinder = new o(this), this.pathfinder.update(!0));\n      }), n.getMarkerVector = s, n.getPathfinderAnchorPoint = e, n.getRadiansToVector = i, pt(c7));\n    };\n  }(S || (S = {}));\n  let pr = S,\n    {\n      addEvent: pn,\n      defined: pa,\n      pick: ph,\n      splat: pl\n    } = tt,\n    pd = Math.max,\n    pc = Math.min;\n  class pp {\n    static compose(t, e) {\n      pr.compose(t, pp, e);\n    }\n    constructor(t) {\n      this.init(t);\n    }\n    init(t) {\n      this.chart = t, this.connections = [], pn(t, \"redraw\", function () {\n        this.pathfinder.update();\n      });\n    }\n    update(t) {\n      let e = this.chart,\n        i = this,\n        s = i.connections;\n      i.connections = [], e.series.forEach(function (t) {\n        t.visible && !t.options.isInternal && t.points.forEach(function (t) {\n          let s;\n          let o = t.options;\n          o && o.dependency && (o.connect = o.dependency);\n          let r = t.options?.connect ? pl(t.options.connect) : [];\n          t.visible && !1 !== t.isInside && r.forEach(o => {\n            let r = \"string\" == typeof o ? o : o.to;\n            r && (s = e.get(r)), s instanceof oq && s.series.visible && s.visible && !1 !== s.isInside && i.connections.push(new lH(t, s, \"string\" == typeof o ? {} : o));\n          });\n        });\n      });\n      for (let t = 0, e, o, r = s.length, n = i.connections.length; t < r; ++t) {\n        o = !1;\n        let r = s[t];\n        for (e = 0; e < n; ++e) {\n          let t = i.connections[e];\n          if ((r.options && r.options.type) === (t.options && t.options.type) && r.fromPoint === t.fromPoint && r.toPoint === t.toPoint) {\n            t.graphics = r.graphics, o = !0;\n            break;\n          }\n        }\n        o || r.destroy();\n      }\n      delete this.chartObstacles, delete this.lineObstacles, i.renderConnections(t);\n    }\n    renderConnections(t) {\n      t ? this.chart.series.forEach(function (t) {\n        let e = function () {\n          let e = t.chart.pathfinder;\n          (e && e.connections || []).forEach(function (e) {\n            e.fromPoint && e.fromPoint.series === t && e.render();\n          }), t.pathfinderRemoveRenderEvent && (t.pathfinderRemoveRenderEvent(), delete t.pathfinderRemoveRenderEvent);\n        };\n        !1 === t.options.animation ? e() : t.pathfinderRemoveRenderEvent = pn(t, \"afterAnimate\", e);\n      }) : this.connections.forEach(function (t) {\n        t.render();\n      });\n    }\n    getChartObstacles(t) {\n      let e = this.chart.series,\n        i = ph(t.algorithmMargin, 0),\n        s = [],\n        o;\n      for (let t = 0, o = e.length; t < o; ++t) if (e[t].visible && !e[t].options.isInternal) for (let o = 0, r = e[t].points.length, n, a; o < r; ++o) (a = e[t].points[o]).visible && (n = function (t) {\n        let e = t.shapeArgs;\n        if (e) return {\n          xMin: e.x || 0,\n          xMax: (e.x || 0) + (e.width || 0),\n          yMin: e.y || 0,\n          yMax: (e.y || 0) + (e.height || 0)\n        };\n        let i = t.graphic && t.graphic.getBBox();\n        return i ? {\n          xMin: t.plotX - i.width / 2,\n          xMax: t.plotX + i.width / 2,\n          yMin: t.plotY - i.height / 2,\n          yMax: t.plotY + i.height / 2\n        } : null;\n      }(a)) && s.push({\n        xMin: n.xMin - i,\n        xMax: n.xMax + i,\n        yMin: n.yMin - i,\n        yMax: n.yMax + i\n      });\n      return s = s.sort(function (t, e) {\n        return t.xMin - e.xMin;\n      }), pa(t.algorithmMargin) || (o = t.algorithmMargin = function (t) {\n        let e;\n        let i = t.length,\n          s = [];\n        for (let o = 0; o < i; ++o) for (let r = o + 1; r < i; ++r) (e = function t(e, i, s) {\n          let o = ph(s, 10),\n            r = e.yMax + o > i.yMin - o && e.yMin - o < i.yMax + o,\n            n = e.xMax + o > i.xMin - o && e.xMin - o < i.xMax + o,\n            a = r ? e.xMin > i.xMax ? e.xMin - i.xMax : i.xMin - e.xMax : 1 / 0,\n            h = n ? e.yMin > i.yMax ? e.yMin - i.yMax : i.yMin - e.yMax : 1 / 0;\n          return n && r ? o ? t(e, i, Math.floor(o / 2)) : 1 / 0 : pc(a, h);\n        }(t[o], t[r])) < 80 && s.push(e);\n        return s.push(80), pd(Math.floor(s.sort(function (t, e) {\n          return t - e;\n        })[Math.floor(s.length / 10)] / 2 - 1), 1);\n      }(s), s.forEach(function (t) {\n        t.xMin -= o, t.xMax += o, t.yMin -= o, t.yMax += o;\n      })), s;\n    }\n    getObstacleMetrics(t) {\n      let e = 0,\n        i = 0,\n        s,\n        o,\n        r = t.length;\n      for (; r--;) s = t[r].xMax - t[r].xMin, o = t[r].yMax - t[r].yMin, e < s && (e = s), i < o && (i = o);\n      return {\n        maxHeight: i,\n        maxWidth: e\n      };\n    }\n    getAlgorithmStartDirection(t) {\n      let e = \"left\" !== t.align && \"right\" !== t.align,\n        i = \"top\" !== t.verticalAlign && \"bottom\" !== t.verticalAlign;\n      return e ? !!i && void 0 : !!i || void 0;\n    }\n  }\n  pp.prototype.algorithms = {\n    fastAvoid: c8,\n    straight: function (t, e) {\n      return {\n        path: [[\"M\", t.x, t.y], [\"L\", e.x, e.y]],\n        obstacles: [{\n          start: t,\n          end: e\n        }]\n      };\n    },\n    simpleConnect: c4\n  }, O.Pathfinder = O.Pathfinder || pp, lB.compose(O.SVGRenderer), O.Pathfinder.compose(O.Chart, O.Point);\n  let {\n    addEvent: pu,\n    defined: pg,\n    isNumber: pf,\n    pick: pm\n  } = tt;\n  function px() {\n    let t = this.chart.options.chart;\n    !this.horiz && pf(this.options.staticScale) && (!t.height || t.scrollablePlotArea && t.scrollablePlotArea.minHeight) && (this.staticScale = this.options.staticScale);\n  }\n  function py() {\n    if (\"adjustHeight\" !== this.redrawTrigger) {\n      for (let t of this.axes || []) {\n        let e = t.chart,\n          i = !!e.initiatedScale && e.options.animation,\n          s = t.options.staticScale;\n        if (t.staticScale && pg(t.min)) {\n          let o = pm(t.brokenAxis && t.brokenAxis.unitLength, t.max + t.tickInterval - t.min) * s,\n            r = (o = Math.max(o, s)) - e.plotHeight;\n          !e.scrollablePixelsY && Math.abs(r) >= 1 && (e.plotHeight = o, e.redrawTrigger = \"adjustHeight\", e.setSize(void 0, e.chartHeight + r, i)), t.series.forEach(function (t) {\n            let i = t.sharedClipKey && e.sharedClips[t.sharedClipKey];\n            i && i.attr(e.inverted ? {\n              width: e.plotHeight\n            } : {\n              height: e.plotHeight\n            });\n          });\n        }\n      }\n      this.initiatedScale = !0;\n    }\n    this.redrawTrigger = null;\n  }\n  let pb = {\n    compose: function (t, e) {\n      let i = e.prototype;\n      i.adjustHeight || (pu(t, \"afterSetOptions\", px), i.adjustHeight = py, pu(e, \"render\", i.adjustHeight));\n    }\n  };\n  pb.compose(O.Axis, O.Chart);\n  let {\n      correctFloat: pv,\n      isNumber: pM,\n      isObject: pk\n    } = tt,\n    {\n      column: {\n        prototype: {\n          pointClass: pw\n        }\n      }\n    } = ry.seriesTypes,\n    {\n      extend: pS\n    } = tt;\n  class pA extends pw {\n    static getColorByCategory(t, e) {\n      let i = t.options.colors || t.chart.options.colors,\n        s = i ? i.length : t.chart.options.chart.colorCount,\n        o = e.y % s,\n        r = i && i[o];\n      return {\n        colorIndex: o,\n        color: r\n      };\n    }\n    resolveColor() {\n      let t = this.series;\n      if (t.options.colorByPoint && !this.options.color) {\n        let e = pA.getColorByCategory(t, this);\n        t.chart.styledMode || (this.color = e.color), this.options.colorIndex || (this.colorIndex = e.colorIndex);\n      } else this.color = this.options.color || t.color;\n    }\n    constructor(t, e) {\n      super(t, e), this.y || (this.y = 0);\n    }\n    applyOptions(t, e) {\n      return super.applyOptions(t, e), this.x2 = this.series.chart.time.parse(this.x2), this.isNull = !this.isValid?.(), this;\n    }\n    setState() {\n      super.setState.apply(this, arguments), this.series.drawPoint(this, this.series.getAnimationVerb());\n    }\n    isValid() {\n      return \"number\" == typeof this.x && \"number\" == typeof this.x2;\n    }\n  }\n  pS(pA.prototype, {\n    ttBelow: !1,\n    tooltipDateKeys: [\"x\", \"x2\"]\n  });\n  let {\n      composed: pT,\n      noop: pP\n    } = O,\n    {\n      parse: pC\n    } = tO,\n    {\n      column: pO\n    } = ry.seriesTypes,\n    {\n      addEvent: pE,\n      clamp: pL,\n      crisp: pB,\n      defined: pI,\n      extend: pD,\n      find: pR,\n      isNumber: pN,\n      isObject: pz,\n      merge: pW,\n      pick: pG,\n      pushUnique: pH,\n      relativeLength: pF\n    } = tt;\n  function pX() {\n    let t, e;\n    if (this.isXAxis) {\n      for (let i of (t = pG(this.dataMax, -Number.MAX_VALUE), this.series)) {\n        let s = i.dataTable.getColumn(\"x2\", !0) || i.dataTable.getColumn(\"end\", !0);\n        if (s) for (let i of s) pN(i) && i > t && (t = i, e = !0);\n      }\n      e && (this.dataMax = t);\n    }\n  }\n  class pY extends pO {\n    static compose(t) {\n      pH(pT, \"Series.XRange\") && pE(t, \"afterGetSeriesExtremes\", pX);\n    }\n    init() {\n      super.init.apply(this, arguments), this.options.stacking = void 0;\n    }\n    getColumnMetrics() {\n      let t = () => {\n        for (let t of this.chart.series) {\n          let e = t.xAxis;\n          t.xAxis = t.yAxis, t.yAxis = e;\n        }\n      };\n      t();\n      let e = super.getColumnMetrics();\n      return t(), e;\n    }\n    cropData(t, e, i) {\n      let s = t.getColumn(\"x\") || [],\n        o = t.getColumn(\"x2\");\n      t.setColumn(\"x\", o, void 0, {\n        silent: !0\n      });\n      let r = super.cropData(t, e, i);\n      return t.setColumn(\"x\", s.slice(r.start, r.end), void 0, {\n        silent: !0\n      }), r;\n    }\n    findPointIndex(t) {\n      let e;\n      let {\n          cropStart: i,\n          points: s\n        } = this,\n        {\n          id: o\n        } = t;\n      if (o) {\n        let t = pR(s, t => t.id === o);\n        e = t ? t.index : void 0;\n      }\n      if (void 0 === e) {\n        let i = pR(s, e => e.x === t.x && e.x2 === t.x2 && !e.touched);\n        e = i ? i.index : void 0;\n      }\n      return this.cropped && pN(e) && pN(i) && e >= i && (e -= i), e;\n    }\n    alignDataLabel(t) {\n      let e = t.plotX;\n      t.plotX = pG(t.dlBox && t.dlBox.centerX, t.plotX), t.dataLabel && t.shapeArgs?.width && t.dataLabel.css({\n        width: `${t.shapeArgs.width}px`\n      }), super.alignDataLabel.apply(this, arguments), t.plotX = e;\n    }\n    translatePoint(t) {\n      let e = this.xAxis,\n        i = this.yAxis,\n        s = this.columnMetrics,\n        o = this.options,\n        r = o.minPointLength || 0,\n        n = (t.shapeArgs && t.shapeArgs.width || 0) / 2,\n        a = this.pointXOffset = s.offset,\n        h = pG(t.x2, t.x + (t.len || 0)),\n        l = o.borderRadius,\n        d = this.chart.plotTop,\n        c = this.chart.plotLeft,\n        p = t.plotX,\n        u = e.translate(h, 0, 0, 0, 1),\n        g = Math.abs(u - p),\n        f = this.chart.inverted,\n        m = pG(o.borderWidth, 1),\n        x,\n        y,\n        b = s.offset,\n        v = Math.round(s.width),\n        M,\n        k,\n        w,\n        S;\n      r && ((x = r - g) < 0 && (x = 0), p -= x / 2, u += x / 2), p = Math.max(p, -10), u = pL(u, -10, e.len + 10), pI(t.options.pointWidth) && (b -= (Math.ceil(t.options.pointWidth) - v) / 2, v = Math.ceil(t.options.pointWidth)), o.pointPlacement && pN(t.plotY) && i.categories && (t.plotY = i.translate(t.y, 0, 1, 0, 1, o.pointPlacement));\n      let A = pB(Math.min(p, u), m),\n        T = pB(Math.max(p, u), m) - A,\n        P = Math.min(pF(\"object\" == typeof l ? l.radius : l || 0, v), Math.min(T, v) / 2),\n        C = {\n          x: A,\n          y: pB((t.plotY || 0) + b, m),\n          width: T,\n          height: v,\n          r: P\n        };\n      t.shapeArgs = C, f ? t.tooltipPos[1] += a + n : t.tooltipPos[0] -= n + a - C.width / 2, k = (M = C.x) + C.width, M < 0 || k > e.len ? (M = pL(M, 0, e.len), w = (k = pL(k, 0, e.len)) - M, t.dlBox = pW(C, {\n        x: M,\n        width: k - M,\n        centerX: w ? w / 2 : null\n      })) : t.dlBox = null;\n      let O = t.tooltipPos,\n        E = f ? 1 : 0,\n        L = f ? 0 : 1,\n        B = this.columnMetrics ? this.columnMetrics.offset : -s.width / 2;\n      f ? O[E] += C.width / 2 : O[E] = pL(O[E] + (e.reversed ? -1 : 0) * C.width, e.left - c, e.left + e.len - c - 1), O[L] = pL(O[L] + (f ? -1 : 1) * B, i.top - d, i.top + i.len - d - 1), (y = t.partialFill) && (pz(y) && (y = y.amount), pN(y) || (y = 0), t.partShapeArgs = pW(C), S = Math.max(Math.round(g * y + t.plotX - p), 0), t.clipRectArgs = {\n        x: e.reversed ? C.x + g - S : C.x,\n        y: C.y,\n        width: S,\n        height: C.height\n      }), t.key = t.category || t.name, t.yCategory = i.categories?.[t.y ?? -1];\n    }\n    translate() {\n      for (let t of (super.translate.apply(this, arguments), this.points)) this.translatePoint(t);\n    }\n    drawPoint(t, e) {\n      let i = this.options,\n        s = this.chart.renderer,\n        o = t.shapeType,\n        r = t.shapeArgs,\n        n = t.partShapeArgs,\n        a = t.clipRectArgs,\n        h = t.state,\n        l = i.states[h || \"normal\"] || {},\n        d = void 0 === h ? \"attr\" : e,\n        c = this.pointAttribs(t, h),\n        p = pG(this.chart.options.chart.animation, l.animation),\n        u = t.graphic,\n        g = t.partialFill;\n      if (t.isNull || !1 === t.visible) u && (t.graphic = u.destroy());else if (u ? u.rect[e](r) : (t.graphic = u = s.g(\"point\").addClass(t.getClassName()).add(t.group || this.group), u.rect = s[o](pW(r)).addClass(t.getClassName()).addClass(\"highcharts-partfill-original\").add(u)), n && (u.partRect ? (u.partRect[e](pW(n)), u.partialClipRect[e](pW(a))) : (u.partialClipRect = s.clipRect(a.x, a.y, a.width, a.height), u.partRect = s[o](n).addClass(\"highcharts-partfill-overlay\").add(u).clip(u.partialClipRect))), !this.chart.styledMode && (u.rect[e](c, p).shadow(i.shadow), n)) {\n        pz(g) || (g = {}), pz(i.partialFill) && (g = pW(i.partialFill, g));\n        let e = g.fill || pC(c.fill).brighten(-.3).get() || pC(t.color || this.color).brighten(-.3).get();\n        c.fill = e, u.partRect[d](c, p).shadow(i.shadow);\n      }\n    }\n    drawPoints() {\n      let t = this.getAnimationVerb();\n      for (let e of this.points) this.drawPoint(e, t);\n    }\n    getAnimationVerb() {\n      return this.chart.pointCount < (this.options.animationLimit || 250) ? \"animate\" : \"attr\";\n    }\n    isPointInside(t) {\n      let e = t.shapeArgs,\n        i = t.plotX,\n        s = t.plotY;\n      return e ? void 0 !== i && void 0 !== s && s >= 0 && s <= this.yAxis.len && (e.x || 0) + (e.width || 0) >= 0 && i <= this.xAxis.len : super.isPointInside.apply(this, arguments);\n    }\n  }\n  pY.defaultOptions = pW(pO.defaultOptions, {\n    colorByPoint: !0,\n    dataLabels: {\n      formatter: function () {\n        let t = this.partialFill;\n        if (pk(t) && (t = t.amount), pM(t) && t > 0) return pv(100 * t) + \"%\";\n      },\n      inside: !0,\n      verticalAlign: \"middle\",\n      style: {\n        whiteSpace: \"nowrap\"\n      }\n    },\n    tooltip: {\n      headerFormat: '<span style=\"font-size: 0.8em\">{ucfirst point.x} - {point.x2}</span><br/>',\n      pointFormat: '<span style=\"color:{point.color}\">●</span> {series.name}: <b>{point.yCategory}</b><br/>'\n    },\n    borderRadius: 3,\n    pointRange: 0\n  }), pD(pY.prototype, {\n    pointClass: pA,\n    pointArrayMap: [\"x2\", \"y\"],\n    getExtremesFromAll: !0,\n    keysAffectYAxis: [\"y\"],\n    parallelArrays: [\"x\", \"x2\", \"y\"],\n    requireSorting: !1,\n    type: \"xrange\",\n    animate: ry.series.prototype.animate,\n    autoIncrement: pP,\n    buildKDTree: pP\n  }), ry.registerSeriesType(\"xrange\", pY), pY.compose(O.Axis);\n  let {\n    xrange: {\n      prototype: {\n        pointClass: pj\n      }\n    }\n  } = ry.seriesTypes;\n  class pU extends pj {\n    static setGanttPointAliases(t, e) {\n      t.x = t.start = e.time.parse(t.start ?? t.x), t.x2 = t.end = e.time.parse(t.end ?? t.x2), t.partialFill = t.completed = t.completed ?? t.partialFill;\n    }\n    applyOptions(t, e) {\n      let i = super.applyOptions(t, e);\n      return pU.setGanttPointAliases(i, i.series.chart), this.isNull = !this.isValid?.(), i;\n    }\n    isValid() {\n      return (\"number\" == typeof this.start || \"number\" == typeof this.x) && (\"number\" == typeof this.end || \"number\" == typeof this.x2 || this.milestone);\n    }\n  }\n  let {\n      isNumber: pV\n    } = tt,\n    {\n      addEvent: p$,\n      find: p_,\n      fireEvent: pq,\n      isArray: pZ,\n      isNumber: pK,\n      pick: pJ\n    } = tt;\n  !function (t) {\n    function e() {\n      void 0 !== this.brokenAxis && this.brokenAxis.setBreaks(this.options.breaks, !1);\n    }\n    function i() {\n      this.brokenAxis?.hasBreaks && (this.options.ordinal = !1);\n    }\n    function s() {\n      let t = this.brokenAxis;\n      if (t?.hasBreaks) {\n        let e = this.tickPositions,\n          i = this.tickPositions.info,\n          s = [];\n        for (let i = 0; i < e.length; i++) t.isInAnyBreak(e[i]) || s.push(e[i]);\n        this.tickPositions = s, this.tickPositions.info = i;\n      }\n    }\n    function o() {\n      this.brokenAxis || (this.brokenAxis = new l(this));\n    }\n    function r() {\n      let {\n        isDirty: t,\n        options: {\n          connectNulls: e\n        },\n        points: i,\n        xAxis: s,\n        yAxis: o\n      } = this;\n      if (t) {\n        let t = i.length;\n        for (; t--;) {\n          let r = i[t],\n            n = !(null === r.y && !1 === e) && (s?.brokenAxis?.isInAnyBreak(r.x, !0) || o?.brokenAxis?.isInAnyBreak(r.y, !0));\n          r.visible = !n && !1 !== r.options.visible;\n        }\n      }\n    }\n    function n() {\n      this.drawBreaks(this.xAxis, [\"x\"]), this.drawBreaks(this.yAxis, pJ(this.pointArrayMap, [\"y\"]));\n    }\n    function a(t, e) {\n      let i, s, o;\n      let r = this,\n        n = r.points;\n      if (t?.brokenAxis?.hasBreaks) {\n        let a = t.brokenAxis;\n        e.forEach(function (e) {\n          i = a?.breakArray || [], s = t.isXAxis ? t.min : pJ(r.options.threshold, t.min);\n          let h = t?.options?.breaks?.filter(function (t) {\n            let e = !0;\n            for (let s = 0; s < i.length; s++) {\n              let o = i[s];\n              if (o.from === t.from && o.to === t.to) {\n                e = !1;\n                break;\n              }\n            }\n            return e;\n          });\n          n.forEach(function (r) {\n            o = pJ(r[\"stack\" + e.toUpperCase()], r[e]), i.forEach(function (e) {\n              if (pK(s) && pK(o)) {\n                let i = \"\";\n                s < e.from && o > e.to || s > e.from && o < e.from ? i = \"pointBreak\" : (s < e.from && o > e.from && o < e.to || s > e.from && o > e.to && o < e.from) && (i = \"pointInBreak\"), i && pq(t, i, {\n                  point: r,\n                  brk: e\n                });\n              }\n            }), h?.forEach(function (e) {\n              pq(t, \"pointOutsideOfBreak\", {\n                point: r,\n                brk: e\n              });\n            });\n          });\n        });\n      }\n    }\n    function h() {\n      let t = this.currentDataGrouping,\n        e = t?.gapSize,\n        i = this.points.slice(),\n        s = this.yAxis,\n        o = this.options.gapSize,\n        r = i.length - 1;\n      if (o && r > 0) {\n        let t, n;\n        for (\"value\" !== this.options.gapUnit && (o *= this.basePointRange), e && e > o && e >= this.basePointRange && (o = e); r--;) if (n && !1 !== n.visible || (n = i[r + 1]), t = i[r], !1 !== n.visible && !1 !== t.visible) {\n          if (n.x - t.x > o) {\n            let e = (t.x + n.x) / 2;\n            i.splice(r + 1, 0, {\n              isNull: !0,\n              x: e\n            }), s.stacking && this.options.stacking && ((s.stacking.stacks[this.stackKey][e] = new aa(s, s.options.stackLabels, !1, e, this.stack)).total = 0);\n          }\n          n = t;\n        }\n      }\n      return this.getGraphPath(i);\n    }\n    t.compose = function (t, l) {\n      if (!t.keepProps.includes(\"brokenAxis\")) {\n        t.keepProps.push(\"brokenAxis\"), p$(t, \"init\", o), p$(t, \"afterInit\", e), p$(t, \"afterSetTickPositions\", s), p$(t, \"afterSetOptions\", i);\n        let d = l.prototype;\n        d.drawBreaks = a, d.gappedPath = h, p$(l, \"afterGeneratePoints\", r), p$(l, \"afterRender\", n);\n      }\n      return t;\n    };\n    class l {\n      static isInBreak(t, e) {\n        let i = t.repeat || 1 / 0,\n          s = t.from,\n          o = t.to - t.from,\n          r = e >= s ? (e - s) % i : i - (s - e) % i;\n        return t.inclusive ? r <= o : r < o && 0 !== r;\n      }\n      static lin2Val(t) {\n        let e = this.brokenAxis,\n          i = e && e.breakArray;\n        if (!i || !pK(t)) return t;\n        let s = t,\n          o,\n          r;\n        for (r = 0; r < i.length && !((o = i[r]).from >= s); r++) o.to < s ? s += o.len : l.isInBreak(o, s) && (s += o.len);\n        return s;\n      }\n      static val2Lin(t) {\n        let e = this.brokenAxis,\n          i = e && e.breakArray;\n        if (!i || !pK(t)) return t;\n        let s = t,\n          o,\n          r;\n        for (r = 0; r < i.length; r++) if ((o = i[r]).to <= t) s -= o.len;else if (o.from >= t) break;else if (l.isInBreak(o, t)) {\n          s -= t - o.from;\n          break;\n        }\n        return s;\n      }\n      constructor(t) {\n        this.hasBreaks = !1, this.axis = t;\n      }\n      findBreakAt(t, e) {\n        return p_(e, function (e) {\n          return e.from < t && t < e.to;\n        });\n      }\n      isInAnyBreak(t, e) {\n        let i = this.axis,\n          s = i.options.breaks || [],\n          o = s.length,\n          r,\n          n,\n          a;\n        if (o && pK(t)) {\n          for (; o--;) l.isInBreak(s[o], t) && (r = !0, n || (n = pJ(s[o].showPoints, !i.isXAxis)));\n          a = r && e ? r && !n : r;\n        }\n        return a;\n      }\n      setBreaks(t, e) {\n        let i = this,\n          s = i.axis,\n          o = s.chart.time,\n          r = pZ(t) && !!t.length && !!Object.keys(t[0]).length;\n        s.isDirty = i.hasBreaks !== r, i.hasBreaks = r, t?.forEach(t => {\n          t.from = o.parse(t.from) || 0, t.to = o.parse(t.to) || 0;\n        }), t !== s.options.breaks && (s.options.breaks = s.userOptions.breaks = t), s.forceRedraw = !0, s.series.forEach(function (t) {\n          t.isDirty = !0;\n        }), r || s.val2lin !== l.val2Lin || (delete s.val2lin, delete s.lin2val), r && (s.userOptions.ordinal = !1, s.lin2val = l.lin2Val, s.val2lin = l.val2Lin, s.setExtremes = function (t, e, o, r, n) {\n          if (i.hasBreaks) {\n            let s;\n            let o = this.options.breaks || [];\n            for (; s = i.findBreakAt(t, o);) t = s.to;\n            for (; s = i.findBreakAt(e, o);) e = s.from;\n            e < t && (e = t);\n          }\n          s.constructor.prototype.setExtremes.call(this, t, e, o, r, n);\n        }, s.setAxisTranslation = function () {\n          if (s.constructor.prototype.setAxisTranslation.call(this), i.unitLength = void 0, i.hasBreaks) {\n            let t = s.options.breaks || [],\n              e = [],\n              o = [],\n              r = pJ(s.pointRangePadding, 0),\n              n = 0,\n              a,\n              h,\n              d = s.userMin || s.min,\n              c = s.userMax || s.max,\n              p,\n              u;\n            t.forEach(function (t) {\n              h = t.repeat || 1 / 0, pK(d) && pK(c) && (l.isInBreak(t, d) && (d += t.to % h - d % h), l.isInBreak(t, c) && (c -= c % h - t.from % h));\n            }), t.forEach(function (t) {\n              if (p = t.from, h = t.repeat || 1 / 0, pK(d) && pK(c)) {\n                for (; p - h > d;) p -= h;\n                for (; p < d;) p += h;\n                for (u = p; u < c; u += h) e.push({\n                  value: u,\n                  move: \"in\"\n                }), e.push({\n                  value: u + t.to - t.from,\n                  move: \"out\",\n                  size: t.breakSize\n                });\n              }\n            }), e.sort(function (t, e) {\n              return t.value === e.value ? (\"in\" === t.move ? 0 : 1) - (\"in\" === e.move ? 0 : 1) : t.value - e.value;\n            }), a = 0, p = d, e.forEach(function (t) {\n              1 === (a += \"in\" === t.move ? 1 : -1) && \"in\" === t.move && (p = t.value), 0 === a && pK(p) && (o.push({\n                from: p,\n                to: t.value,\n                len: t.value - p - (t.size || 0)\n              }), n += t.value - p - (t.size || 0));\n            }), i.breakArray = o, pK(d) && pK(c) && pK(s.min) && (i.unitLength = c - d - n + r, pq(s, \"afterBreaks\"), s.staticScale ? s.transA = s.staticScale : i.unitLength && (s.transA *= (c - s.min + r) / i.unitLength), r && (s.minPixelPadding = s.transA * (s.minPointOffset || 0)), s.min = d, s.max = c);\n          }\n        }), pJ(e, !0) && s.chart.redraw();\n      }\n    }\n    t.Additions = l;\n  }(A || (A = {}));\n  let pQ = A,\n    {\n      dateFormats: p0\n    } = O,\n    {\n      addEvent: p1,\n      defined: p2,\n      erase: p3,\n      find: p5,\n      isArray: p6,\n      isNumber: p9,\n      merge: p4,\n      pick: p8,\n      timeUnits: p7,\n      wrap: ut\n    } = tt;\n  function ue(t) {\n    return tt.isObject(t, !0);\n  }\n  function ui(t, e) {\n    let i = {\n      width: 0,\n      height: 0\n    };\n    if (e.forEach(function (e) {\n      let s = t[e],\n        o = 0,\n        r = 0,\n        n;\n      ue(s) && (o = (n = ue(s.label) ? s.label : {}).getBBox ? n.getBBox().height : 0, n.textStr && !p9(n.textPxLength) && (n.textPxLength = n.getBBox().width), r = p9(n.textPxLength) ? Math.round(n.textPxLength) : 0, n.textStr && (r = Math.round(n.getBBox().width)), i.height = Math.max(o, i.height), i.width = Math.max(r, i.width));\n    }), \"treegrid\" === this.type && this.treeGrid && this.treeGrid.mapOfPosToGridNode) {\n      let t = this.treeGrid.mapOfPosToGridNode[-1].height || 0;\n      i.width += this.options.labels.indentation * (t - 1);\n    }\n    return i;\n  }\n  function us(t) {\n    let {\n        grid: e\n      } = this,\n      i = 3 === this.side;\n    if (i || t.apply(this), !e?.isColumn) {\n      let t = e?.columns || [];\n      i && (t = t.slice().reverse()), t.forEach(t => {\n        t.getOffset();\n      });\n    }\n    i && t.apply(this);\n  }\n  function uo(t) {\n    if (!0 === (this.options.grid || {}).enabled) {\n      let {\n          axisTitle: e,\n          height: i,\n          horiz: s,\n          left: o,\n          offset: r,\n          opposite: n,\n          options: a,\n          top: h,\n          width: l\n        } = this,\n        d = this.tickSize(),\n        c = e && e.getBBox().width,\n        p = a.title.x,\n        u = a.title.y,\n        g = p8(a.title.margin, s ? 5 : 10),\n        f = e ? this.chart.renderer.fontMetrics(e).f : 0,\n        m = (s ? h + i : o) + (s ? 1 : -1) * (n ? -1 : 1) * (d ? d[0] / 2 : 0) + (this.side === T.bottom ? f : 0);\n      t.titlePosition.x = s ? o - (c || 0) / 2 - g + p : m + (n ? l : 0) + r + p, t.titlePosition.y = s ? m - (n ? i : 0) + (n ? f : -f) / 2 + r + u : h - g + u;\n    }\n  }\n  function ur() {\n    let {\n      chart: t,\n      options: {\n        grid: e = {}\n      },\n      userOptions: i\n    } = this;\n    if (e.enabled && function (t) {\n      let e = t.options;\n      e.labels.align = p8(e.labels.align, \"center\"), t.categories || (e.showLastLabel = !1), t.labelRotation = 0, e.labels.rotation = 0, e.minTickInterval = 1;\n    }(this), e.columns) {\n      let s = this.grid.columns = [],\n        o = this.grid.columnIndex = 0;\n      for (; ++o < e.columns.length;) {\n        let r = p4(i, e.columns[o], {\n            isInternal: !0,\n            linkedTo: 0,\n            scrollbar: {\n              enabled: !1\n            }\n          }, {\n            grid: {\n              columns: void 0\n            }\n          }),\n          n = new sU(this.chart, r, \"yAxis\");\n        n.grid.isColumn = !0, n.grid.columnIndex = o, p3(t.axes, n), p3(t[this.coll] || [], n), s.push(n);\n      }\n    }\n  }\n  function un() {\n    let {\n      axisTitle: t,\n      grid: e,\n      options: i\n    } = this;\n    if (!0 === (i.grid || {}).enabled) {\n      let s = this.min || 0,\n        o = this.max || 0,\n        r = this.ticks[this.tickPositions[0]];\n      if (t && !this.chart.styledMode && r?.slotWidth && !this.options.title.style.width && t.css({\n        width: `${r.slotWidth}px`\n      }), this.maxLabelDimensions = this.getMaxLabelDimensions(this.ticks, this.tickPositions), this.rightWall && this.rightWall.destroy(), this.grid && this.grid.isOuterAxis() && this.axisLine) {\n        let t = i.lineWidth;\n        if (t) {\n          let e = this.getLinePath(t),\n            r = e[0],\n            n = e[1],\n            a = (this.tickSize(\"tick\") || [1])[0] * (this.side === T.top || this.side === T.left ? -1 : 1);\n          if (\"M\" === r[0] && \"L\" === n[0] && (this.horiz ? (r[2] += a, n[2] += a) : (r[1] += a, n[1] += a)), !this.horiz && this.chart.marginRight) {\n            let t = [\"L\", this.left, r[2] || 0],\n              e = [r, t],\n              a = [\"L\", this.chart.chartWidth - this.chart.marginRight, this.toPixels(o + this.tickmarkOffset)],\n              h = [[\"M\", n[1] || 0, this.toPixels(o + this.tickmarkOffset)], a];\n            this.grid.upperBorder || s % 1 == 0 || (this.grid.upperBorder = this.grid.renderBorder(e)), this.grid.upperBorder && (this.grid.upperBorder.attr({\n              stroke: i.lineColor,\n              \"stroke-width\": i.lineWidth\n            }), this.grid.upperBorder.animate({\n              d: e\n            })), this.grid.lowerBorder || o % 1 == 0 || (this.grid.lowerBorder = this.grid.renderBorder(h)), this.grid.lowerBorder && (this.grid.lowerBorder.attr({\n              stroke: i.lineColor,\n              \"stroke-width\": i.lineWidth\n            }), this.grid.lowerBorder.animate({\n              d: h\n            }));\n          }\n          this.grid.axisLineExtra ? (this.grid.axisLineExtra.attr({\n            stroke: i.lineColor,\n            \"stroke-width\": i.lineWidth\n          }), this.grid.axisLineExtra.animate({\n            d: e\n          })) : this.grid.axisLineExtra = this.grid.renderBorder(e), this.axisLine[this.showAxis ? \"show\" : \"hide\"]();\n        }\n      }\n      if ((e && e.columns || []).forEach(t => t.render()), !this.horiz && this.chart.hasRendered && (this.scrollbar || this.linkedParent && this.linkedParent.scrollbar) && this.tickPositions.length) {\n        let t, e;\n        let i = this.tickmarkOffset,\n          r = this.tickPositions[this.tickPositions.length - 1],\n          n = this.tickPositions[0];\n        for (; (t = this.hiddenLabels.pop()) && t.element;) t.show();\n        for (; (e = this.hiddenMarks.pop()) && e.element;) e.show();\n        (t = this.ticks[n].label) && (s - n > i ? this.hiddenLabels.push(t.hide()) : t.show()), (t = this.ticks[r].label) && (r - o > i ? this.hiddenLabels.push(t.hide()) : t.show());\n        let a = this.ticks[r].mark;\n        a && r - o < i && r - o > 0 && this.ticks[r].isLast && this.hiddenMarks.push(a.hide());\n      }\n    }\n  }\n  function ua() {\n    let t = this.tickPositions && this.tickPositions.info,\n      e = this.options,\n      i = e.grid || {},\n      s = this.userOptions.labels || {};\n    i.enabled && (this.horiz ? (this.series.forEach(t => {\n      t.options.pointRange = 0;\n    }), t && e.dateTimeLabelFormats && e.labels && !p2(s.align) && (!1 === e.dateTimeLabelFormats[t.unitName].range || t.count > 1) && (e.labels.align = \"left\", p2(s.x) || (e.labels.x = 3))) : \"treegrid\" !== this.type && this.grid && this.grid.columns && (this.minPointOffset = this.tickInterval));\n  }\n  function uh(t) {\n    let e;\n    let i = this.options,\n      s = t.userOptions,\n      o = i && ue(i.grid) ? i.grid : {};\n    !0 === o.enabled && (e = p4(!0, {\n      className: \"highcharts-grid-axis \" + (s.className || \"\"),\n      dateTimeLabelFormats: {\n        hour: {\n          list: [\"%[HM]\", \"%[H]\"]\n        },\n        day: {\n          list: [\"%[AeB]\", \"%[aeb]\", \"%[E]\"]\n        },\n        week: {\n          list: [\"Week %W\", \"W%W\"]\n        },\n        month: {\n          list: [\"%[B]\", \"%[b]\", \"%o\"]\n        }\n      },\n      grid: {\n        borderWidth: 1\n      },\n      labels: {\n        padding: 2,\n        style: {\n          fontSize: \"0.9em\"\n        }\n      },\n      margin: 0,\n      title: {\n        text: null,\n        reserveSpace: !1,\n        rotation: 0,\n        style: {\n          textOverflow: \"ellipsis\"\n        }\n      },\n      units: [[\"millisecond\", [1, 10, 100]], [\"second\", [1, 10]], [\"minute\", [1, 5, 15]], [\"hour\", [1, 6]], [\"day\", [1]], [\"week\", [1]], [\"month\", [1]], [\"year\", null]]\n    }, s), \"xAxis\" !== this.coll || (p2(s.linkedTo) && !p2(s.tickPixelInterval) && (e.tickPixelInterval = 350), !(!p2(s.tickPixelInterval) && p2(s.linkedTo)) || p2(s.tickPositioner) || p2(s.tickInterval) || p2(s.units) || (e.tickPositioner = function (t, i) {\n      let s = this.linkedParent && this.linkedParent.tickPositions && this.linkedParent.tickPositions.info;\n      if (s) {\n        let o = e.units || [],\n          r,\n          n = 1,\n          a = \"year\";\n        for (let t = 0; t < o.length; t++) {\n          let e = o[t];\n          if (e && e[0] === s.unitName) {\n            r = t;\n            break;\n          }\n        }\n        let h = p9(r) && o[r + 1];\n        if (h) {\n          a = h[0] || \"year\";\n          let t = h[1];\n          n = t && t[0] || 1;\n        } else \"year\" === s.unitName && (n = 10 * s.count);\n        let l = p7[a];\n        return this.tickInterval = l * n, this.chart.time.getTimeTicks({\n          unitRange: l,\n          count: n,\n          unitName: a\n        }, t, i, this.options.startOfWeek);\n      }\n    })), p4(!0, this.options, e), this.horiz && (i.minPadding = p8(s.minPadding, 0), i.maxPadding = p8(s.maxPadding, 0)), p9(i.grid.borderWidth) && (i.tickWidth = i.lineWidth = o.borderWidth));\n  }\n  function ul(t) {\n    let e = t.userOptions,\n      i = e && e.grid || {},\n      s = i.columns;\n    i.enabled && s && p4(!0, this.options, s[0]);\n  }\n  function ud() {\n    (this.grid.columns || []).forEach(t => t.setScale());\n  }\n  function uc(t) {\n    let {\n      horiz: e,\n      maxLabelDimensions: i,\n      options: {\n        grid: s = {}\n      }\n    } = this;\n    if (s.enabled && i) {\n      let o = 2 * this.options.labels.distance,\n        r = e ? s.cellHeight || o + i.height : o + i.width;\n      p6(t.tickSize) ? t.tickSize[0] = r : t.tickSize = [r, 0];\n    }\n  }\n  function up() {\n    this.axes.forEach(t => {\n      (t.grid && t.grid.columns || []).forEach(t => {\n        t.setAxisSize(), t.setAxisTranslation();\n      });\n    });\n  }\n  function uu(t) {\n    let {\n      grid: e\n    } = this;\n    (e.columns || []).forEach(e => e.destroy(t.keepEvents)), e.columns = void 0;\n  }\n  function ug(t) {\n    let e = t.userOptions || {},\n      i = e.grid || {};\n    i.enabled && p2(i.borderColor) && (e.tickColor = e.lineColor = i.borderColor), this.grid || (this.grid = new ub(this)), this.hiddenLabels = [], this.hiddenMarks = [];\n  }\n  function uf(t) {\n    let e = this.label,\n      i = this.axis,\n      s = i.reversed,\n      o = i.chart,\n      r = i.options.grid || {},\n      n = i.options.labels,\n      a = n.align,\n      h = T[i.side],\n      l = t.tickmarkOffset,\n      d = i.tickPositions,\n      c = this.pos - l,\n      p = p9(d[t.index + 1]) ? d[t.index + 1] - l : (i.max || 0) + l,\n      u = i.tickSize(\"tick\"),\n      g = u ? u[0] : 0,\n      f = u ? u[1] / 2 : 0;\n    if (!0 === r.enabled) {\n      let r, l, d, u;\n      if (\"top\" === h ? l = (r = i.top + i.offset) - g : \"bottom\" === h ? r = (l = o.chartHeight - i.bottom + i.offset) + g : (r = i.top + i.len - (i.translate(s ? p : c) || 0), l = i.top + i.len - (i.translate(s ? c : p) || 0)), \"right\" === h ? u = (d = o.chartWidth - i.right + i.offset) + g : \"left\" === h ? d = (u = i.left + i.offset) - g : (d = Math.round(i.left + (i.translate(s ? p : c) || 0)) - f, u = Math.min(Math.round(i.left + (i.translate(s ? c : p) || 0)) - f, i.left + i.len)), this.slotWidth = u - d, t.pos.x = \"left\" === a ? d : \"right\" === a ? u : d + (u - d) / 2, t.pos.y = l + (r - l) / 2, e) {\n        let i = o.renderer.fontMetrics(e),\n          s = e.getBBox().height;\n        if (n.useHTML) t.pos.y += i.b + -(s / 2);else {\n          let e = Math.round(s / i.h);\n          t.pos.y += (i.b - (i.h - i.f)) / 2 + -((e - 1) * i.h / 2);\n        }\n      }\n      t.pos.x += i.horiz && n.x || 0;\n    }\n  }\n  function um(t) {\n    let {\n      axis: e,\n      value: i\n    } = t;\n    if (e.options.grid && e.options.grid.enabled) {\n      let s;\n      let o = e.tickPositions,\n        r = (e.linkedParent || e).series[0],\n        n = i === o[0],\n        a = i === o[o.length - 1],\n        h = r && p5(r.options.data, function (t) {\n          return t[e.isXAxis ? \"x\" : \"y\"] === i;\n        });\n      h && r.is(\"gantt\") && (s = p4(h), O.seriesTypes.gantt.prototype.pointClass.setGanttPointAliases(s, e.chart)), t.isFirst = n, t.isLast = a, t.point = s;\n    }\n  }\n  function ux() {\n    let t = this.options,\n      e = t.grid || {},\n      i = this.categories,\n      s = this.tickPositions,\n      o = s[0],\n      r = s[1],\n      n = s[s.length - 1],\n      a = s[s.length - 2],\n      h = this.linkedParent && this.linkedParent.min,\n      l = this.linkedParent && this.linkedParent.max,\n      d = h || this.min,\n      c = l || this.max,\n      p = this.tickInterval,\n      u = p9(d) && d >= o + p && d < r,\n      g = p9(d) && o < d && o + p > d,\n      f = p9(c) && n > c && n - p < c,\n      m = p9(c) && c <= n - p && c > a;\n    !0 === e.enabled && !i && (this.isXAxis || this.isLinked) && ((g || u) && !t.startOnTick && (s[0] = d), (f || m) && !t.endOnTick && (s[s.length - 1] = c));\n  }\n  function uy(t) {\n    var e;\n    let {\n      options: {\n        grid: i = {}\n      }\n    } = this;\n    return !0 === i.enabled && this.categories ? this.tickInterval : t.apply(this, (e = arguments, Array.prototype.slice.call(e, 1)));\n  }\n  !function (t) {\n    t[t.top = 0] = \"top\", t[t.right = 1] = \"right\", t[t.bottom = 2] = \"bottom\", t[t.left = 3] = \"left\";\n  }(T || (T = {}));\n  class ub {\n    constructor(t) {\n      this.axis = t;\n    }\n    isOuterAxis() {\n      let t = this.axis,\n        e = t.chart,\n        i = t.grid.columnIndex,\n        s = t.linkedParent?.grid.columns || t.grid.columns || [],\n        o = i ? t.linkedParent : t,\n        r = -1,\n        n = 0;\n      return 3 === t.side && !e.inverted && s.length ? !t.linkedParent : ((e[t.coll] || []).forEach((e, i) => {\n        e.side !== t.side || e.options.isInternal || (n = i, e !== o || (r = i));\n      }), n === r && (!p9(i) || s.length === i));\n    }\n    renderBorder(t) {\n      let e = this.axis,\n        i = e.chart.renderer,\n        s = e.options,\n        o = i.path(t).addClass(\"highcharts-axis-line\").add(e.axisGroup);\n      return i.styledMode || o.attr({\n        stroke: s.lineColor,\n        \"stroke-width\": s.lineWidth,\n        zIndex: 7\n      }), o;\n    }\n  }\n  p0.E = function (t) {\n    return this.dateFormat(\"%a\", t, !0).charAt(0);\n  }, p0.W = function (t) {\n    let e = this.toParts(t),\n      i = (e[7] + 6) % 7,\n      s = e.slice(0);\n    s[2] = e[2] - i + 3;\n    let o = this.toParts(this.makeTime(s[0], 0, 1));\n    return 4 !== o[7] && (e[1] = 0, e[2] = 1 + (11 - o[7]) % 7), (1 + Math.floor((this.makeTime(s[0], s[1], s[2]) - this.makeTime(o[0], o[1], o[2])) / 6048e5)).toString();\n  };\n  let uv = {\n      compose: function (t, e, i) {\n        return t.keepProps.includes(\"grid\") || (t.keepProps.push(\"grid\"), t.prototype.getMaxLabelDimensions = ui, ut(t.prototype, \"unsquish\", uy), ut(t.prototype, \"getOffset\", us), p1(t, \"init\", ug), p1(t, \"afterGetTitlePosition\", uo), p1(t, \"afterInit\", ur), p1(t, \"afterRender\", un), p1(t, \"afterSetAxisTranslation\", ua), p1(t, \"afterSetOptions\", uh), p1(t, \"afterSetOptions\", ul), p1(t, \"afterSetScale\", ud), p1(t, \"afterTickSize\", uc), p1(t, \"trimTicks\", ux), p1(t, \"destroy\", uu), p1(e, \"afterSetChartSize\", up), p1(i, \"afterGetLabelPosition\", uf), p1(i, \"labelFormat\", um)), t;\n      }\n    },\n    {\n      extend: uM,\n      isNumber: uk,\n      pick: uw\n    } = tt;\n  function uS(t, e, i, s, o, r) {\n    let n = r && r.after,\n      a = r && r.before,\n      h = {\n        data: s,\n        depth: i - 1,\n        id: t,\n        level: i,\n        parent: e || \"\"\n      },\n      l = 0,\n      d = 0,\n      c,\n      p;\n    \"function\" == typeof a && a(h, r);\n    let u = (o[t] || []).map(e => {\n      let s = uS(e.id, t, i + 1, e, o, r),\n        n = e.start || NaN,\n        a = !0 === e.milestone ? n : e.end || NaN;\n      return c = !uk(c) || n < c ? n : c, p = !uk(p) || a > p ? a : p, l = l + 1 + s.descendants, d = Math.max(s.height + 1, d), s;\n    });\n    return s && (s.start = uw(s.start, c), s.end = uw(s.end, p)), uM(h, {\n      children: u,\n      descendants: l,\n      height: d\n    }), \"function\" == typeof n && n(h, r), h;\n  }\n  let uA = {\n      getNode: uS,\n      getTree: function (t, e) {\n        return uS(\"\", null, 1, null, function (t) {\n          let e = [],\n            i = t.reduce((t, i) => {\n              let {\n                parent: s = \"\",\n                id: o\n              } = i;\n              return void 0 === t[s] && (t[s] = []), t[s].push(i), o && e.push(o), t;\n            }, {});\n          return Object.keys(i).forEach(t => {\n            if (\"\" !== t && -1 === e.indexOf(t)) {\n              let e = i[t].map(function (t) {\n                let {\n                  ...e\n                } = t;\n                return e;\n              });\n              i[\"\"].push(...e), delete i[t];\n            }\n          }), i;\n        }(t), e);\n      }\n    },\n    {\n      addEvent: uT,\n      removeEvent: uP,\n      isObject: uC,\n      isNumber: uO,\n      pick: uE,\n      wrap: uL\n    } = tt;\n  function uB() {\n    this.treeGrid || (this.treeGrid = new uR(this));\n  }\n  function uI(t, e, i, s, o, r, n, a, h) {\n    let l, d, c;\n    let p = uE(this.options && this.options.labels, r),\n      u = this.pos,\n      g = this.axis,\n      f = \"treegrid\" === g.type,\n      m = t.apply(this, [e, i, s, o, p, n, a, h]);\n    if (f) {\n      let {\n          width: t = 0,\n          padding: e = g.linkedParent ? 0 : 5\n        } = p && uC(p.symbol, !0) ? p.symbol : {},\n        i = p && uO(p.indentation) ? p.indentation : 0;\n      c = (d = (l = g.treeGrid.mapOfPosToGridNode) && l[u]) && d.depth || 1, m.x += t + 2 * e + (c - 1) * i;\n    }\n    return m;\n  }\n  function uD(t) {\n    let e, i, s;\n    let {\n        pos: o,\n        axis: r,\n        label: n,\n        treeGrid: a,\n        options: h\n      } = this,\n      l = a?.labelIcon,\n      d = n?.element,\n      {\n        treeGrid: c,\n        options: p,\n        chart: u,\n        tickPositions: g\n      } = r,\n      f = c.mapOfPosToGridNode,\n      m = uE(h?.labels, p?.labels),\n      x = m && uC(m.symbol, !0) ? m.symbol : {},\n      y = f && f[o],\n      {\n        descendants: b,\n        depth: v\n      } = y || {},\n      M = y && b && b > 0,\n      k = \"treegrid\" === r.type && d,\n      w = g.indexOf(o) > -1,\n      S = \"highcharts-treegrid-node-\",\n      A = S + \"level-\",\n      T = u.styledMode;\n    k && y && n.removeClass(RegExp(A + \".*\")).addClass(A + v), t.apply(this, Array.prototype.slice.call(arguments, 1)), k && M ? (e = c.isCollapsed(y), function (t, e) {\n      let i = t.treeGrid,\n        s = !i.labelIcon,\n        o = e.renderer,\n        r = e.xy,\n        n = e.options,\n        a = n.width || 0,\n        h = n.height || 0,\n        l = n.padding ?? t.axis.linkedParent ? 0 : 5,\n        d = {\n          x: r.x - a / 2 - l,\n          y: r.y - h / 2\n        },\n        c = e.collapsed ? 90 : 180,\n        p = e.show && uO(d.y),\n        u = i.labelIcon;\n      u || (i.labelIcon = u = o.path(o.symbols[n.type](n.x || 0, n.y || 0, a, h)).addClass(\"highcharts-label-icon\").add(e.group)), u[p ? \"show\" : \"hide\"](), o.styledMode || u.attr({\n        cursor: \"pointer\",\n        fill: uE(e.color, \"#666666\"),\n        \"stroke-width\": 1,\n        stroke: n.lineColor,\n        strokeWidth: n.lineWidth || 0\n      }), u[s ? \"attr\" : \"animate\"]({\n        translateX: d.x,\n        translateY: d.y,\n        rotation: c\n      });\n    }(this, {\n      color: !T && n.styles.color || \"\",\n      collapsed: e,\n      group: n.parentGroup,\n      options: x,\n      renderer: n.renderer,\n      show: w,\n      xy: n.xy\n    }), i = S + (e ? \"collapsed\" : \"expanded\"), s = S + (e ? \"expanded\" : \"collapsed\"), n.addClass(i).removeClass(s), T || n.css({\n      cursor: \"pointer\"\n    }), [n, l].forEach(t => {\n      t && !t.attachedTreeGridEvents && (uT(t.element, \"mouseover\", function () {\n        n.addClass(\"highcharts-treegrid-node-active\"), n.renderer.styledMode || n.css({\n          textDecoration: \"underline\"\n        });\n      }), uT(t.element, \"mouseout\", function () {\n        !function (t, e) {\n          let i = uC(e.style) ? e.style : {};\n          t.removeClass(\"highcharts-treegrid-node-active\"), t.renderer.styledMode || t.css({\n            textDecoration: i.textDecoration || \"none\"\n          });\n        }(n, m);\n      }), uT(t.element, \"click\", function () {\n        a.toggleCollapse();\n      }), t.attachedTreeGridEvents = !0);\n    })) : l && (uP(d), n?.css({\n      cursor: \"default\"\n    }), l.destroy());\n  }\n  class uR {\n    static compose(t) {\n      let e = t.prototype;\n      e.toggleCollapse || (uT(t, \"init\", uB), uL(e, \"getLabelPosition\", uI), uL(e, \"renderLabel\", uD), e.collapse = function (t) {\n        this.treeGrid.collapse(t);\n      }, e.expand = function (t) {\n        this.treeGrid.expand(t);\n      }, e.toggleCollapse = function (t) {\n        this.treeGrid.toggleCollapse(t);\n      });\n    }\n    constructor(t) {\n      this.tick = t;\n    }\n    collapse(t) {\n      let e = this.tick,\n        i = e.axis,\n        s = i.brokenAxis;\n      if (s && i.treeGrid.mapOfPosToGridNode) {\n        let o = e.pos,\n          r = i.treeGrid.mapOfPosToGridNode[o],\n          n = i.treeGrid.collapse(r);\n        s.setBreaks(n, uE(t, !0));\n      }\n    }\n    destroy() {\n      this.labelIcon && this.labelIcon.destroy();\n    }\n    expand(t) {\n      let {\n          pos: e,\n          axis: i\n        } = this.tick,\n        {\n          treeGrid: s,\n          brokenAxis: o\n        } = i,\n        r = s.mapOfPosToGridNode;\n      if (o && r) {\n        let i = r[e],\n          n = s.expand(i);\n        o.setBreaks(n, uE(t, !0));\n      }\n    }\n    toggleCollapse(t) {\n      let e = this.tick,\n        i = e.axis,\n        s = i.brokenAxis;\n      if (s && i.treeGrid.mapOfPosToGridNode) {\n        let o = e.pos,\n          r = i.treeGrid.mapOfPosToGridNode[o],\n          n = i.treeGrid.toggleCollapse(r);\n        s.setBreaks(n, uE(t, !0));\n      }\n    }\n  }\n  let {\n      extend: uN,\n      isArray: uz,\n      isNumber: uW,\n      isObject: uG,\n      merge: uH,\n      pick: uF,\n      relativeLength: uX\n    } = tt,\n    {\n      getLevelOptions: uY\n    } = {\n      getColor: function (t, e) {\n        let i, s, o, r, n, a;\n        let h = e.index,\n          l = e.mapOptionsToLevel,\n          d = e.parentColor,\n          c = e.parentColorIndex,\n          p = e.series,\n          u = e.colors,\n          g = e.siblings,\n          f = p.points,\n          m = p.chart.options.chart;\n        return t && (i = f[t.i], s = l[t.level] || {}, i && s.colorByPoint && (r = i.index % (u ? u.length : m.colorCount), o = u && u[r]), p.chart.styledMode || (n = uF(i && i.options.color, s && s.color, o, d && (t => {\n          let e = s && s.colorVariation;\n          return e && \"brightness\" === e.key && h && g ? tO.parse(t).brighten(e.to * (h / g)).get() : t;\n        })(d), p.color)), a = uF(i && i.options.colorIndex, s && s.colorIndex, r, c, e.colorIndex)), {\n          color: n,\n          colorIndex: a\n        };\n      },\n      getLevelOptions: function (t) {\n        let e, i, s, o, r, n;\n        let a = {};\n        if (uG(t)) for (o = uW(t.from) ? t.from : 1, n = t.levels, i = {}, e = uG(t.defaults) ? t.defaults : {}, uz(n) && (i = n.reduce((t, i) => {\n          let s, r, n;\n          return uG(i) && uW(i.level) && (r = uF((n = uH({}, i)).levelIsConstant, e.levelIsConstant), delete n.levelIsConstant, delete n.level, uG(t[s = i.level + (r ? 0 : o - 1)]) ? uH(!0, t[s], n) : t[s] = n), t;\n        }, {})), r = uW(t.to) ? t.to : 1, s = 0; s <= r; s++) a[s] = uH({}, e, uG(i[s]) ? i[s] : {});\n        return a;\n      },\n      getNodeWidth: function (t, e) {\n        let {\n            chart: i,\n            options: s\n          } = t,\n          {\n            nodeDistance: o = 0,\n            nodeWidth: r = 0\n          } = s,\n          {\n            plotSizeX: n = 1\n          } = i;\n        if (\"auto\" === r) {\n          if (\"string\" == typeof o && /%$/.test(o)) return n / (e + parseFloat(o) / 100 * (e - 1));\n          let t = Number(o);\n          return (n + t) / (e || 1) - t;\n        }\n        return uX(r, n);\n      },\n      setTreeValues: function t(e, i) {\n        let s = i.before,\n          o = i.idRoot,\n          r = i.mapIdToNode[o],\n          n = !1 !== i.levelIsConstant,\n          a = i.points[e.i],\n          h = a && a.options || {},\n          l = [],\n          d = 0;\n        e.levelDynamic = e.level - (n ? 0 : r.level), e.name = uF(a && a.name, \"\"), e.visible = o === e.id || !0 === i.visible, \"function\" == typeof s && (e = s(e, i)), e.children.forEach((s, o) => {\n          let r = uN({}, i);\n          uN(r, {\n            index: o,\n            siblings: e.children.length,\n            visible: e.visible\n          }), s = t(s, r), l.push(s), s.visible && (d += s.val);\n        });\n        let c = uF(h.value, d);\n        return e.visible = c >= 0 && (d > 0 || e.visible), e.children = l, e.childrenTotal = d, e.isLeaf = e.visible && !d, e.val = c, e;\n      },\n      updateRootId: function (t) {\n        let e, i;\n        return uG(t) && (i = uG(t.options) ? t.options : {}, e = uF(t.rootNode, i.rootId, \"\"), uG(t.userOptions) && (t.userOptions.rootId = e), t.rootNode = e), e;\n      }\n    },\n    {\n      addEvent: uj,\n      isArray: uU,\n      splat: uV,\n      find: u$,\n      fireEvent: u_,\n      isObject: uq,\n      isString: uZ,\n      merge: uK,\n      pick: uJ,\n      removeEvent: uQ,\n      wrap: u0\n    } = tt;\n  function u1(t, e) {\n    let i = t.collapseEnd || 0,\n      s = t.collapseStart || 0;\n    return i >= e && (s -= .5), {\n      from: s,\n      to: i,\n      showPoints: !1\n    };\n  }\n  function u2(t, e, i) {\n    let s = [],\n      o = [],\n      r = {},\n      n = e || !1,\n      a = {},\n      h = -1,\n      l = uA.getTree(t, {\n        after: function (t) {\n          let e = a[t.pos],\n            i = 0,\n            s = 0;\n          e.children.forEach(function (t) {\n            s += (t.descendants || 0) + 1, i = Math.max((t.height || 0) + 1, i);\n          }), e.descendants = s, e.height = i, e.collapsed && o.push(e);\n        },\n        before: function (t) {\n          let e, i;\n          let o = uq(t.data, !0) ? t.data : {},\n            l = uZ(o.name) ? o.name : \"\",\n            d = r[t.parent],\n            c = uq(d, !0) ? a[d.pos] : null;\n          n && uq(c, !0) && (e = u$(c.children, function (t) {\n            return t.name === l;\n          })) ? (i = e.pos, e.nodes.push(t)) : i = h++, !a[i] && (a[i] = e = {\n            depth: c ? c.depth + 1 : 0,\n            name: l,\n            id: o.id,\n            nodes: [t],\n            children: [],\n            pos: i\n          }, -1 !== i && s.push(l), uq(c, !0) && c.children.push(e)), uZ(t.id) && (r[t.id] = t), e && !0 === o.collapsed && (e.collapsed = !0), t.pos = i;\n        }\n      });\n    return {\n      categories: s,\n      mapOfIdToNode: r,\n      mapOfPosToGridNode: a = function (t, e) {\n        let i = function (t, s, o) {\n          let r = t.nodes,\n            n = s + (-1 === s ? 0 : e - 1),\n            a = (n - s) / 2,\n            h = s + a;\n          return r.forEach(function (t) {\n            let e = t.data;\n            uq(e, !0) && (e.y = s + (e.seriesIndex || 0), delete e.seriesIndex), t.pos = h;\n          }), o[h] = t, t.pos = h, t.tickmarkOffset = a + .5, t.collapseStart = n + .5, t.children.forEach(function (t) {\n            i(t, n + 1, o), n = (t.collapseEnd || 0) - .5;\n          }), t.collapseEnd = n + .5, o;\n        };\n        return i(t[\"-1\"], -1, {});\n      }(a, i),\n      collapsedNodes: o,\n      tree: l\n    };\n  }\n  function u3(t) {\n    let e = t.target;\n    e.axes.filter(t => \"treegrid\" === t.type).forEach(function (i) {\n      let s = i.options || {},\n        o = s.labels,\n        r = i.uniqueNames,\n        n = e.time.parse(s.max),\n        a = !i.treeGrid.mapOfPosToGridNode || i.series.some(function (t) {\n          return !t.hasRendered || t.isDirtyData || t.isDirty;\n        }),\n        h = 0,\n        l,\n        d;\n      if (a) {\n        let s = [];\n        if (l = i.series.reduce(function (t, i) {\n          let o = i.options.data || [],\n            n = o[0],\n            a = Array.isArray(n) && !n.find(t => \"object\" == typeof t);\n          return s.push(a), i.visible && (o.forEach(function (s) {\n            (a || i.options.keys && i.options.keys.length) && (s = i.pointClass.prototype.optionsToObject.call({\n              series: i\n            }, s), i.pointClass.setGanttPointAliases(s, e)), uq(s, !0) && (s.seriesIndex = h, t.push(s));\n          }), !0 === r && h++), t;\n        }, []), n && l.length < n) for (let t = l.length; t <= n; t++) l.push({\n          name: t + \"​\"\n        });\n        d = u2(l, r || !1, !0 === r ? h : 1), i.categories = d.categories, i.treeGrid.mapOfPosToGridNode = d.mapOfPosToGridNode, i.hasNames = !0, i.treeGrid.tree = d.tree, i.series.forEach(function (t, e) {\n          let i = (t.options.data || []).map(function (i) {\n            return (s[e] || uU(i) && t.options.keys && t.options.keys.length) && l.forEach(function (t) {\n              let e = uV(i);\n              e.indexOf(t.x || 0) >= 0 && e.indexOf(t.x2 || 0) >= 0 && (i = t);\n            }), uq(i, !0) ? uK(i) : i;\n          });\n          t.visible && t.setData(i, !1);\n        }), i.treeGrid.mapOptionsToLevel = uY({\n          defaults: o,\n          from: 1,\n          levels: o && o.levels,\n          to: i.treeGrid.tree && i.treeGrid.tree.height\n        }), \"beforeRender\" === t.type && (i.treeGrid.collapsedNodes = d.collapsedNodes);\n      }\n    });\n  }\n  function u5(t, e) {\n    let i = this.treeGrid.mapOptionsToLevel || {},\n      s = \"treegrid\" === this.type,\n      r = this.ticks,\n      n = r[e],\n      a,\n      h,\n      l;\n    s && this.treeGrid.mapOfPosToGridNode ? ((a = i[(l = this.treeGrid.mapOfPosToGridNode[e]).depth]) && (h = {\n      labels: a\n    }), !n && o ? r[e] = n = new o(this, e, void 0, void 0, {\n      category: l.name,\n      tickmarkOffset: l.tickmarkOffset,\n      options: h\n    }) : (n.parameters.category = l.name, n.options = h, n.addLabel())) : t.apply(this, Array.prototype.slice.call(arguments, 1));\n  }\n  function u6(t, e, i, s) {\n    let o = this,\n      r = \"treegrid\" === i.type;\n    o.treeGrid || (o.treeGrid = new u8(o)), r && (uj(e, \"beforeRender\", u3), uj(e, \"beforeRedraw\", u3), uj(e, \"addSeries\", function (t) {\n      if (t.options.data) {\n        let e = u2(t.options.data, i.uniqueNames || !1, 1);\n        o.treeGrid.collapsedNodes = (o.treeGrid.collapsedNodes || []).concat(e.collapsedNodes);\n      }\n    }), uj(o, \"foundExtremes\", function () {\n      o.treeGrid.collapsedNodes && o.treeGrid.collapsedNodes.forEach(function (t) {\n        let e = o.treeGrid.collapse(t);\n        o.brokenAxis && (o.brokenAxis.setBreaks(e, !1), o.treeGrid.collapsedNodes && (o.treeGrid.collapsedNodes = o.treeGrid.collapsedNodes.filter(e => t.collapseStart !== e.collapseStart || t.collapseEnd !== e.collapseEnd)));\n      });\n    }), uj(o, \"afterBreaks\", function () {\n      \"yAxis\" === o.coll && !o.staticScale && o.chart.options.chart.height && (o.isDirty = !0);\n    }), i = uK({\n      grid: {\n        enabled: !0\n      },\n      labels: {\n        align: \"left\",\n        levels: [{\n          level: void 0\n        }, {\n          level: 1,\n          style: {\n            fontWeight: \"bold\"\n          }\n        }],\n        symbol: {\n          type: \"triangle\",\n          x: -5,\n          y: -5,\n          height: 10,\n          width: 10\n        }\n      },\n      uniqueNames: !1\n    }, i, {\n      reversed: !0\n    })), t.apply(o, [e, i, s]), r && (o.hasNames = !0, o.options.showLastLabel = !0);\n  }\n  function u9(t) {\n    let e = this.options,\n      i = this.chart.time,\n      s = \"number\" == typeof e.linkedTo ? this.chart[this.coll]?.[e.linkedTo] : void 0;\n    if (\"treegrid\" === this.type) {\n      if (this.min = this.userMin ?? i.parse(e.min) ?? this.dataMin, this.max = this.userMax ?? i.parse(e.max) ?? this.dataMax, u_(this, \"foundExtremes\"), this.setAxisTranslation(), this.tickInterval = 1, this.tickmarkOffset = .5, this.tickPositions = this.treeGrid.mapOfPosToGridNode ? this.treeGrid.getTickPositions() : [], s) {\n        let t = s.getExtremes();\n        this.min = uJ(t.min, t.dataMin), this.max = uJ(t.max, t.dataMax), this.tickPositions = s.tickPositions;\n      }\n      this.linkedParent = s;\n    } else t.apply(this, Array.prototype.slice.call(arguments, 1));\n  }\n  function u4(t) {\n    let e = this;\n    \"treegrid\" === this.type && e.visible && e.tickPositions.forEach(function (t) {\n      let i = e.ticks[t];\n      i.label && i.label.attachedTreeGridEvents && (uQ(i.label.element), i.label.attachedTreeGridEvents = !1);\n    }), t.apply(e, Array.prototype.slice.call(arguments, 1));\n  }\n  class u8 {\n    static compose(t, e, i, s) {\n      if (!t.keepProps.includes(\"treeGrid\")) {\n        let e = t.prototype;\n        t.keepProps.push(\"treeGrid\"), u0(e, \"generateTick\", u5), u0(e, \"init\", u6), u0(e, \"setTickInterval\", u9), u0(e, \"redraw\", u4), e.utils = {\n          getNode: uA.getNode\n        }, o || (o = s);\n      }\n      return uv.compose(t, e, s), pQ.compose(t, i), uR.compose(s), t;\n    }\n    constructor(t) {\n      this.axis = t;\n    }\n    setCollapsedStatus(t) {\n      let e = this.axis,\n        i = e.chart;\n      e.series.forEach(function (e) {\n        let s = e.options.data;\n        if (t.id && s) {\n          let o = i.get(t.id),\n            r = s[e.data.indexOf(o)];\n          o && r && (o.collapsed = t.collapsed, r.collapsed = t.collapsed);\n        }\n      });\n    }\n    collapse(t) {\n      let e = this.axis,\n        i = e.options.breaks || [],\n        s = u1(t, e.max);\n      return i.push(s), t.collapsed = !0, e.treeGrid.setCollapsedStatus(t), i;\n    }\n    expand(t) {\n      let e = this.axis,\n        i = e.options.breaks || [],\n        s = u1(t, e.max);\n      return t.collapsed = !1, e.treeGrid.setCollapsedStatus(t), i.reduce(function (t, e) {\n        return (e.to !== s.to || e.from !== s.from) && t.push(e), t;\n      }, []);\n    }\n    getTickPositions() {\n      let t = this.axis,\n        e = Math.floor(t.min / t.tickInterval) * t.tickInterval,\n        i = Math.ceil(t.max / t.tickInterval) * t.tickInterval;\n      return Object.keys(t.treeGrid.mapOfPosToGridNode || {}).reduce(function (s, o) {\n        let r = +o;\n        return r >= e && r <= i && !(t.brokenAxis && t.brokenAxis.isInAnyBreak(r)) && s.push(r), s;\n      }, []);\n    }\n    isCollapsed(t) {\n      let e = this.axis,\n        i = e.options.breaks || [],\n        s = u1(t, e.max);\n      return i.some(function (t) {\n        return t.from === s.from && t.to === s.to;\n      });\n    }\n    toggleCollapse(t) {\n      return this.isCollapsed(t) ? this.expand(t) : this.collapse(t);\n    }\n  }\n  let {\n      series: u7,\n      seriesTypes: {\n        xrange: gt\n      }\n    } = ry,\n    {\n      extend: ge,\n      isNumber: gi,\n      merge: gs\n    } = tt;\n  class go extends gt {\n    static compose(t, e, i, s) {\n      gt.compose(t), e && (pb.compose(t, e), i) && (pp.compose(e, i.prototype.pointClass), s && u8.compose(t, e, i, s));\n    }\n    drawPoint(t, e) {\n      let i = this.options,\n        s = this.chart.renderer,\n        o = t.shapeArgs,\n        r = t.plotY,\n        n = t.selected && \"select\",\n        a = i.stacking && !i.borderRadius,\n        h = t.graphic,\n        l;\n      t.options.milestone ? gi(r) && null !== t.y && !1 !== t.visible ? (l = s.symbols.diamond(o.x || 0, o.y || 0, o.width || 0, o.height || 0), h ? h[e]({\n        d: l\n      }) : t.graphic = h = s.path(l).addClass(t.getClassName(), !0).add(t.group || this.group), this.chart.styledMode || t.graphic.attr(this.pointAttribs(t, n)).shadow(i.shadow, null, a)) : h && (t.graphic = h.destroy()) : super.drawPoint(t, e);\n    }\n    translatePoint(t) {\n      let e, i;\n      super.translatePoint(t), t.options.milestone && (i = (e = t.shapeArgs).height || 0, t.shapeArgs = {\n        x: (e.x || 0) - i / 2,\n        y: e.y,\n        width: i,\n        height: i\n      });\n    }\n  }\n  go.defaultOptions = gs(gt.defaultOptions, {\n    grouping: !1,\n    dataLabels: {\n      enabled: !0\n    },\n    tooltip: {\n      headerFormat: '<span style=\"font-size: 0.8em\">{series.name}</span><br/>',\n      pointFormat: null,\n      pointFormatter: function () {\n        let t = this.series,\n          e = t.xAxis,\n          i = t.tooltipOptions.dateTimeLabelFormats,\n          s = e.options.startOfWeek,\n          o = t.tooltipOptions,\n          r = this.options.milestone,\n          n = o.xDateFormat,\n          a = \"<b>\" + (this.name || this.yCategory) + \"</b>\";\n        if (o.pointFormat) return this.tooltipFormatter(o.pointFormat);\n        !n && pV(this.start) && (n = t.chart.time.getDateFormat(e.closestPointRange, this.start, s, i || {}));\n        let h = t.chart.time.dateFormat(n, this.start),\n          l = t.chart.time.dateFormat(n, this.end);\n        return a += \"<br/>\", r ? a += h + \"<br/>\" : a += \"Start: \" + h + \"<br/>End: \" + l + \"<br/>\", a;\n      }\n    },\n    connectors: {\n      type: \"simpleConnect\",\n      animation: {\n        reversed: !0\n      },\n      radius: 0,\n      startMarker: {\n        enabled: !0,\n        symbol: \"arrow-filled\",\n        radius: 4,\n        fill: \"#fa0\",\n        align: \"left\"\n      },\n      endMarker: {\n        enabled: !1,\n        align: \"right\"\n      }\n    }\n  }), ge(go.prototype, {\n    pointArrayMap: [\"start\", \"end\", \"y\"],\n    pointClass: pU,\n    setData: u7.prototype.setData\n  }), ry.registerSeriesType(\"gantt\", go), O.Connection = O.Connection || lH, O.GanttChart = O.GanttChart || l1, O.Navigator = O.Navigator || cs, O.RangeSelector = O.RangeSelector || cK, O.Scrollbar = O.Scrollbar || d$, O.ganttChart = O.GanttChart.ganttChart, lB.compose(O.SVGRenderer), {\n    compose: function (t, e) {\n      lj(lF, \"CurrentDateIndication\") && (lX(t, \"afterSetOptions\", l$), lX(e, \"render\", l_), lU(e.prototype, \"getLabelText\", lq));\n    }\n  }.compose(O.Axis, O.PlotLineOrBand), go.compose(O.Axis, O.Chart, O.Series, O.Tick), O.Navigator.compose(O.Chart, O.Axis, O.Series), O.RangeSelector.compose(O.Axis, O.Chart), O.Scrollbar.compose(O.Axis),\n  /**\n  * @license Highcharts Gantt JS v12.1.2 (2024-12-21)\n  * @module highcharts/highcharts-gantt\n  *\n  * (c) 2017-2024 Lars Cabrera, Torstein Honsi, Jon Arild Nygard & Oystein Moseng\n  *\n  * License: www.highcharts.com/license\n  */\n  O.product = \"Highcharts Gantt\";\n  let gr = O;\n  return C.default;\n})());","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}